# nomenclatures/services/document_service.py - –¶–Ø–õ–û–°–¢–ï–ù –ö–û–î
"""
Document Service - COMPLETE VERSION

–õ–û–ì–ò–ö–ê:
1. –ê–∫–æ DocumentType.requires_approval=True ‚Üí –∏–∑–ø–æ–ª–∑–≤–∞ ApprovalRule workflow
2. –ê–∫–æ DocumentType.requires_approval=False ‚Üí –∏–∑–ø–æ–ª–∑–≤–∞ —Å–∞–º–æ DocumentTypeStatus –Ω–∞—Å—Ç—Ä–æ–π–∫–∏
3. –ü–æ–¥–¥—ä—Ä–∂–∞ –º–∞–ª–∫–∏ –º–∞–≥–∞–∑–∏–Ω–∏ –±–µ–∑ —Å–ª–æ–∂–Ω–∏ –æ–¥–æ–±—Ä–µ–Ω–∏—è
4. –ü–æ–¥–¥—ä—Ä–∂–∞ –µ–¥–∏—Ç–∏—Ä–∞–Ω–µ –Ω–∞ completed –¥–æ–∫—É–º–µ–Ω—Ç–∏ (allow_edit_completed)
"""

from typing import Dict, List, Optional, Any, Type, Union, Tuple, TYPE_CHECKING

if TYPE_CHECKING:
    from django.db import models as django_models
from dataclasses import dataclass, field
from django.db import transaction, models
from django.contrib.contenttypes.models import ContentType
from django.contrib.auth import get_user_model
from django.utils import timezone
from django.apps import apps
import logging

User = get_user_model()
logger = logging.getLogger(__name__)


# =====================
# RESULT TYPES (–£–Ω–∏—Ñ–∏—Ü–∏—Ä–∞–Ω–∏ —Å ApprovalService)
# =====================

@dataclass
class Result:
    """–£–Ω–∏—Ñ–∏—Ü–∏—Ä–∞–Ω —Ä–µ–∑—É–ª—Ç–∞—Ç –∑–∞ –≤—Å–∏—á–∫–∏ services"""
    ok: bool
    code: Optional[str] = None
    msg: Optional[str] = None
    data: Dict[str, Any] = field(default_factory=dict)

    @classmethod
    def success(cls, data: Dict = None, msg: str = None) -> 'Result':
        return cls(ok=True, data=data or {}, msg=msg)

    @classmethod
    def error(cls, code: str, msg: str, data: Dict = None) -> 'Result':
        return cls(ok=False, code=code, msg=msg, data=data or {})


class DocumentService:
    """
    Document Service - CENTRAL ORCHESTRATOR

    –ü–æ–¥–¥—ä—Ä–∂–∞ –∏ —Å–ª–æ–∂–Ω–∏ approval workflows –∏ –ø—Ä–æ—Å—Ç–∏ status transitions.
    """

    # =====================
    # DOCUMENT CREATION
    # =====================

    @staticmethod
    @transaction.atomic
    def create_document(model_class,
                        data: Dict[str, Any],
                        user: User,
                        location: Optional[Any] = None) -> Result:
        """
        Create document with automatic numbering and initial status
        """
        try:
            # 1. Get DocumentType
            document_type = DocumentService._get_document_type_for_model(model_class)
            if not document_type:
                return Result.error(
                    'DOCUMENT_TYPE_NOT_FOUND',
                    f'No DocumentType found for {model_class.__name__}'
                )

            # 2. Extract location
            location = location or data.get('location')
            if not location:
                return Result.error('LOCATION_REQUIRED', 'Location is required for document creation')

            # 3. Generate document number
            document_number = DocumentService._generate_document_number(
                document_type, location, user
            )

            # 4. Get initial status
            initial_status = DocumentService._get_initial_status(document_type)

            # 5. Prepare document data
            document_data = {
                **data,
                'document_type': document_type,
                'document_number': document_number,
                'status': initial_status,
                'created_by': user,
                'location': location,
            }

            # 6. Create document instance
            document = model_class(**document_data)
            document.full_clean()
            document.save()

            logger.info(f"Created {model_class.__name__} {document_number} by {user.username}")

            return Result.success(
                data={'document': document},
                msg=f'Document {document_number} created successfully'
            )

        except Exception as e:
            logger.error(f"Error creating {model_class.__name__}: {e}")
            return Result.error('DOCUMENT_CREATION_FAILED', str(e))

    @staticmethod
    def create_purchase_request(supplier, location, user, lines_data=None, **kwargs) -> Result:
        """Create Purchase Request with lines"""
        try:
            PurchaseRequest = apps.get_model('purchases', 'PurchaseRequest')
            PurchaseRequestLine = apps.get_model('purchases', 'PurchaseRequestLine')

            with transaction.atomic():
                # Create main document
                data = {
                    'supplier': supplier,
                    'location': location,
                    **kwargs
                }

                result = DocumentService.create_document(PurchaseRequest, data, user, location)
                if not result.ok:
                    return result

                request = result.data['document']

                # Create lines if provided
                if lines_data:
                    for line_data in lines_data:
                        line = PurchaseRequestLine(
                            document=request,
                            **line_data
                        )
                        line.full_clean()
                        line.save()

                return Result.success(
                    data={'document': request},
                    msg=f'Purchase Request {request.document_number} created with {len(lines_data) if lines_data else 0} lines'
                )

        except Exception as e:
            return Result.error('REQUEST_CREATION_FAILED', str(e))

    # =====================
    # STATUS TRANSITIONS - –ì–õ–ê–í–ù–ê–¢–ê –õ–û–ì–ò–ö–ê
    # =====================

    @staticmethod
    @transaction.atomic
    def transition_document(document, to_status: str, user: User,
                            comments: str = '', **kwargs) -> Result:
        """
        Execute document status transition - COMPLETE FIXED VERSION

        –õ–û–ì–ò–ö–ê:
        1. –ê–∫–æ requires_approval=True ‚Üí ApprovalService authorization + ApprovalRule
        2. –ê–∫–æ requires_approval=False ‚Üí DocumentTypeStatus validation –°–ê–ú–û
        3. –í–∏–Ω–∞–≥–∏ business validation
        4. State change + conditional logging
        """
        try:
            from_status = document.status

            logger.info(f"üîÑ Transitioning {document.document_number}: {from_status} ‚Üí {to_status}")

            # Lock document –∑–∞ race condition protection
            document = document.__class__.objects.select_for_update().get(pk=document.pk)

            # –ò–¥–µ–º–ø–æ—Ç–µ–Ω—Ç–Ω–æ—Å—Ç
            if document.status == to_status:
                return Result.success(
                    data={'status': to_status},
                    msg=f'Document already in status {to_status}'
                )

            # 1. –û–°–ù–û–í–ù–ê –í–ê–õ–ò–î–ê–¶–ò–Ø
            if not document.document_type:
                logger.error(f"‚ùå Document {document.document_number} has no document_type")
                return Result.error('NO_DOCUMENT_TYPE', 'Document has no type configured')

            # 2. –°–¢–ê–¢–£–° –í–ê–õ–ò–î–ê–¶–ò–Ø (–≤–∏–Ω–∞–≥–∏ —Å–µ –ø—Ä–∞–≤–∏)
            logger.debug(f"üîç Validating status transition for {document.document_number}")
            status_result = DocumentService._validate_status_transition(document, to_status)
            if not status_result.ok:
                logger.error(f"‚ùå Status validation failed: {status_result.msg}")
                return status_result

            # 3. APPROVAL vs SIMPLE TRANSITION –õ–û–ì–ò–ö–ê
            approval_data = {}

            if document.document_type.requires_approval:
                # === APPROVAL WORKFLOW ===
                logger.debug(f"üîí Document requires approval - checking ApprovalService")
                try:
                    from .approval_service import ApprovalService

                    decision = ApprovalService.authorize_transition(document, user, to_status)
                    if not decision.allowed:
                        logger.warning(f"üö´ Approval denied: {decision.reason}")
                        return Result.error(
                            'AUTHORIZATION_DENIED',
                            decision.reason,
                            data={'rule_id': decision.rule_id, 'level': decision.level}
                        )

                    logger.info(f"‚úÖ Approval authorized by rule {decision.rule_id}")
                    approval_data = {
                        'rule_id': decision.rule_id,
                        'level': decision.level
                    }

                except ImportError:
                    logger.error("‚ùå ApprovalService not available but document requires approval")
                    return Result.error('APPROVAL_SERVICE_UNAVAILABLE', 'Approval system not available')

            else:
                # === SIMPLE TRANSITION (–º–∞–ª–∫–∏ –º–∞–≥–∞–∑–∏–Ω–∏) ===
                logger.debug(f"üü¢ Simple transition - no approval required")
                simple_result = DocumentService._validate_simple_transition(document, to_status, user)
                if not simple_result.ok:
                    logger.error(f"‚ùå Simple validation failed: {simple_result.msg}")
                    return simple_result

            # 4. BUSINESS VALIDATION
            logger.debug(f"üîß Validating business rules")
            business_result = DocumentService._validate_business_rules(
                document, to_status, user, **kwargs
            )
            if not business_result.ok:
                logger.error(f"‚ùå Business validation failed: {business_result.msg}")
                return business_result

            # 5. üöÄ EXECUTE TRANSITION
            logger.info(f"üöÄ Executing transition: {from_status} ‚Üí {to_status}")

            old_status = document.status
            document.status = to_status

            # Update audit fields
            if hasattr(document, 'updated_by'):
                document.updated_by = user
            if hasattr(document, 'approved_by') and 'approv' in to_status.lower():
                document.approved_by = user
            if hasattr(document, 'approved_at') and 'approv' in to_status.lower():
                document.approved_at = timezone.now()

            # üî• CRITICAL FIX: Save document immediately
            try:
                document.save()
                logger.info(f"üíæ Document saved with new status: {to_status}")
            except Exception as save_error:
                logger.error(f"‚ùå Failed to save document: {save_error}")
                return Result.error('SAVE_FAILED', f'Failed to save document: {save_error}')

            # 6. üî• CONDITIONAL LOGGING (fixed)
            try:
                if document.document_type.requires_approval:
                    # Log to ApprovalLog for approval workflows
                    logger.debug(f"üìù Logging to ApprovalLog")
                    DocumentService._log_transition(
                        document, approval_data.get('rule_id'), old_status, to_status, user, comments
                    )
                else:
                    # Log to Django admin log for simple transitions
                    logger.debug(f"üìù Logging to Admin log (simple transition)")
                    DocumentService._log_simple_transition(
                        document, old_status, to_status, user, comments
                    )
            except Exception as log_error:
                # Logging failure should NOT break the transition
                logger.warning(f"‚ö†Ô∏è Logging failed but transition succeeded: {log_error}")

            # 7. POST-TRANSITION EFFECTS
            try:
                logger.debug(f"üîÑ Executing post-transition actions")
                DocumentService._execute_post_transition_actions(
                    document, old_status, to_status, user, **kwargs
                )
            except Exception as post_error:
                logger.warning(f"‚ö†Ô∏è Post-transition actions failed: {post_error}")

            logger.info(f"‚úÖ Successfully transitioned {document.document_number} to {to_status}")

            return Result.success(
                data={
                    'document': document,
                    'from_status': old_status,
                    'to_status': to_status,
                    **approval_data
                },
                msg=f'Document transitioned from {old_status} to {to_status}'
            )

        except Exception as e:
            logger.error(f"üí• Error transitioning {document.document_number}: {e}")
            import traceback
            logger.error(f"Full traceback: {traceback.format_exc()}")
            return Result.error('TRANSITION_FAILED', str(e))

    # =====================
    # SMART CONVENIENCE METHODS
    # =====================

    @staticmethod
    def submit_for_approval(document, user: User, comments: str = '') -> Result:
        """Submit document for approval - SMART VERSION"""
        try:
            if not document.document_type.requires_approval:
                return Result.error(
                    'NO_APPROVAL_REQUIRED',
                    'This document type does not require approval'
                )

            from .approval_service import ApprovalService
            target_status = ApprovalService.find_submission_status(document)

            if not target_status:
                return Result.error(
                    'NO_SUBMISSION_STATUS',
                    'No submission status found for current state'
                )

            return DocumentService.transition_document(document, target_status, user, comments)

        except Exception as e:
            return Result.error('SUBMISSION_FAILED', str(e))

    @staticmethod
    def approve_document(document, user: User, comments: str = '') -> Result:
        """Approve document - SMART VERSION"""
        try:
            from .approval_service import ApprovalService

            target_status = ApprovalService.find_next_approval_status(document)
            if not target_status:
                return Result.error(
                    'NO_APPROVAL_STATUS',
                    'No approval status found for current state'
                )

            return DocumentService.transition_document(document, target_status, user, comments)

        except Exception as e:
            return Result.error('APPROVAL_FAILED', str(e))

    @staticmethod
    def reject_document(document, user: User, reason: str) -> Result:
        """Reject document - SMART VERSION"""
        try:
            from .approval_service import ApprovalService

            target_status = ApprovalService.find_rejection_status(document)
            if not target_status:
                return Result.error(
                    'NO_REJECTION_STATUS',
                    'No rejection status found for current state'
                )

            return DocumentService.transition_document(
                document, target_status, user, reason
            )

        except Exception as e:
            return Result.error('REJECTION_FAILED', str(e))

    # =====================
    # EDITING PERMISSIONS - –ó–ê –ö–û–†–ï–ö–¶–ò–ò
    # =====================

    @staticmethod
    def can_edit_document(document, user: User) -> Tuple[bool, str]:
        """
        –ü—Ä–æ–≤–µ—Ä–∏ –¥–∞–ª–∏ –¥–æ–∫—É–º–µ–Ω—Ç—ä—Ç –º–æ–∂–µ –¥–∞ —Å–µ —Ä–µ–¥–∞–∫—Ç–∏—Ä–∞

        –õ–û–ì–ò–ö–ê:
        - Draft —Å—Ç–∞—Ç—É—Å–∏: –≤–∏–Ω–∞–≥–∏ –º–æ–∂–µ
        - Completed —Å—Ç–∞—Ç—É—Å–∏: —Å–ø–æ—Ä–µ–¥ allow_edit_completed + permissions
        - Final —Å—Ç–∞—Ç—É—Å–∏: —Å–ø–æ—Ä–µ–¥ allow_edit_completed + admin permissions
        """
        try:
            if not document.document_type:
                return False, "Document has no type configured"

            # 1. –ü—Ä–æ–≤–µ—Ä–∏ current status type
            status_info = DocumentService._get_status_info(document)

            # 2. Draft/Initial —Å—Ç–∞—Ç—É—Å–∏ - –≤–∏–Ω–∞–≥–∏ –º–æ–∂–µ (–æ—Å–≤–µ–Ω –∞–∫–æ –Ω–µ –µ final)
            if status_info.get('is_initial') and not status_info.get('is_final'):
                return True, "Document is in draft state"

            # 3. Completed/Final —Å—Ç–∞—Ç—É—Å–∏ - –ø—Ä–æ–≤–µ—Ä–∏ allow_edit_completed
            if status_info.get('is_final') or 'complet' in document.status.lower():
                if not document.document_type.allow_edit_completed:
                    return False, "Completed documents cannot be edited"

                # –ü—Ä–æ–≤–µ—Ä–∫–∞ permissions –∑–∞ completed editing
                edit_check = DocumentService._check_completed_edit_permissions(document, user)
                if not edit_check['allowed']:
                    return False, edit_check['reason']

                return True, "Editing completed document allowed"

            # 4. In-progress —Å—Ç–∞—Ç—É—Å–∏ - –∑–∞–≤–∏—Å–∏ –æ—Ç workflow
            if document.document_type.requires_approval:
                # Approval workflow - –ø—Ä–æ–≤–µ—Ä–∏ ApprovalRule permissions
                from .approval_service import ApprovalService
                transitions = ApprovalService.get_available_transitions(document, user)

                if not transitions:
                    return False, "No available actions for current user"

                return True, "Document is in workflow and user has permissions"
            else:
                # Simple workflow - –≤–∏–Ω–∞–≥–∏ –º–æ–∂–µ –∞–∫–æ –Ω–µ –µ final
                return True, "Document is editable"

        except Exception as e:
            logger.error(f"Error checking edit permissions: {e}")
            return False, f"Error checking permissions: {e}"

    @staticmethod
    def _check_completed_edit_permissions(document, user: User) -> Dict:
        """–ü—Ä–æ–≤–µ—Ä–∏ permissions –∑–∞ editing –Ω–∞ completed –¥–æ–∫—É–º–µ–Ω—Ç–∏"""
        try:
            # 1. Creator –≤–∏–Ω–∞–≥–∏ –º–æ–∂–µ (–∞–∫–æ –Ω—è–º–∞ restrictions)
            if hasattr(document, 'created_by') and document.created_by == user:
                return {'allowed': True, 'reason': 'Document creator'}

            # 2. Admin permissions
            if user.is_superuser:
                return {'allowed': True, 'reason': 'Superuser permissions'}

            # 3. Specific permissions –∑–∞ editing completed
            perm_name = f'{document._meta.app_label}.edit_completed_{document._meta.model_name}'
            if user.has_perm(perm_name):
                return {'allowed': True, 'reason': 'Has edit_completed permission'}

            # 4. Manager role check
            if user.groups.filter(name__icontains='manager').exists():
                return {'allowed': True, 'reason': 'Manager role'}

            return {'allowed': False, 'reason': 'Insufficient permissions to edit completed document'}

        except Exception as e:
            return {'allowed': False, 'reason': f'Error checking permissions: {e}'}

    # =====================
    # STATUS VALIDATION METHODS
    # =====================

    @staticmethod
    def _validate_status_transition(document, to_status: str) -> Result:
        """–ü—Ä–æ–≤–µ—Ä–∏ –¥–∞–ª–∏ to_status –µ –≤–∞–ª–∏–¥–µ–Ω –∑–∞ document_type"""
        try:
            # –ü—Ä–æ–≤–µ—Ä–∏ –¥–∞–ª–∏ to_status —Å—ä—â–µ—Å—Ç–≤—É–≤–∞ –≤ DocumentTypeStatus
            from ..models.statuses import DocumentTypeStatus

            status_config = DocumentTypeStatus.objects.filter(
                document_type=document.document_type,
                status__code=to_status,
                is_active=True
            ).first()

            if not status_config:
                # –ù–∞–º–µ—Ä–∏ –∫–∞–∫–≤–∏ —Å—Ç–∞—Ç—É—Å–∏ —Å–∞ –∫–æ–Ω—Ñ–∏–≥—É—Ä–∏—Ä–∞–Ω–∏
                configured = list(
                    DocumentTypeStatus.objects.filter(
                        document_type=document.document_type,
                        is_active=True
                    ).values_list('status__code', flat=True)
                )

                return Result.error(
                    'INVALID_STATUS',
                    f"Status '{to_status}' is not configured for document type "
                    f"'{document.document_type.type_key}'. Available: {configured}"
                )

            # –ü—Ä–æ–≤–µ—Ä–∏ transition rules
            current_config = DocumentTypeStatus.objects.filter(
                document_type=document.document_type,
                status__code=document.status,
                is_active=True
            ).first()

            # –ù–µ –º–æ–∂–µ FROM final —Å—Ç–∞—Ç—É—Å
            if current_config and current_config.is_final:
                return Result.error(
                    'FROM_FINAL_STATUS',
                    f"Cannot transition from final status '{document.status}'"
                )

            # –ù–µ –º–æ–∂–µ TO initial —Å—Ç–∞—Ç—É—Å
            if status_config.is_initial:
                return Result.error(
                    'TO_INITIAL_STATUS',
                    f"Cannot transition to initial status '{to_status}'"
                )

            return Result.success()

        except Exception as e:
            return Result.error('STATUS_VALIDATION_ERROR', str(e))

    @staticmethod
    def _validate_simple_transition(document, to_status: str, user: User) -> Result:
        """
        –í–∞–ª–∏–¥–∞—Ü–∏—è –∑–∞ –¥–æ–∫—É–º–µ–Ω—Ç–∏ –ë–ï–ó approval workflow

        –ü—Ä–æ–≤–µ—Ä—è–≤–∞ —Å–∞–º–æ –æ—Å–Ω–æ–≤–Ω–∏ business rules –∏ permissions
        """
        try:
            # 1. Basic permissions - –≤—Å–µ–∫–∏ –º–æ–∂–µ –¥–∞ –ø—Ä–∞–≤–∏ transitions (–æ—Å–≤–µ–Ω restrictions)

            # 2. –°–ø–µ—Ü–∏–∞–ª–Ω–∏ business rules –∑–∞ common transitions
            if 'complet' in to_status.lower():
                # –ö—ä–º completed —Å—Ç–∞—Ç—É—Å - –ø—Ä–æ–≤–µ—Ä–∏ lines
                if hasattr(document, 'lines'):
                    if not document.lines.exists():
                        return Result.error(
                            'NO_LINES',
                            'Cannot complete document without lines'
                        )

            # 3. Cancel transition - –≤–∏–Ω–∞–≥–∏ –ø–æ–∑–≤–æ–ª–µ–Ω (–æ—Å–≤–µ–Ω –æ—Ç final)
            if 'cancel' in to_status.lower():
                return Result.success(msg="Cancellation allowed")

            # 4. Default - –ø–æ–∑–≤–æ–ª–µ–Ω–æ
            return Result.success(msg="Simple transition allowed")

        except Exception as e:
            return Result.error('SIMPLE_TRANSITION_ERROR', str(e))

    @staticmethod
    def _validate_business_rules(document, to_status: str, user: User, **kwargs) -> Result:
        """Validate business-specific rules"""
        try:
            # Dynamic: Call model-specific validation if exists
            model_name = document.__class__.__name__.lower()

            validation_method = getattr(
                DocumentService,
                f'_validate_{model_name}_rules',
                None
            )

            if validation_method:
                result = validation_method(document, to_status, user, **kwargs)
                if isinstance(result, dict):
                    # Legacy format conversion
                    if result.get('valid'):
                        return Result.success(msg=result.get('message', 'Business rules passed'))
                    else:
                        return Result.error('BUSINESS_RULE_VIOLATION', result.get('message', 'Business rule failed'))
                return result

            # Default: Basic validation
            return Result.success(msg='No specific business rules')

        except Exception as e:
            return Result.error('BUSINESS_VALIDATION_ERROR', str(e))

    @staticmethod
    def _validate_purchaserequest_rules(document, to_status: str, user: User, **kwargs) -> Result:
        """Purchase Request specific validation"""
        try:
            # Submission validation
            if any(word in to_status.lower() for word in ['submit', 'pending', 'review']):
                if not document.lines.exists():
                    return Result.error(
                        'NO_LINES',
                        'Cannot submit request without lines'
                    )

            # Completion validation
            if 'complet' in to_status.lower():
                if not document.lines.exists():
                    return Result.error(
                        'NO_LINES',
                        'Cannot complete request without lines'
                    )

                # Check all lines have required data
                incomplete_lines = document.lines.filter(
                    models.Q(quantity__isnull=True) | models.Q(quantity__lte=0)
                )
                if incomplete_lines.exists():
                    return Result.error(
                        'INCOMPLETE_LINES',
                        f'Lines with missing quantities: {incomplete_lines.count()}'
                    )

            return Result.success()

        except Exception as e:
            return Result.error('PURCHASE_REQUEST_VALIDATION_ERROR', str(e))

    # =====================
    # INFORMATION & QUERY METHODS
    # =====================

    @staticmethod
    def get_available_actions(document, user: User) -> List[Dict]:
        """Get available actions for document and user"""
        try:
            actions = []

            if not document.document_type:
                return actions

            if document.document_type.requires_approval:
                # === APPROVAL WORKFLOW ACTIONS ===
                from .approval_service import ApprovalService
                transitions = ApprovalService.get_available_transitions(document, user)

                for trans in transitions:
                    actions.append({
                        'action': 'transition',
                        'status': trans['to_status'],
                        'label': trans['label'],
                        'can_perform': True,
                        'requires_approval': True,
                        'button_style': DocumentService._get_button_style(trans['to_status']),
                        'icon': trans.get('icon', 'fas fa-arrow-right'),
                        'rule_id': trans.get('rule_id')
                    })
            else:
                # === SIMPLE WORKFLOW ACTIONS ===
                available_statuses = DocumentService._get_simple_next_statuses(document)

                for status in available_statuses:
                    actions.append({
                        'action': 'transition',
                        'status': status,
                        'label': status.replace('_', ' ').title(),
                        'can_perform': True,
                        'requires_approval': False,
                        'button_style': DocumentService._get_button_style(status),
                        'icon': DocumentService._get_status_icon(status)
                    })

            # === EDIT ACTION ===
            can_edit, edit_reason = DocumentService.can_edit_document(document, user)
            if can_edit:
                actions.append({
                    'action': 'edit',
                    'label': 'Edit Document',
                    'can_perform': True,
                    'button_style': 'outline-primary',
                    'icon': 'fas fa-edit',
                    'reason': edit_reason
                })

            return actions

        except Exception as e:
            logger.error(f"Error getting available actions: {e}")
            return []

    @staticmethod
    def _get_simple_next_statuses(document) -> List[str]:
        """–ù–∞–º–µ—Ä–∏ —Å–ª–µ–¥–≤–∞—â–∏ —Å—Ç–∞—Ç—É—Å–∏ –∑–∞ simple workflow"""
        try:
            from ..models.statuses import DocumentTypeStatus

            # –ù–∞–º–µ—Ä–∏ –≤—Å–∏—á–∫–∏ non-initial —Å—Ç–∞—Ç—É—Å–∏ –∑–∞ —Ç–æ–∑–∏ document type
            all_statuses = DocumentTypeStatus.objects.filter(
                document_type=document.document_type,
                is_initial=False,
                is_active=True
            ).exclude(
                status__code=document.status
            ).order_by('sort_order')

            # –§–∏–ª—Ç—Ä–∏—Ä–∞–π —Å–ø–æ—Ä–µ–¥ current status
            available = []

            for config in all_statuses:
                status_code = config.status.code

                # –û—Å–Ω–æ–≤–Ω–∏ –ø—Ä–∞–≤–∏–ª–∞:
                # - –û—Ç draft –º–æ–∂–µ –∫—ä–º –≤—Å–∏—á–∫–∏
                # - –û—Ç in-progress –º–æ–∂–µ –∫—ä–º completed –∏–ª–∏ cancelled
                # - –û—Ç completed –º–æ–∂–µ —Å–∞–º–æ –∫—ä–º cancelled (–∞–∫–æ allow_edit_completed)

                if document.status == 'draft':
                    available.append(status_code)
                elif 'cancel' in status_code:
                    # Cancellation –≤–∏–Ω–∞–≥–∏ –µ –≤—ä–∑–º–æ–∂–Ω–∞
                    available.append(status_code)
                elif not config.is_final:
                    # –ö—ä–º non-final —Å—Ç–∞—Ç—É—Å–∏
                    available.append(status_code)

            return available

        except Exception as e:
            logger.error(f"Error getting simple next statuses: {e}")
            return []

    @staticmethod
    def _get_status_info(document) -> Dict:
        """–ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –∑–∞ —Ç–µ–∫—É—â–∏—è —Å—Ç–∞—Ç—É—Å"""
        try:
            from ..models.statuses import DocumentTypeStatus

            config = DocumentTypeStatus.objects.filter(
                document_type=document.document_type,
                status__code=document.status,
                is_active=True
            ).select_related('status').first()

            if config:
                return {
                    'code': config.status.code,
                    'name': config.custom_name or config.status.name,
                    'color': config.status.color,
                    'icon': config.status.icon,
                    'is_initial': config.is_initial,
                    'is_final': config.is_final,
                    'is_cancellation': config.is_cancellation,
                    'allow_edit': config.status.allow_edit,
                    'allow_delete': config.status.allow_delete
                }

            # Fallback
            return {
                'code': document.status,
                'name': document.status.replace('_', ' ').title(),
                'color': '#6c757d',
                'is_initial': document.status == 'draft',
                'is_final': document.status in ['completed', 'cancelled'],
                'is_cancellation': 'cancel' in document.status.lower(),
                'allow_edit': True,
                'allow_delete': False
            }

        except Exception as e:
            logger.error(f"Error getting status info: {e}")
            return {'code': document.status}

    # =====================
    # HELPER METHODS
    # =====================

    @staticmethod
    def _get_button_style(status: str) -> str:
        """UI button style –∑–∞ —Å—Ç–∞—Ç—É—Å–∏"""
        status_lower = status.lower()

        if any(word in status_lower for word in ['approv', 'accept', 'confirm']):
            return 'success'
        elif any(word in status_lower for word in ['reject', 'deny', 'cancel']):
            return 'danger'
        elif any(word in status_lower for word in ['submit', 'send']):
            return 'primary'
        elif any(word in status_lower for word in ['complet', 'finish']):
            return 'info'
        else:
            return 'secondary'

    @staticmethod
    def _get_status_icon(status: str) -> str:
        """Icon –∑–∞ —Å—Ç–∞—Ç—É—Å–∏"""
        status_lower = status.lower()

        if any(word in status_lower for word in ['approv', 'accept']):
            return 'fas fa-check'
        elif any(word in status_lower for word in ['reject', 'deny']):
            return 'fas fa-times'
        elif 'cancel' in status_lower:
            return 'fas fa-ban'
        elif any(word in status_lower for word in ['submit', 'send']):
            return 'fas fa-paper-plane'
        elif any(word in status_lower for word in ['complet', 'finish']):
            return 'fas fa-check-circle'
        elif 'draft' in status_lower:
            return 'fas fa-edit'
        else:
            return 'fas fa-arrow-right'

    @staticmethod
    def _log_transition(document, rule_id: Optional[int], from_status: str,
                        to_status: str, user: User, comments: str = ''):
        """
        üî• FIXED: Log approval transition - SKIP for simple transitions
        """
        try:
            # üî• FIX: Skip logging for documents that don't require approval
            if not document.document_type.requires_approval:
                logger.debug(f"Skipping ApprovalLog for simple transition: {from_status} ‚Üí {to_status}")
                return

            # üî• FIX: Skip logging if no rule_id (shouldn't happen for approval docs, but safety check)
            if not rule_id:
                logger.warning(f"No rule_id for approval document {document.document_number}, skipping log")
                return

            from ..models.approvals import ApprovalLog, ApprovalRule
            from django.contrib.contenttypes.models import ContentType

            content_type = ContentType.objects.get_for_model(document.__class__)

            # Determine action based on to_status
            if any(word in to_status.lower() for word in ['approv', 'accept', 'confirm']):
                action = 'approved'
            elif any(word in to_status.lower() for word in ['reject', 'deny']):
                action = 'rejected'
            elif any(word in to_status.lower() for word in ['cancel']):
                action = 'cancelled'
            else:
                action = 'submitted'

            # Get rule
            try:
                rule = ApprovalRule.objects.get(id=rule_id)
            except ApprovalRule.DoesNotExist:
                logger.error(f"ApprovalRule {rule_id} not found for logging")
                return

            # Create log entry
            ApprovalLog.objects.create(
                content_type=content_type,
                object_id=document.pk,
                rule=rule,  # Now guaranteed to exist
                action=action,
                from_status=from_status,
                to_status=to_status,
                actor=user,
                comments=comments or ''
            )

            logger.debug(f"‚úÖ Logged approval transition: {from_status} ‚Üí {to_status}")

        except Exception as e:
            logger.error(f"‚ùå Error logging approval transition: {e}")
            # üî• IMPORTANT: Don't re-raise - logging failure shouldn't break transition

    # üî• ALSO ADD: Alternative logging for simple transitions (optional)
    @staticmethod
    def _log_simple_transition(document, from_status: str, to_status: str, user: User, comments: str = ''):
        """
        Log simple transition without ApprovalRule (optional alternative logging)
        Could save to Django admin log or custom SimpleTransitionLog model
        """
        try:
            from django.contrib.admin.models import LogEntry, CHANGE
            from django.contrib.contenttypes.models import ContentType

            content_type = ContentType.objects.get_for_model(document.__class__)

            LogEntry.objects.log_action(
                user_id=user.id,
                content_type_id=content_type.id,
                object_id=document.pk,
                object_repr=str(document),
                action_flag=CHANGE,
                change_message=f"Status changed from {from_status} to {to_status}" +
                               (f" - {comments}" if comments else "")
            )

            logger.debug(f"‚úÖ Logged simple transition to admin log: {from_status} ‚Üí {to_status}")

        except Exception as e:
            logger.debug(f"‚ö†Ô∏è Failed to log simple transition: {e}")

    @staticmethod
    def _execute_post_transition_actions(document, from_status: str, to_status: str,
                                         user: User, **kwargs):
        """Execute actions after successful transition"""
        try:
            # 1. Inventory movements (if document affects inventory)
            if document.document_type.affects_inventory:
                DocumentService._handle_inventory_movements(document, from_status, to_status)

            # 2. Notifications
            DocumentService._send_transition_notifications(document, from_status, to_status, user)

            # 3. Auto-calculations (VAT, totals, etc.)
            DocumentService._update_document_calculations(document, to_status)

        except Exception as e:
            logger.error(f"Error in post-transition actions: {e}")

    @staticmethod
    def _handle_inventory_movements(document, from_status: str, to_status: str):
        """Handle inventory movements based on status transition"""
        try:
            # –ü—Ä–æ–≤–µ—Ä–∏ –∫–æ–≥–∞ –¥–∞ —Å–µ –ø—Ä–∞–≤—è—Ç –¥–≤–∏–∂–µ–Ω–∏—è
            movement_timing = getattr(document.document_type, 'inventory_timing', 'on_completion')

            should_create_movements = False

            if movement_timing == 'on_completion' and 'complet' in to_status.lower():
                should_create_movements = True
            elif movement_timing == 'on_approval' and 'approv' in to_status.lower():
                should_create_movements = True
            elif movement_timing == 'on_status_change':
                should_create_movements = True

            if should_create_movements:
                try:
                    from inventory.services.movement_service import MovementService
                    movements = MovementService.create_from_document(document)
                    logger.info(f"Created inventory movements for {document.document_number}")
                except ImportError:
                    logger.warning("InventoryService not available")

        except Exception as e:
            logger.error(f"Error handling inventory movements: {e}")

    @staticmethod
    def _update_document_calculations(document, status: str):
        """Update document calculations (VAT, totals)"""
        try:
            # Trigger recalculation –∞–∫–æ –¥–æ–∫—É–º–µ–Ω—Ç—ä—Ç –∏–º–∞ —Ñ–∏–Ω–∞–Ω—Å–æ–≤–∏ –ø–æ–ª–µ—Ç–∞
            if hasattr(document, 'calculate_totals'):
                document.calculate_totals()
                document.save()
            elif hasattr(document, 'update_totals'):
                document.update_totals()

        except Exception as e:
            logger.error(f"Error updating calculations: {e}")

    @staticmethod
    def _send_transition_notifications(document, from_status: str, to_status: str, user: User):
        """Send notifications for status transition"""
        try:
            try:
                from notifications.services import NotificationService
                NotificationService.send_status_change_notification(
                    document, from_status, to_status, user
                )
            except ImportError:
                # Simple logging fallback
                logger.info(
                    f"Status Change: {document.document_number} "
                    f"{from_status}‚Üí{to_status} by {user.username}"
                )

        except Exception as e:
            logger.error(f"Error sending notifications: {e}")

    # =====================
    # LEGACY SUPPORT & UTILITY METHODS
    # =====================

    @staticmethod
    def _get_document_type_for_model(model_class):
        """Get DocumentType for model class"""
        try:
            from ..models.documents import get_document_type_by_key

            app_name = model_class._meta.app_label
            type_key = model_class.__name__.lower()

            # –û–ø–∏—Ç–∞–π —Å model methods –∞–∫–æ –∏–º–∞
            try:
                instance = model_class()
                if hasattr(instance, 'get_app_name'):
                    app_name = instance.get_app_name()
                if hasattr(instance, 'get_document_type_key'):
                    type_key = instance.get_document_type_key()
            except:
                pass

            return get_document_type_by_key(app_name, type_key)

        except Exception as e:
            logger.warning(f"No DocumentType found for {model_class.__name__}: {e}")
            return None

    @staticmethod
    def _generate_document_number(document_type, location, user: User) -> str:
        """Generate document number using NumberingConfiguration"""
        try:
            # Try to use NumberingConfiguration
            try:
                from ..models.numbering import generate_document_number
                return generate_document_number(document_type, location, user)
            except ImportError:
                pass  # NumberingConfiguration not available yet

            # Fallback: Simple sequential numbering
            prefix = getattr(document_type, 'code', document_type.type_key[:3].upper())

            # Simple counter (–≤ —Ä–µ–∞–ª–Ω–∞—Ç–∞ –∏–º–ø–ª–µ–º–µ–Ω—Ç–∞—Ü–∏—è –∏–∑–ø–æ–ª–∑–≤–∞–π sequence)
            from django.utils import timezone
            timestamp = timezone.now().strftime("%y%m%d%H%M%S")
            return f"{prefix}{timestamp}"

        except Exception as e:
            logger.error(f"Error generating document number: {e}")
            from django.utils import timezone
            timestamp = timezone.now().strftime("%y%m%d%H%M%S")
            return f"DOC{timestamp}"

    @staticmethod
    def _get_initial_status(document_type) -> str:
        """Get initial status from DocumentTypeStatus"""
        try:
            from ..models.statuses import DocumentTypeStatus

            initial_config = DocumentTypeStatus.objects.filter(
                document_type=document_type,
                is_initial=True,
                is_active=True
            ).first()

            if initial_config:
                return initial_config.status.code

            # Fallback
            return 'draft'

        except Exception as e:
            logger.warning(f"Error getting initial status: {e}")
            return 'draft'

    # =====================
    # DYNAMIC QUERY METHODS (for Managers)
    # =====================

    @staticmethod
    def get_pending_approval_documents(model_class=None, queryset=None):
        """Get documents pending approval - DYNAMIC"""
        if queryset is None:
            if model_class is None:
                raise ValueError("Either model_class or queryset must be provided")
            queryset = model_class.objects.all()

        try:
            from ..models.approvals import ApprovalRule

            pending_statuses = set()

            # Get document types –∑–∞ —Ç–æ–∑–∏ –º–æ–¥–µ–ª
            doc_type = DocumentService._get_document_type_for_model(queryset.model)
            if doc_type and doc_type.requires_approval:
                # –ò–∑–ø–æ–ª–∑–≤–∞–π ApprovalRule
                rules = ApprovalRule.objects.filter(
                    document_type=doc_type,
                    is_active=True
                )
                pending_statuses.update(rules.values_list('from_status_obj__code', flat=True))

            # Fallback –∞–∫–æ –Ω—è–º–∞ –ø—Ä–∞–≤–∏–ª–∞
            if not pending_statuses:
                pending_statuses = {'submitted', 'pending_approval', 'pending_review'}

            return queryset.filter(status__in=pending_statuses)

        except ImportError:
            # Fallback –±–µ–∑ ApprovalRule
            return queryset.filter(status__in=['submitted', 'pending_approval'])

    @staticmethod
    def get_active_documents(model_class=None, queryset=None):
        """Get active documents - DYNAMIC"""
        if queryset is None:
            if model_class is None:
                raise ValueError("Either model_class or queryset must be provided")
            queryset = model_class.objects.all()

        try:
            from ..models.statuses import DocumentTypeStatus

            doc_type = DocumentService._get_document_type_for_model(queryset.model)
            if doc_type:
                # –ò–∑–ø–æ–ª–∑–≤–∞–π DocumentTypeStatus –∑–∞ final —Å—Ç–∞—Ç—É—Å–∏
                final_statuses = list(
                    DocumentTypeStatus.objects.filter(
                        document_type=doc_type,
                        is_final=True,
                        is_active=True
                    ).values_list('status__code', flat=True)
                )

                if final_statuses:
                    return queryset.exclude(status__in=final_statuses)

            # Fallback
            return queryset.exclude(status__in=['cancelled', 'closed', 'deleted', 'archived'])

        except Exception:
            # Basic fallback
            return queryset.exclude(status__in=['cancelled', 'closed', 'deleted'])

    # –í –∫—Ä–∞—è –Ω–∞ nomenclatures/services/document_service.py

    @staticmethod
    def generate_number_for(instance):
        """Generate number for existing model instance (for admin save())"""
        try:
            from nomenclatures.models.numbering import generate_document_number

            # –ù–∞–º–µ—Ä–∏ DocumentType
            document_type = DocumentService._get_document_type_for_model(instance.__class__)

            if document_type:
                # –ó–ê–î–ê–ô –°–¢–ê–¢–£–° –ê–ö–û –ù–Ø–ú–ê
                if hasattr(instance, 'status') and not instance.status:
                    instance.status = DocumentService._get_initial_status(document_type)

                return generate_document_number(
                    document_type=document_type,
                    location=getattr(instance, 'location', None),
                    user=getattr(instance, 'created_by', None)
                )
        except:
            pass

        # Fallback
        from datetime import datetime
        prefix = instance.__class__.__name__[:3].upper()
        timestamp = datetime.now().strftime("%y%m%d%H%M%S")

        # –ó–ê–î–ê–ô –°–¢–ê–¢–£–° –ò –¢–£–ö
        if hasattr(instance, 'status') and not instance.status:
            instance.status = 'draft'

        return f"{prefix}{timestamp}"


# =====================
# CONVENIENCE FUNCTIONS
# =====================

def transition_document(document, to_status: str, user: User, comments: str = '') -> Result:
    """Convenience function for document transitions"""
    return DocumentService.transition_document(document, to_status, user, comments)


def can_edit_document(document, user: User) -> bool:
    """Quick check if document can be edited"""
    can_edit, _ = DocumentService.can_edit_document(document, user)
    return can_edit


def get_document_actions(document, user: User) -> List[Dict]:
    """Get available actions for document"""
    return DocumentService.get_available_actions(document, user)