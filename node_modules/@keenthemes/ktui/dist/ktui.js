(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else {
		var a = factory();
		for(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];
	}
})(self, function() {
return /******/ (function() { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ 494:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


/**
 * KTUI - Free & Open-Source Tailwind UI Components by Keenthemes
 * Copyright 2025 by Keenthemes Inc
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TypeToSearchBuffer = exports.EventManager = exports.FocusManager = exports.filterOptions = exports.KTSelectDropdown = exports.KTSelectTags = exports.KTSelectSearch = exports.KTSelectCombobox = exports.KTSelectRemote = exports.KTSelect = void 0;
var select_1 = __webpack_require__(8016);
Object.defineProperty(exports, "KTSelect", ({ enumerable: true, get: function () { return select_1.KTSelect; } }));
var remote_1 = __webpack_require__(3710);
Object.defineProperty(exports, "KTSelectRemote", ({ enumerable: true, get: function () { return remote_1.KTSelectRemote; } }));
var combobox_1 = __webpack_require__(5539);
Object.defineProperty(exports, "KTSelectCombobox", ({ enumerable: true, get: function () { return combobox_1.KTSelectCombobox; } }));
var search_1 = __webpack_require__(7620);
Object.defineProperty(exports, "KTSelectSearch", ({ enumerable: true, get: function () { return search_1.KTSelectSearch; } }));
var tags_1 = __webpack_require__(8797);
Object.defineProperty(exports, "KTSelectTags", ({ enumerable: true, get: function () { return tags_1.KTSelectTags; } }));
var dropdown_1 = __webpack_require__(7125);
Object.defineProperty(exports, "KTSelectDropdown", ({ enumerable: true, get: function () { return dropdown_1.KTSelectDropdown; } }));
var utils_1 = __webpack_require__(9011);
Object.defineProperty(exports, "filterOptions", ({ enumerable: true, get: function () { return utils_1.filterOptions; } }));
Object.defineProperty(exports, "FocusManager", ({ enumerable: true, get: function () { return utils_1.FocusManager; } }));
Object.defineProperty(exports, "EventManager", ({ enumerable: true, get: function () { return utils_1.EventManager; } }));
Object.defineProperty(exports, "TypeToSearchBuffer", ({ enumerable: true, get: function () { return utils_1.TypeToSearchBuffer; } }));


/***/ }),

/***/ 642:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


/**
 * KTUI - Free & Open-Source Tailwind UI Components by Keenthemes
 * Copyright 2025 by Keenthemes Inc
 */
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.KTReparent = void 0;
var data_1 = __webpack_require__(8716);
var dom_1 = __webpack_require__(9010);
var utils_1 = __webpack_require__(2599);
var component_1 = __webpack_require__(2658);
var KTReparent = /** @class */ (function (_super) {
    __extends(KTReparent, _super);
    function KTReparent(element, config) {
        if (config === void 0) { config = null; }
        var _this = _super.call(this) || this;
        _this._name = 'reparent';
        _this._defaultConfig = {
            mode: '',
            target: '',
        };
        if (data_1.default.has(element, _this._name))
            return _this;
        _this._init(element);
        _this._buildConfig(config);
        _this._update();
        return _this;
    }
    KTReparent.prototype._update = function () {
        if (!this._element)
            return;
        var target = this._getOption('target');
        var targetEl = dom_1.default.getElement(target);
        var mode = this._getOption('mode');
        if (targetEl && this._element.parentNode !== targetEl) {
            if (mode === 'prepend') {
                targetEl.prepend(this._element);
            }
            else if (mode === 'append') {
                targetEl.append(this._element);
            }
        }
    };
    KTReparent.prototype.update = function () {
        this._update();
    };
    KTReparent.handleResize = function () {
        window.addEventListener('resize', function () {
            var timer;
            utils_1.default.throttle(timer, function () {
                document
                    .querySelectorAll('[data-kt-reparent-initialized]')
                    .forEach(function (element) {
                    var reparent = KTReparent.getInstance(element);
                    console.log('reparent update');
                    reparent === null || reparent === void 0 ? void 0 : reparent.update();
                });
            }, 200);
        });
    };
    KTReparent.getInstance = function (element) {
        return data_1.default.get(element, 'reparent');
    };
    KTReparent.getOrCreateInstance = function (element, config) {
        return this.getInstance(element) || new KTReparent(element, config);
    };
    KTReparent.createInstances = function () {
        var elements = document.querySelectorAll('[data-kt-reparent]');
        elements.forEach(function (element) {
            new KTReparent(element);
        });
    };
    KTReparent.init = function () {
        KTReparent.createInstances();
        if (window.KT_REPARENT_INITIALIZED !== true) {
            KTReparent.handleResize();
            window.KT_REPARENT_INITIALIZED = true;
        }
    };
    return KTReparent;
}(component_1.default));
exports.KTReparent = KTReparent;
if (typeof window !== 'undefined') {
    window.KTReparent = KTReparent;
}


/***/ }),

/***/ 706:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


/**
 * KTUI - Free & Open-Source Tailwind UI Components by Keenthemes
 * Copyright 2025 by Keenthemes Inc
 */
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.KTDrawer = void 0;
var data_1 = __webpack_require__(8716);
var dom_1 = __webpack_require__(9010);
var utils_1 = __webpack_require__(2599);
var event_handler_1 = __webpack_require__(5183);
var component_1 = __webpack_require__(2658);
var KTDrawer = /** @class */ (function (_super) {
    __extends(KTDrawer, _super);
    function KTDrawer(element, config) {
        var _this = _super.call(this) || this;
        _this._name = 'drawer';
        _this._defaultConfig = {
            zindex: '100',
            enable: true,
            class: '',
            shownClass: 'flex',
            hiddenClass: 'hidden',
            backdrop: true,
            backdropClass: 'kt-drawer-backdrop',
            backdropStatic: false,
            keyboard: true,
            disableScroll: true,
            persistent: false,
            container: '',
            focus: true,
        };
        _this._config = _this._defaultConfig;
        _this._isOpen = false;
        _this._isTransitioning = false;
        _this._backdropElement = null;
        _this._relatedTarget = null;
        if (data_1.default.has(element, _this._name))
            return _this;
        _this._init(element);
        _this._buildConfig(config);
        _this._handleClose();
        _this._update();
        _this._handleContainer();
        return _this;
    }
    KTDrawer.prototype._handleClose = function () {
        var _this = this;
        if (!this._element)
            return;
        event_handler_1.default.on(this._element, '[data-kt-drawer-hide]', 'click', function () {
            _this._hide();
        });
    };
    KTDrawer.prototype._toggle = function (relatedTarget) {
        var payload = { cancel: false };
        this._fireEvent('toggle', payload);
        this._dispatchEvent('toggle', payload);
        if (payload.cancel === true) {
            return;
        }
        if (this._isOpen === true) {
            this._hide();
        }
        else {
            this._show(relatedTarget);
        }
    };
    KTDrawer.prototype._show = function (relatedTarget) {
        var _this = this;
        if (this._isOpen || this._isTransitioning) {
            return;
        }
        var payload = { cancel: false };
        this._fireEvent('show', payload);
        this._dispatchEvent('show', payload);
        if (payload.cancel === true) {
            return;
        }
        KTDrawer.hide();
        if (this._getOption('backdrop') === true)
            this._createBackdrop();
        if (relatedTarget)
            this._relatedTarget = relatedTarget;
        if (!this._element)
            return;
        this._isTransitioning = true;
        this._element.classList.remove(this._getOption('hiddenClass'));
        this._element.classList.add(this._getOption('shownClass'));
        this._element.setAttribute('role', 'dialog');
        this._element.setAttribute('aria-modal', 'true');
        this._element.setAttribute('tabindex', '-1');
        var zindex = parseInt(this._getOption('zindex'));
        if (zindex > 0) {
            this._element.style.zIndex = "".concat(zindex);
        }
        if (this._getOption('disableScroll')) {
            document.body.style.overflow = 'hidden';
        }
        dom_1.default.reflow(this._element);
        this._element.classList.add('open');
        dom_1.default.transitionEnd(this._element, function () {
            _this._isTransitioning = false;
            _this._isOpen = true;
            if (_this._getOption('focus') === true) {
                _this._autoFocus();
            }
            _this._fireEvent('shown');
            _this._dispatchEvent('shown');
        });
    };
    KTDrawer.prototype._hide = function () {
        var _this = this;
        if (!this._element)
            return;
        if (this._isOpen === false || this._isTransitioning) {
            return;
        }
        var payload = { cancel: false };
        this._fireEvent('hide', payload);
        this._dispatchEvent('hide', payload);
        if (payload.cancel === true) {
            return;
        }
        this._isTransitioning = true;
        this._element.removeAttribute('role');
        this._element.removeAttribute('aria-modal');
        this._element.removeAttribute('tabindex');
        if (this._getOption('disableScroll')) {
            document.body.style.overflow = '';
        }
        dom_1.default.reflow(this._element);
        this._element.classList.remove('open');
        if (this._getOption('backdrop') === true) {
            this._deleteBackdrop();
        }
        dom_1.default.transitionEnd(this._element, function () {
            if (!_this._element)
                return;
            _this._isTransitioning = false;
            _this._isOpen = false;
            _this._element.classList.add(_this._getOption('hiddenClass'));
            _this._element.classList.remove(_this._getOption('shownClass'));
            _this._element.style.zIndex = '';
            _this._fireEvent('hidden');
            _this._dispatchEvent('hidden');
        });
    };
    KTDrawer.prototype._update = function () {
        var _a;
        if (((_a = this._getOption('class')) === null || _a === void 0 ? void 0 : _a.length) > 0) {
            if (this.isEnabled()) {
                dom_1.default.addClass(this._element, this._getOption('class'));
            }
            else {
                dom_1.default.removeClass(this._element, this._getOption('class'));
            }
        }
    };
    KTDrawer.prototype._handleContainer = function () {
        var _a;
        if (this._getOption('container')) {
            if (this._getOption('container') === 'body') {
                document.body.appendChild(this._element);
            }
            else {
                (_a = document
                    .querySelector(this._getOption('container'))) === null || _a === void 0 ? void 0 : _a.appendChild(this._element);
            }
        }
    };
    KTDrawer.prototype._autoFocus = function () {
        if (!this._element)
            return;
        var input = this._element.querySelector('[data-kt-drawer-focus]');
        if (!input)
            return;
        else
            input.focus();
    };
    KTDrawer.prototype._createBackdrop = function () {
        var _this = this;
        if (!this._element)
            return;
        var zindex = parseInt(this._getOption('zindex'));
        this._backdropElement = document.createElement('DIV');
        this._backdropElement.style.zIndex = (zindex - 1).toString();
        this._backdropElement.setAttribute('data-kt-drawer-backdrop', 'true');
        document.body.append(this._backdropElement);
        dom_1.default.reflow(this._backdropElement);
        dom_1.default.addClass(this._backdropElement, this._getOption('backdropClass'));
        this._backdropElement.addEventListener('click', function (event) {
            event.preventDefault();
            if (_this._getOption('backdropStatic') === false) {
                _this._hide();
            }
        });
    };
    KTDrawer.prototype._deleteBackdrop = function () {
        var _this = this;
        if (!this._backdropElement)
            return;
        dom_1.default.reflow(this._backdropElement);
        this._backdropElement.style.opacity = '0';
        dom_1.default.transitionEnd(this._backdropElement, function () {
            if (!_this._backdropElement)
                return;
            dom_1.default.remove(_this._backdropElement);
        });
    };
    KTDrawer.prototype._isEnabled = function () {
        return utils_1.default.stringToBoolean(this._getOption('enable'));
    };
    KTDrawer.prototype.toggle = function () {
        return this._toggle();
    };
    KTDrawer.prototype.show = function (relatedTarget) {
        return this._show(relatedTarget);
    };
    KTDrawer.prototype.hide = function () {
        return this._hide();
    };
    KTDrawer.prototype.update = function () {
        return this._update();
    };
    KTDrawer.prototype.getRelatedTarget = function () {
        return this._relatedTarget;
    };
    KTDrawer.prototype.isOpen = function () {
        return this._isOpen;
    };
    KTDrawer.prototype.isEnabled = function () {
        return this._isEnabled();
    };
    KTDrawer.getInstance = function (element) {
        if (!element)
            return null;
        if (data_1.default.has(element, 'drawer')) {
            return data_1.default.get(element, 'drawer');
        }
        if (element.getAttribute('data-kt-drawer-initialized') === 'true') {
            return new KTDrawer(element);
        }
        return null;
    };
    KTDrawer.getOrCreateInstance = function (element, config) {
        return this.getInstance(element) || new KTDrawer(element, config);
    };
    KTDrawer.hide = function () {
        var elements = document.querySelectorAll('[data-kt-drawer-initialized]');
        elements.forEach(function (element) {
            var drawer = KTDrawer.getInstance(element);
            if (drawer && drawer.isOpen()) {
                drawer.hide();
            }
        });
    };
    KTDrawer.handleResize = function () {
        window.addEventListener('resize', function () {
            var timer;
            utils_1.default.throttle(timer, function () {
                document
                    .querySelectorAll('[data-kt-drawer-initialized]')
                    .forEach(function (element) {
                    var drawer = KTDrawer.getInstance(element);
                    drawer.update();
                    if (drawer && drawer.isOpen() && !drawer.isEnabled()) {
                        drawer.hide();
                    }
                });
            }, 200);
        });
    };
    KTDrawer.handleToggle = function () {
        event_handler_1.default.on(document.body, '[data-kt-drawer-toggle]', 'click', function (event, target) {
            event.stopPropagation();
            var selector = target.getAttribute('data-kt-drawer-toggle');
            if (!selector)
                return;
            var drawerEl = document.querySelector(selector);
            var drawer = KTDrawer.getInstance(drawerEl);
            if (drawer) {
                drawer.toggle();
            }
        });
    };
    KTDrawer.handleDismiss = function () {
        event_handler_1.default.on(document.body, '[data-kt-drawer-dismiss]', 'click', function (event, target) {
            event.stopPropagation();
            var modalElement = target.closest('[data-kt-drawer="true"]');
            if (modalElement) {
                var modal = KTDrawer.getInstance(modalElement);
                if (modal) {
                    modal.hide();
                }
            }
        });
    };
    KTDrawer.handleClickAway = function () {
        document.addEventListener('click', function (event) {
            var drawerEl = document.querySelector('.open[data-kt-drawer-initialized]');
            if (!drawerEl)
                return;
            var drawer = KTDrawer.getInstance(drawerEl);
            if (!drawer)
                return;
            if (drawer.getOption('persistent'))
                return;
            if (drawer.getOption('backdrop'))
                return;
            if (drawerEl !== event.target &&
                drawer.getRelatedTarget() !== event.target &&
                drawerEl.contains(event.target) === false) {
                drawer.hide();
            }
        });
    };
    KTDrawer.handleKeyword = function () {
        document.addEventListener('keydown', function (event) {
            var drawerEl = document.querySelector('.open[data-kt-drawer-initialized]');
            var drawer = KTDrawer.getInstance(drawerEl);
            if (!drawer) {
                return;
            }
            // if esc key was not pressed in combination with ctrl or alt or shift
            if (event.key === 'Escape' &&
                !(event.ctrlKey || event.altKey || event.shiftKey)) {
                drawer.hide();
            }
            if (event.code === 'Tab' && !event.metaKey) {
                return;
            }
        });
    };
    KTDrawer.createInstances = function () {
        var elements = document.querySelectorAll('[data-kt-drawer]');
        elements.forEach(function (element) {
            new KTDrawer(element);
        });
    };
    KTDrawer.init = function () {
        KTDrawer.createInstances();
        if (window.KT_DRAWER_INITIALIZED !== true) {
            KTDrawer.handleToggle();
            KTDrawer.handleDismiss();
            KTDrawer.handleResize();
            KTDrawer.handleClickAway();
            KTDrawer.handleKeyword();
            window.KT_DRAWER_INITIALIZED = true;
        }
    };
    return KTDrawer;
}(component_1.default));
exports.KTDrawer = KTDrawer;
if (typeof window !== 'undefined') {
    window.KTDrawer = KTDrawer;
}


/***/ }),

/***/ 733:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


/**
 * KTUI - Free & Open-Source Tailwind UI Components by Keenthemes
 * Copyright 2025 by Keenthemes Inc
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.KTSticky = void 0;
var sticky_1 = __webpack_require__(3394);
Object.defineProperty(exports, "KTSticky", ({ enumerable: true, get: function () { return sticky_1.KTSticky; } }));


/***/ }),

/***/ 770:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


/**
 * KTUI - Free & Open-Source Tailwind UI Components by Keenthemes
 * Copyright 2025 by Keenthemes Inc
 */
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.KTStepper = void 0;
var data_1 = __webpack_require__(8716);
var dom_1 = __webpack_require__(9010);
var component_1 = __webpack_require__(2658);
var KTStepper = /** @class */ (function (_super) {
    __extends(KTStepper, _super);
    function KTStepper(element, config) {
        if (config === void 0) { config = null; }
        var _this = _super.call(this) || this;
        _this._name = 'stepper';
        _this._defaultConfig = {
            hiddenClass: 'hidden',
            activeStep: 1,
        };
        _this._config = _this._defaultConfig;
        _this._activeStep = 0;
        _this._nextElement = null;
        _this._backElement = null;
        if (data_1.default.has(element, _this._name))
            return _this;
        _this._init(element);
        _this._buildConfig(config);
        if (!_this._element)
            return _this;
        _this._nextElement = _this._element.querySelector('[data-kt-stepper-next]');
        _this._backElement = _this._element.querySelector('[data-kt-stepper-back]');
        _this._activeStep = 1;
        if (_this._getOption('activeStep') !== _this._activeStep) {
            _this._go(_this._getOption('activeStep'));
        }
        _this._update();
        _this._handlers();
        return _this;
    }
    KTStepper.prototype._handlers = function () {
        var _this = this;
        if (!this._nextElement) {
            console.error('data-kt-stepper-next not found');
            return;
        }
        if (this._nextElement) {
            this._nextElement.addEventListener('click', function (event) {
                event.preventDefault();
                _this._goNext();
            });
        }
        if (this._backElement) {
            this._backElement.addEventListener('click', function (event) {
                event.preventDefault();
                _this._goBack();
            });
        }
    };
    KTStepper.prototype._update = function () {
        var _this = this;
        if (!this._element)
            return;
        var state = '';
        if (this._activeStep === this._getTotalSteps()) {
            state = 'last';
        }
        else if (this._activeStep === 1) {
            state = 'first';
        }
        else {
            state = 'between';
        }
        this._element.classList.remove('first');
        this._element.classList.remove('last');
        this._element.classList.remove('between');
        this._element.classList.add(state);
        this._getItemElements().forEach(function (element, index) {
            var contentElement = dom_1.default.getElement(element.getAttribute('data-kt-stepper-item'));
            if (!contentElement)
                return;
            element.classList.remove('active');
            element.classList.remove('completed');
            element.classList.remove('pending');
            var numberElement = element.querySelector('[data-kt-stepper-number]');
            if (numberElement)
                numberElement.innerHTML = String(index + 1);
            if (index + 1 == _this._activeStep) {
                element.classList.add('active');
                contentElement.classList.remove(_this._getOption('hiddenClass'));
            }
            else {
                contentElement.classList.add(_this._getOption('hiddenClass'));
                if (index + 1 < _this._activeStep) {
                    element.classList.add('completed');
                }
                else {
                    element.classList.add('pending');
                }
            }
        });
    };
    KTStepper.prototype._getItemElements = function () {
        var elements = [];
        this._element
            .querySelectorAll('[data-kt-stepper-item]')
            .forEach(function (element) {
            if (dom_1.default.isVisible(element)) {
                elements.push(element);
            }
        });
        return elements;
    };
    KTStepper.prototype._go = function (step) {
        if (step === this._activeStep || step > this._getTotalSteps() || step < 0)
            return;
        var payload = { step: step, cancel: false };
        this._fireEvent('change', payload);
        this._dispatchEvent('change', payload);
        if (payload.cancel === true) {
            return;
        }
        this._activeStep = step;
        this._update();
        this._fireEvent('changed');
        this._dispatchEvent('changed');
    };
    KTStepper.prototype._goTo = function (itemElement) {
        var step = this._getStep(itemElement);
        this._go(step);
    };
    KTStepper.prototype._getStep = function (itemElement) {
        var step = -1;
        this._getItemElements().forEach(function (element, index) {
            if (element === itemElement) {
                step = index + 1;
                return;
            }
        });
        return step;
    };
    KTStepper.prototype._getItemElement = function (step) {
        return this._getItemElements()[step - 1];
    };
    KTStepper.prototype._getTotalSteps = function () {
        return this._getItemElements().length;
    };
    KTStepper.prototype._goNext = function () {
        var step;
        if (this._getTotalSteps() >= this._activeStep + 1) {
            step = this._activeStep + 1;
        }
        else {
            step = this._getTotalSteps();
        }
        this._go(step);
    };
    KTStepper.prototype._goBack = function () {
        var step;
        if (this._activeStep - 1 > 1) {
            step = this._activeStep - 1;
        }
        else {
            step = 1;
        }
        this._go(step);
    };
    KTStepper.prototype._goLast = function () {
        var step = this._getTotalSteps();
        this._go(step);
    };
    KTStepper.prototype._goFirst = function () {
        var step = 1;
        this._go(step);
    };
    KTStepper.prototype._isLast = function () {
        return this._getTotalSteps() === this._activeStep + 1;
    };
    KTStepper.prototype._isFirst = function () {
        return this._activeStep === 1;
    };
    KTStepper.prototype.isLast = function () {
        return this._isLast();
    };
    KTStepper.prototype.isFirst = function () {
        return this._isFirst();
    };
    KTStepper.prototype.go = function (step) {
        this._go(step);
    };
    KTStepper.prototype.goTo = function (itemElement) {
        this.goTo(itemElement);
    };
    KTStepper.prototype.goFirst = function () {
        this._goFirst();
    };
    KTStepper.prototype.goLast = function () {
        this._goLast();
    };
    KTStepper.prototype.goNext = function () {
        this._goNext();
    };
    KTStepper.prototype.goBack = function () {
        this._goBack();
    };
    KTStepper.prototype.update = function () {
        this._update();
    };
    KTStepper.prototype.getStep = function (itemElement) {
        return this._getStep(itemElement);
    };
    KTStepper.prototype.getItemElement = function (step) {
        return this._getItemElement(step);
    };
    KTStepper.prototype.getTotalSteps = function () {
        return this._getTotalSteps();
    };
    KTStepper.prototype.getItemElements = function () {
        return this._getItemElements();
    };
    KTStepper.getInstance = function (element) {
        if (!element)
            return null;
        if (data_1.default.has(element, 'stepper')) {
            return data_1.default.get(element, 'stepper');
        }
        if (element.getAttribute('data-kt-stepper')) {
            return new KTStepper(element);
        }
        return null;
    };
    KTStepper.getOrCreateInstance = function (element, config) {
        return this.getInstance(element) || new KTStepper(element, config);
    };
    KTStepper.createInstances = function () {
        var elements = document.querySelectorAll('[data-kt-stepper]');
        elements.forEach(function (element) {
            new KTStepper(element);
        });
    };
    KTStepper.init = function () {
        KTStepper.createInstances();
    };
    return KTStepper;
}(component_1.default));
exports.KTStepper = KTStepper;
if (typeof window !== 'undefined') {
    window.KTStepper = KTStepper;
}


/***/ }),

/***/ 1069:
/***/ (function(__unused_webpack_module, exports) {


/**
 * KTUI - Free & Open-Source Tailwind UI Components by Keenthemes
 * Copyright 2025 by Keenthemes Inc
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.KTDatepickerEvents = void 0;
/**
 * KTDatepicker events enum
 */
var KTDatepickerEvents;
(function (KTDatepickerEvents) {
    KTDatepickerEvents["CALENDAR_UPDATE"] = "kt.datepicker.calendar.update";
    KTDatepickerEvents["DAY_SELECT"] = "kt.datepicker.day.select";
    KTDatepickerEvents["MONTH_CHANGE"] = "kt.datepicker.month.change";
    KTDatepickerEvents["DROPDOWN_SHOW"] = "kt.datepicker.dropdown.show";
    KTDatepickerEvents["DROPDOWN_HIDE"] = "kt.datepicker.dropdown.hide";
    KTDatepickerEvents["CHANGE"] = "kt.datepicker.change";
    KTDatepickerEvents["OPEN"] = "kt.datepicker.open";
    KTDatepickerEvents["CLOSE"] = "kt.datepicker.close";
    KTDatepickerEvents["GET_RANGE"] = "kt.datepicker.getRange";
})(KTDatepickerEvents || (exports.KTDatepickerEvents = KTDatepickerEvents = {}));


/***/ }),

/***/ 1132:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


/**
 * KTUI - Free & Open-Source Tailwind UI Components by Keenthemes
 * Copyright 2025 by Keenthemes Inc
 */
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.KTToggle = void 0;
var data_1 = __webpack_require__(8716);
var dom_1 = __webpack_require__(9010);
var component_1 = __webpack_require__(2658);
var KTToggle = /** @class */ (function (_super) {
    __extends(KTToggle, _super);
    function KTToggle(element, config) {
        if (config === void 0) { config = null; }
        var _this = _super.call(this) || this;
        _this._name = 'toggle';
        _this._defaultConfig = {
            target: '',
            activeClass: 'active',
            class: '',
            removeClass: '',
            attribute: '',
        };
        _this._config = _this._defaultConfig;
        if (data_1.default.has(element, _this._name))
            return _this;
        _this._init(element);
        _this._buildConfig(config);
        _this._targetElement = _this._getTargetElement();
        if (!_this._targetElement) {
            return _this;
        }
        _this._handlers();
        return _this;
    }
    KTToggle.prototype._handlers = function () {
        var _this = this;
        if (!this._element)
            return;
        this._element.addEventListener('click', function () {
            _this._toggle();
        });
    };
    KTToggle.prototype._getTargetElement = function () {
        return (dom_1.default.getElement(this._element.getAttribute('data-kt-toggle')) || dom_1.default.getElement(this._getOption('target')));
    };
    KTToggle.prototype._toggle = function () {
        if (!this._element)
            return;
        var payload = { cancel: false };
        this._fireEvent('toggle', payload);
        this._dispatchEvent('toggle', payload);
        if (payload.cancel === true) {
            return;
        }
        this._element.classList.toggle(this._getOption('activeClass'));
        this._update();
        this._fireEvent('toggled');
        this._dispatchEvent('toggled');
    };
    KTToggle.prototype._update = function () {
        if (!this._targetElement)
            return;
        if (this._getOption('removeClass')) {
            dom_1.default.removeClass(this._targetElement, this._getOption('removeClass'));
        }
        if (!this._isActive()) {
            if (this._getOption('class')) {
                dom_1.default.addClass(this._targetElement, this._getOption('class'));
            }
            if (this._getOption('attribute')) {
                this._targetElement.setAttribute(this._getOption('attribute'), 'true');
            }
        }
        else {
            if (this._getOption('class')) {
                dom_1.default.removeClass(this._targetElement, this._getOption('class'));
            }
            if (this._getOption('attribute')) {
                this._targetElement.removeAttribute(this._getOption('attribute'));
            }
        }
    };
    KTToggle.prototype._isActive = function () {
        if (!this._element)
            return false;
        return (dom_1.default.hasClass(this._targetElement, this._getOption('class')) ||
            this._targetElement.hasAttribute(this._getOption('attribute')));
    };
    KTToggle.prototype.toggle = function () {
        this._toggle();
    };
    KTToggle.prototype.update = function () {
        this._update();
    };
    KTToggle.prototype.isActive = function () {
        return this._isActive();
    };
    KTToggle.getInstance = function (element) {
        if (!element)
            return null;
        if (data_1.default.has(element, 'toggle')) {
            return data_1.default.get(element, 'toggle');
        }
        if (element.getAttribute('data-kt-toggle')) {
            return new KTToggle(element);
        }
        return null;
    };
    KTToggle.getOrCreateInstance = function (element, config) {
        return this.getInstance(element) || new KTToggle(element, config);
    };
    KTToggle.createInstances = function () {
        var elements = document.querySelectorAll('[data-kt-toggle]');
        elements.forEach(function (element) {
            new KTToggle(element);
        });
    };
    KTToggle.init = function () {
        KTToggle.createInstances();
    };
    return KTToggle;
}(component_1.default));
exports.KTToggle = KTToggle;
if (typeof window !== 'undefined') {
    window.KTToggle = KTToggle;
}


/***/ }),

/***/ 1396:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


/**
 * KTUI - Free & Open-Source Tailwind UI Components by Keenthemes
 * Copyright 2025 by Keenthemes Inc
 */
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.KTTabs = void 0;
var data_1 = __webpack_require__(8716);
var dom_1 = __webpack_require__(9010);
var event_handler_1 = __webpack_require__(5183);
var component_1 = __webpack_require__(2658);
var KTTabs = /** @class */ (function (_super) {
    __extends(KTTabs, _super);
    function KTTabs(element, config) {
        var _this = _super.call(this) || this;
        _this._name = 'tabs';
        _this._defaultConfig = {
            hiddenClass: 'hidden',
        };
        _this._config = _this._defaultConfig;
        _this._currentTabElement = null;
        _this._currentContentElement = null;
        _this._lastTabElement = null;
        _this._lastContentElement = null;
        _this._tabElements = null;
        _this._isTransitioning = false;
        if (data_1.default.has(element, _this._name))
            return _this;
        _this._init(element);
        _this._buildConfig(config);
        if (!_this._element)
            return _this;
        _this._tabElements = _this._element.querySelectorAll('[data-kt-tab-toggle]');
        _this._currentTabElement = _this._element.querySelector('.active[data-kt-tab-toggle]');
        _this._currentContentElement =
            (_this._currentTabElement &&
                (dom_1.default.getElement(_this._currentTabElement.getAttribute('data-kt-tab-toggle')) ||
                    dom_1.default.getElement(_this._currentTabElement.getAttribute('href')))) ||
                null;
        _this._handlers();
        return _this;
    }
    KTTabs.prototype._handlers = function () {
        var _this = this;
        if (!this._element)
            return;
        event_handler_1.default.on(this._element, '[data-kt-tab-toggle]', 'click', function (event, target) {
            event.preventDefault();
            _this._show(target);
        });
    };
    KTTabs.prototype._show = function (tabElement) {
        var _this = this;
        var _a, _b, _c, _d, _e, _f, _g, _h;
        if (this._isShown(tabElement) || this._isTransitioning)
            return;
        var payload = { cancel: false };
        this._fireEvent('show', payload);
        this._dispatchEvent('show', payload);
        if (payload.cancel === true) {
            return;
        }
        (_a = this._currentTabElement) === null || _a === void 0 ? void 0 : _a.classList.remove('active');
        (_b = this._currentTabElement) === null || _b === void 0 ? void 0 : _b.classList.remove('selected');
        (_c = this._currentContentElement) === null || _c === void 0 ? void 0 : _c.classList.add(this._getOption('hiddenClass'));
        this._lastTabElement = this._currentTabElement;
        (_d = this._getDropdownToggleElement(this._lastTabElement)) === null || _d === void 0 ? void 0 : _d.classList.remove('active');
        this._lastContentElement = this._currentContentElement;
        this._currentTabElement = tabElement;
        this._currentContentElement =
            dom_1.default.getElement(tabElement.getAttribute('data-kt-tab-toggle')) ||
                dom_1.default.getElement(tabElement.getAttribute('href'));
        (_e = this._currentTabElement) === null || _e === void 0 ? void 0 : _e.classList.add('active');
        (_f = this._currentTabElement) === null || _f === void 0 ? void 0 : _f.classList.add('selected');
        (_g = this._currentContentElement) === null || _g === void 0 ? void 0 : _g.classList.remove(this._getOption('hiddenClass'));
        (_h = this._getDropdownToggleElement(this._currentTabElement)) === null || _h === void 0 ? void 0 : _h.classList.add('active');
        this._currentContentElement.style.opacity = '0';
        dom_1.default.reflow(this._currentContentElement);
        this._currentContentElement.style.opacity = '1';
        dom_1.default.transitionEnd(this._currentContentElement, function () {
            _this._isTransitioning = false;
            _this._currentContentElement.style.opacity = '';
            _this._fireEvent('shown');
            _this._dispatchEvent('shown');
        });
    };
    KTTabs.prototype._getDropdownToggleElement = function (element) {
        var containerElement = element.closest('[data-kt-dropdown-initialized],[data-kt-menu-initialized]');
        if (containerElement) {
            return containerElement.querySelector('[data-kt-dropdown-toggle], [data-kt-menu-toggle]');
        }
        else {
            return null;
        }
    };
    KTTabs.prototype._isShown = function (tabElement) {
        return tabElement.classList.contains('active');
    };
    KTTabs.prototype.isShown = function (tabElement) {
        return this._isShown(tabElement);
    };
    KTTabs.prototype.show = function (tabElement) {
        return this._show(tabElement);
    };
    KTTabs.keyboardArrow = function () { };
    KTTabs.keyboardJump = function () { };
    KTTabs.handleAccessibility = function () { };
    KTTabs.getInstance = function (element) {
        if (!element)
            return null;
        if (data_1.default.has(element, 'tabs')) {
            return data_1.default.get(element, 'tabs');
        }
        if (element.getAttribute('data-kt-tabs')) {
            return new KTTabs(element);
        }
        return null;
    };
    KTTabs.getOrCreateInstance = function (element, config) {
        return this.getInstance(element) || new KTTabs(element, config);
    };
    KTTabs.createInstances = function () {
        var elements = document.querySelectorAll('[data-kt-tabs]');
        elements.forEach(function (element) {
            new KTTabs(element);
        });
    };
    KTTabs.init = function () {
        KTTabs.createInstances();
        if (window.KT_TABS_INITIALIZED !== true) {
            KTTabs.handleAccessibility();
            window.KT_TABS_INITIALIZED = true;
        }
    };
    return KTTabs;
}(component_1.default));
exports.KTTabs = KTTabs;
if (typeof window !== 'undefined') {
    window.KTTabs = KTTabs;
}


/***/ }),

/***/ 1794:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


/**
 * KTUI - Free & Open-Source Tailwind UI Components by Keenthemes
 * Copyright 2025 by Keenthemes Inc
 */
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.KTCollapse = void 0;
/* eslint-disable max-len */
/* eslint-disable require-jsdoc */
var data_1 = __webpack_require__(8716);
var dom_1 = __webpack_require__(9010);
var component_1 = __webpack_require__(2658);
var KTCollapse = /** @class */ (function (_super) {
    __extends(KTCollapse, _super);
    function KTCollapse(element, config) {
        var _this = _super.call(this) || this;
        _this._name = 'collapse';
        _this._defaultConfig = {
            hiddenClass: 'hidden',
            activeClass: 'active',
            target: '',
        };
        _this._config = _this._defaultConfig;
        _this._isAnimating = false;
        if (data_1.default.has(element, _this._name))
            return _this;
        _this._init(element);
        _this._buildConfig(config);
        _this._targetElement = _this._getTargetElement();
        if (!_this._targetElement) {
            return _this;
        }
        _this._handlers();
        return _this;
    }
    KTCollapse.prototype._getTargetElement = function () {
        return (dom_1.default.getElement(this._element.getAttribute('data-kt-collapse')) || dom_1.default.getElement(this._getOption('target')));
    };
    KTCollapse.prototype._isOpen = function () {
        return this._targetElement.classList.contains(this._getOption('activeClass'));
    };
    KTCollapse.prototype._handlers = function () {
        var _this = this;
        this._element.addEventListener('click', function (event) {
            event.preventDefault();
            _this._toggle();
        });
    };
    KTCollapse.prototype._expand = function () {
        var _this = this;
        if (this._isAnimating || this._isOpen()) {
            return;
        }
        var payload = { cancel: false };
        this._fireEvent('expand', payload);
        this._dispatchEvent('expand', payload);
        if (payload.cancel === true) {
            return;
        }
        if (this._element) {
            this._element.setAttribute('aria-expanded', 'true');
            this._element.classList.add(this._getOption('activeClass'));
        }
        this._targetElement.classList.remove(this._getOption('hiddenClass'));
        this._targetElement.classList.add(this._getOption('activeClass'));
        this._targetElement.style.height = '0px';
        this._targetElement.style.overflow = 'hidden';
        dom_1.default.reflow(this._targetElement);
        this._targetElement.style.height = "".concat(this._targetElement.scrollHeight, "px");
        this._isAnimating = true;
        dom_1.default.transitionEnd(this._targetElement, function () {
            _this._isAnimating = false;
            _this._targetElement.style.height = '';
            _this._targetElement.style.overflow = '';
            _this._fireEvent('expanded');
            _this._dispatchEvent('expanded');
        });
    };
    KTCollapse.prototype._collapse = function () {
        var _this = this;
        if (this._isAnimating || !this._isOpen()) {
            return;
        }
        var payload = { cancel: false };
        this._fireEvent('collapse', payload);
        this._dispatchEvent('collapse', payload);
        if (payload.cancel === true) {
            return;
        }
        if (!this._element)
            return;
        this._element.setAttribute('aria-expanded', 'false');
        this._element.classList.remove(this._getOption('activeClass'));
        this._targetElement.classList.remove(this._getOption('activeClass'));
        this._targetElement.style.height = "".concat(this._targetElement.scrollHeight, "px");
        dom_1.default.reflow(this._targetElement);
        this._targetElement.style.height = "0px";
        this._targetElement.style.overflow = 'hidden';
        this._isAnimating = true;
        dom_1.default.transitionEnd(this._targetElement, function () {
            _this._isAnimating = false;
            _this._targetElement.classList.add(_this._getOption('hiddenClass'));
            _this._targetElement.style.overflow = '';
            _this._fireEvent('collapsed');
            _this._dispatchEvent('collapsed');
        });
    };
    KTCollapse.prototype._toggle = function () {
        var payload = { cancel: false };
        this._fireEvent('toggle', payload);
        this._dispatchEvent('toggle', payload);
        if (payload.cancel === true) {
            return;
        }
        if (this._isOpen()) {
            this._collapse();
        }
        else {
            this._expand();
        }
    };
    KTCollapse.prototype.expand = function () {
        return this._expand();
    };
    KTCollapse.prototype.collapse = function () {
        return this._collapse();
    };
    KTCollapse.prototype.isOpen = function () {
        return this._isOpen();
    };
    KTCollapse.getInstance = function (element) {
        if (!element)
            return null;
        if (data_1.default.has(element, 'collapse')) {
            return data_1.default.get(element, 'collapse');
        }
        if (element.getAttribute('data-kt-collapse')) {
            return new KTCollapse(element);
        }
        return null;
    };
    KTCollapse.getOrCreateInstance = function (element, config) {
        return this.getInstance(element) || new KTCollapse(element, config);
    };
    KTCollapse.createInstances = function () {
        var elements = document.querySelectorAll('[data-kt-collapse]');
        elements.forEach(function (element) {
            new KTCollapse(element);
        });
    };
    KTCollapse.init = function () {
        KTCollapse.createInstances();
    };
    return KTCollapse;
}(component_1.default));
exports.KTCollapse = KTCollapse;
if (typeof window !== 'undefined') {
    window.KTCollapse = KTCollapse;
}


/***/ }),

/***/ 1850:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


/**
 * KTUI - Free & Open-Source Tailwind UI Components by Keenthemes
 * Copyright 2025 by Keenthemes Inc
 */
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.KTTooltip = void 0;
var data_1 = __webpack_require__(8716);
var dom_1 = __webpack_require__(9010);
var component_1 = __webpack_require__(2658);
var core_1 = __webpack_require__(3915);
var KTTooltip = /** @class */ (function (_super) {
    __extends(KTTooltip, _super);
    function KTTooltip(element, config) {
        if (config === void 0) { config = null; }
        var _this = _super.call(this) || this;
        _this._name = 'tooltip';
        _this._defaultConfig = {
            target: '',
            hiddenClass: 'hidden',
            trigger: 'hover',
            placement: 'top',
            placementRtl: 'top',
            container: '',
            strategy: 'fixed',
            offset: '0, 5px',
            offsetRtl: '0, 5px',
            delayShow: 0,
            delayHide: 0,
            permanent: false,
            zindex: '100',
        };
        _this._config = _this._defaultConfig;
        _this._isOpen = false;
        _this._transitioning = false;
        if (data_1.default.has(element, _this._name))
            return _this;
        _this._init(element);
        _this._buildConfig(config);
        _this._targetElement = _this._getTargetElement();
        if (!_this._targetElement) {
            return _this;
        }
        _this._handlers();
        return _this;
    }
    KTTooltip.prototype._getTargetElement = function () {
        return (dom_1.default.getElement(this._element.getAttribute('data-kt-tooltip')) ||
            this._element.querySelector('[data-kt-tooltip-content]') ||
            dom_1.default.getElement(this._getOption('target')));
    };
    KTTooltip.prototype._handlers = function () {
        var _this = this;
        if (!this._element)
            return;
        if (this._getOption('trigger') === 'click') {
            this._element.addEventListener('click', function () { return _this._toggle(); });
        }
        if (this._getOption('trigger') === 'focus') {
            this._element.addEventListener('focus', function () { return _this._toggle(); });
            this._element.addEventListener('blur', function () { return _this._hide(); });
        }
        if (this._getOption('trigger') === 'hover') {
            this._element.addEventListener('mouseenter', function () { return _this._show(); });
            this._element.addEventListener('mouseleave', function () { return _this._hide(); });
        }
    };
    KTTooltip.prototype._show = function () {
        var _this = this;
        if (this._timeout) {
            clearTimeout(this._timeout);
        }
        if (this._isOpen)
            return;
        this._timeout = setTimeout(function () {
            var payload = { cancel: false };
            _this._fireEvent('show', payload);
            _this._dispatchEvent('show', payload);
            if (payload.cancel === true) {
                return;
            }
            if (!_this._targetElement) {
                return;
            }
            if (!_this._element)
                return;
            _this._createPopper();
            _this._handleContainer();
            _this._setZindex();
            _this._targetElement.classList.add('show');
            _this._targetElement.classList.remove(_this._getOption('hiddenClass'));
            _this._targetElement.style.opacity = '0';
            dom_1.default.reflow(_this._targetElement);
            _this._targetElement.style.opacity = '1';
            _this._transitioning = true;
            _this._isOpen = true;
            dom_1.default.transitionEnd(_this._targetElement, function () {
                _this._targetElement.style.opacity = '';
                _this._transitioning = false;
                _this._fireEvent('shown');
                _this._dispatchEvent('shown');
            });
        }, this._getOption('delayShow'));
    };
    KTTooltip.prototype._hide = function () {
        var _this = this;
        if (this._timeout) {
            clearTimeout(this._timeout);
        }
        if (!this._isOpen)
            return;
        this._timeout = setTimeout(function () {
            var payload = { cancel: false };
            _this._fireEvent('hide', payload);
            _this._dispatchEvent('hide', payload);
            if (payload.cancel === true) {
                return;
            }
            if (!_this._targetElement) {
                return;
            }
            _this._targetElement.style.opacity = '1';
            dom_1.default.reflow(_this._targetElement);
            _this._targetElement.style.opacity = '0';
            _this._transitioning = true;
            _this._isOpen = false;
            dom_1.default.transitionEnd(_this._targetElement, function () {
                _this._popper.destroy();
                _this._targetElement.classList.remove('show');
                _this._targetElement.classList.add(_this._getOption('hiddenClass'));
                _this._targetElement.style.opacity = '';
                _this._transitioning = false;
                _this._fireEvent('hidden');
                _this._dispatchEvent('hidden');
            });
        }, this._getOption('delayHide'));
    };
    KTTooltip.prototype._toggle = function () {
        var payload = { cancel: false };
        this._fireEvent('toggle', payload);
        this._dispatchEvent('toggle', payload);
        if (payload.cancel === true) {
            return;
        }
        if (this._isOpen) {
            this._hide();
        }
        else {
            this._show();
        }
    };
    KTTooltip.prototype._createPopper = function () {
        if (!this._element)
            return;
        var isRtl = dom_1.default.isRTL();
        // Placement
        var placement = this._getOption('placement');
        if (isRtl && this._getOption('placementRtl')) {
            placement = this._getOption('placementRtl');
        }
        // Offset
        var offsetValue = this._getOption('offset');
        if (isRtl && this._getOption('offsetRtl')) {
            offsetValue = this._getOption('offsetRtl');
        }
        var offset = offsetValue
            ? offsetValue
                .toString()
                .split(',')
                .map(function (value) { return parseInt(value.trim(), 10); })
            : [0, 0];
        if (!this._targetElement) {
            return;
        }
        this._popper = (0, core_1.createPopper)(this._element, this._targetElement, {
            placement: placement,
            strategy: this._getOption('strategy'),
            modifiers: [
                {
                    name: 'offset',
                    options: {
                        offset: offset,
                    },
                },
            ],
        });
    };
    KTTooltip.prototype._handleContainer = function () {
        var _a;
        if (this._getOption('container')) {
            if (this._getOption('container') === 'body') {
                document.body.appendChild(this._targetElement);
            }
            else {
                (_a = document
                    .querySelector(this._getOption('container'))) === null || _a === void 0 ? void 0 : _a.appendChild(this._targetElement);
            }
        }
    };
    KTTooltip.prototype._setZindex = function () {
        var zindex = parseInt(this._getOption('zindex'));
        if (parseInt(dom_1.default.getCssProp(this._element, 'z-index')) > zindex) {
            zindex = parseInt(dom_1.default.getCssProp(this._element, 'z-index'));
        }
        if (dom_1.default.getHighestZindex(this._element) > zindex) {
            zindex = dom_1.default.getHighestZindex(this._element) + 1;
        }
        this._targetElement.style.zIndex = String(zindex);
    };
    KTTooltip.prototype.show = function () {
        this._show();
    };
    KTTooltip.prototype.hide = function () {
        this._hide();
    };
    KTTooltip.prototype.toggle = function () {
        this._toggle();
    };
    KTTooltip.prototype.getContentElement = function () {
        return this._targetElement;
    };
    KTTooltip.prototype.isOpen = function () {
        return this._isOpen;
    };
    KTTooltip.prototype.getTriggerOption = function () {
        return this._getOption('trigger');
    };
    KTTooltip.prototype.isPermanent = function () {
        return this._getOption('permanent');
    };
    KTTooltip.initHandlers = function () {
        document.addEventListener('click', function (event) {
            document
                .querySelectorAll('[data-kt-tooltip-initialized]')
                .forEach(function (tooltipElement) {
                var tooltip = KTTooltip.getInstance(tooltipElement);
                if (tooltip &&
                    tooltip.isOpen() &&
                    tooltip.getTriggerOption() !== 'hover' &&
                    !tooltip.isPermanent()) {
                    var contentElement = tooltip.getContentElement();
                    if (contentElement &&
                        (contentElement === event.target ||
                            contentElement.contains(event.target))) {
                        return;
                    }
                    else {
                        tooltip.hide();
                    }
                }
            });
        });
    };
    KTTooltip.getInstance = function (element) {
        if (!element)
            return null;
        if (data_1.default.has(element, 'tooltip')) {
            return data_1.default.get(element, 'tooltip');
        }
        if (element.getAttribute('data-kt-tooltip')) {
            return new KTTooltip(element);
        }
        return null;
    };
    KTTooltip.getOrCreateInstance = function (element, config) {
        return this.getInstance(element) || new KTTooltip(element, config);
    };
    KTTooltip.createInstances = function () {
        document.querySelectorAll('[data-kt-tooltip]').forEach(function (element) {
            new KTTooltip(element);
        });
    };
    KTTooltip.init = function () {
        KTTooltip.createInstances();
        if (window.KT_TOOLTIP_INITIALIZED !== true) {
            KTTooltip.initHandlers();
            window.KT_TOOLTIP_INITIALIZED = true;
        }
    };
    return KTTooltip;
}(component_1.default));
exports.KTTooltip = KTTooltip;
if (typeof window !== 'undefined') {
    window.KTTooltip = KTTooltip;
}


/***/ }),

/***/ 1851:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


/**
 * KTUI - Free & Open-Source Tailwind UI Components by Keenthemes
 * Copyright 2025 by Keenthemes Inc
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.KTScrollable = void 0;
var scrollable_1 = __webpack_require__(4850);
Object.defineProperty(exports, "KTScrollable", ({ enumerable: true, get: function () { return scrollable_1.KTScrollable; } }));


/***/ }),

/***/ 2232:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


/**
 * KTUI - Free & Open-Source Tailwind UI Components by Keenthemes
 * Copyright 2025 by Keenthemes Inc
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.KTTogglePassword = void 0;
var toggle_password_1 = __webpack_require__(7490);
Object.defineProperty(exports, "KTTogglePassword", ({ enumerable: true, get: function () { return toggle_password_1.KTTogglePassword; } }));


/***/ }),

/***/ 2393:
/***/ (function(__unused_webpack_module, exports) {


/**
 * KTUI - Free & Open-Source Tailwind UI Components by Keenthemes
 * Copyright 2025 by Keenthemes Inc
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.formatDate = formatDate;
exports.parseDate = parseDate;
exports.isValidDate = isValidDate;
exports.getDaysInMonth = getDaysInMonth;
exports.getFirstDayOfMonth = getFirstDayOfMonth;
exports.padZero = padZero;
exports.getLocaleConfig = getLocaleConfig;
exports.isDateBetween = isDateBetween;
exports.isSameDay = isSameDay;
exports.isWeekend = isWeekend;
exports.isDateDisabled = isDateDisabled;
exports.generateCalendarMonth = generateCalendarMonth;
exports.isDateEqual = isDateEqual;
exports.isDateInRange = isDateInRange;
/**
 * Format a date according to the provided format string
 *
 * @param date - Date to format
 * @param format - Format string
 * @param config - Datepicker configuration
 * @returns Formatted date string
 */
function formatDate(date, format, config) {
    if (!date || !(date instanceof Date) || isNaN(date.getTime())) {
        return '';
    }
    var locale = getLocaleConfig(config);
    var isLeadingZero = config.forceLeadingZero;
    // Replace year tokens
    var year = date.getFullYear();
    format = format.replace(/yyyy/g, year.toString());
    format = format.replace(/yy/g, year.toString().slice(-2));
    // Replace month tokens
    var month = date.getMonth();
    var monthNum = month + 1;
    format = format.replace(/MMMM/g, locale.monthNames[month]);
    format = format.replace(/MMM/g, locale.monthNamesShort[month]);
    format = format.replace(/MM/g, isLeadingZero ? padZero(monthNum) : monthNum.toString());
    format = format.replace(/M/g, monthNum.toString());
    // Replace day tokens
    var day = date.getDate();
    format = format.replace(/dd/g, isLeadingZero ? padZero(day) : day.toString());
    format = format.replace(/d/g, day.toString());
    // Replace day of week tokens
    var dayOfWeek = date.getDay();
    format = format.replace(/EEEE/g, locale.dayNames[dayOfWeek]);
    format = format.replace(/EEE/g, locale.dayNamesShort[dayOfWeek]);
    format = format.replace(/E/g, locale.dayNamesMin[dayOfWeek]);
    // Replace time tokens if time is enabled
    if (config.enableTime) {
        var hours = date.getHours();
        var minutes = date.getMinutes();
        var seconds = date.getSeconds();
        // 24-hour format
        format = format.replace(/HH/g, isLeadingZero ? padZero(hours) : hours.toString());
        format = format.replace(/H/g, hours.toString());
        // 12-hour format
        var hours12 = hours % 12 || 12;
        format = format.replace(/hh/g, isLeadingZero ? padZero(hours12) : hours12.toString());
        format = format.replace(/h/g, hours12.toString());
        // Minutes and seconds
        format = format.replace(/mm/g, isLeadingZero ? padZero(minutes) : minutes.toString());
        format = format.replace(/m/g, minutes.toString());
        format = format.replace(/ss/g, isLeadingZero ? padZero(seconds) : seconds.toString());
        format = format.replace(/s/g, seconds.toString());
        // AM/PM
        var ampm = hours >= 12 ? config.pm : config.am;
        format = format.replace(/A/g, ampm);
        format = format.replace(/a/g, ampm.toLowerCase());
        // Timezone (simplified implementation)
        var timezoneOffset = date.getTimezoneOffset();
        var timezoneOffsetHours = Math.abs(Math.floor(timezoneOffset / 60));
        var timezoneOffsetMinutes = Math.abs(timezoneOffset % 60);
        var timezoneSign = timezoneOffset > 0 ? '-' : '+';
        var formattedTimezone = "".concat(timezoneSign).concat(padZero(timezoneOffsetHours), ":").concat(padZero(timezoneOffsetMinutes));
        format = format.replace(/ZZZ/g, formattedTimezone);
    }
    return format;
}
/**
 * Parse a date string according to the provided format
 *
 * @param dateStr - Date string to parse
 * @param format - Format string
 * @param config - Datepicker configuration
 * @returns Parsed date or null if invalid
 */
function parseDate(dateStr, format, config) {
    if (!dateStr)
        return null;
    // Handle natural language dates if enabled
    if (config.enableNaturalLanguage) {
        var naturalDate = parseNaturalLanguageDate(dateStr);
        if (naturalDate)
            return naturalDate;
    }
    // Create a new date object to populate
    var date = new Date();
    date.setHours(0, 0, 0, 0);
    // Extract parts from the format
    var formatParts = {};
    var formatRegex = format
        .replace(/(\w)(\1*)/g, function (_, p1, p2) {
        var length = p1.length + p2.length;
        var token = '';
        switch (p1) {
            case 'y':
                token = length > 2 ? 'yyyy' : 'yy';
                break;
            case 'M':
                token = ['M', 'MM', 'MMM', 'MMMM'][Math.min(length - 1, 3)];
                break;
            case 'd':
                token = length > 1 ? 'dd' : 'd';
                break;
            case 'E':
                token = length > 3 ? 'EEEE' : length > 1 ? 'EEE' : 'E';
                break;
            case 'h':
            case 'H':
                token = length > 1 ? p1 + p1 : p1;
                break;
            case 'm':
                token = length > 1 ? 'mm' : 'm';
                break;
            case 's':
                token = length > 1 ? 'ss' : 's';
                break;
            case 'a':
            case 'A':
                token = p1;
                break;
            default:
                token = p1.repeat(length);
        }
        formatParts[token] = '';
        return "(\\d+|[a-zA-Z]+)";
    })
        .replace(/[^\w\s]/g, '\\$&');
    var match = new RegExp(formatRegex).exec(dateStr);
    if (!match)
        return null;
    // Map format tokens to their extracted values
    var i = 1;
    for (var token in formatParts) {
        formatParts[token] = match[i++];
    }
    // Extract year
    if (formatParts.yyyy) {
        date.setFullYear(parseInt(formatParts.yyyy));
    }
    else if (formatParts.yy) {
        var year = parseInt(formatParts.yy);
        var century = Math.floor(new Date().getFullYear() / 100) * 100;
        date.setFullYear(century + year);
    }
    // Extract month
    if (formatParts.MM || formatParts.M) {
        var month = parseInt(formatParts.MM || formatParts.M) - 1;
        if (month >= 0 && month <= 11) {
            date.setMonth(month);
        }
    }
    else if (formatParts.MMM || formatParts.MMMM) {
        var monthName_1 = formatParts.MMMM || formatParts.MMM;
        var locale = getLocaleConfig(config);
        var monthIndex = locale.monthNames.findIndex(function (m) { return m.toLowerCase() === monthName_1.toLowerCase(); });
        if (monthIndex === -1) {
            var shortMonthIndex = locale.monthNamesShort.findIndex(function (m) { return m.toLowerCase() === monthName_1.toLowerCase(); });
            if (shortMonthIndex !== -1) {
                date.setMonth(shortMonthIndex);
            }
        }
        else {
            date.setMonth(monthIndex);
        }
    }
    // Extract day
    if (formatParts.dd || formatParts.d) {
        var day = parseInt(formatParts.dd || formatParts.d);
        if (day >= 1 && day <= 31) {
            date.setDate(day);
        }
    }
    // Extract time if needed
    if (config.enableTime) {
        // Hours (24-hour format)
        if (formatParts.HH || formatParts.H) {
            var hours = parseInt(formatParts.HH || formatParts.H);
            if (hours >= 0 && hours <= 23) {
                date.setHours(hours);
            }
        }
        // Hours (12-hour format)
        else if (formatParts.hh || formatParts.h) {
            var hours = parseInt(formatParts.hh || formatParts.h);
            // Adjust for AM/PM
            if (formatParts.A) {
                var isPM = formatParts.A.toUpperCase() === config.pm;
                if (isPM && hours < 12) {
                    hours += 12;
                }
                else if (!isPM && hours === 12) {
                    hours = 0;
                }
            }
            if (hours >= 0 && hours <= 23) {
                date.setHours(hours);
            }
        }
        // Minutes
        if (formatParts.mm || formatParts.m) {
            var minutes = parseInt(formatParts.mm || formatParts.m);
            if (minutes >= 0 && minutes <= 59) {
                date.setMinutes(minutes);
            }
        }
        // Seconds
        if (formatParts.ss || formatParts.s) {
            var seconds = parseInt(formatParts.ss || formatParts.s);
            if (seconds >= 0 && seconds <= 59) {
                date.setSeconds(seconds);
            }
        }
    }
    // Validate the final date
    return isValidDate(date) ? date : null;
}
/**
 * Parse natural language date strings
 *
 * @param input - Natural language date string
 * @returns Parsed date or null if not recognized
 */
function parseNaturalLanguageDate(input) {
    var normalized = input.trim().toLowerCase();
    var now = new Date();
    // Handle common natural language inputs
    switch (normalized) {
        case 'today':
            return new Date(now.setHours(0, 0, 0, 0));
        case 'yesterday': {
            var yesterday = new Date(now);
            yesterday.setDate(yesterday.getDate() - 1);
            yesterday.setHours(0, 0, 0, 0);
            return yesterday;
        }
        case 'tomorrow': {
            var tomorrow = new Date(now);
            tomorrow.setDate(tomorrow.getDate() + 1);
            tomorrow.setHours(0, 0, 0, 0);
            return tomorrow;
        }
        default: {
            // Handle relative dates like "next week", "last month", etc.
            var relativeMatch = normalized.match(/^(next|last|this)\s+(day|week|month|year)$/);
            if (relativeMatch) {
                var _ = relativeMatch[0], direction = relativeMatch[1], unit = relativeMatch[2];
                var result = new Date(now);
                result.setHours(0, 0, 0, 0);
                switch (unit) {
                    case 'day':
                        result.setDate(result.getDate() +
                            (direction === 'next' ? 1 : direction === 'last' ? -1 : 0));
                        break;
                    case 'week':
                        result.setDate(result.getDate() +
                            (direction === 'next' ? 7 : direction === 'last' ? -7 : 0));
                        break;
                    case 'month':
                        result.setMonth(result.getMonth() +
                            (direction === 'next' ? 1 : direction === 'last' ? -1 : 0));
                        break;
                    case 'year':
                        result.setFullYear(result.getFullYear() +
                            (direction === 'next' ? 1 : direction === 'last' ? -1 : 0));
                        break;
                }
                return result;
            }
            return null;
        }
    }
}
/**
 * Check if a date is valid
 *
 * @param date - Date to check
 * @returns Whether the date is valid
 */
function isValidDate(date) {
    return date instanceof Date && !isNaN(date.getTime());
}
/**
 * Get the number of days in a month
 *
 * @param year - Year
 * @param month - Month (0-indexed)
 * @returns Number of days in the month
 */
function getDaysInMonth(year, month) {
    return new Date(year, month + 1, 0).getDate();
}
/**
 * Get the first day of the month
 *
 * @param year - Year
 * @param month - Month (0-indexed)
 * @returns Day of week for the first day (0 = Sunday, 6 = Saturday)
 */
function getFirstDayOfMonth(year, month) {
    return new Date(year, month, 1).getDay();
}
/**
 * Pad a number with a leading zero if needed
 *
 * @param num - Number to pad
 * @returns Padded number string
 */
function padZero(num) {
    return num < 10 ? "0".concat(num) : num.toString();
}
/**
 * Get locale configuration for the datepicker
 *
 * @param config - Datepicker configuration
 * @returns Locale configuration
 */
function getLocaleConfig(config) {
    return config.locales[config.locale] || config.locales['en-US'];
}
/**
 * Check if a date is between two other dates (inclusive)
 *
 * @param date - Date to check
 * @param start - Start date
 * @param end - End date
 * @returns Whether the date is between start and end
 */
function isDateBetween(date, start, end) {
    var dateTime = date.getTime();
    return dateTime >= start.getTime() && dateTime <= end.getTime();
}
/**
 * Compare two dates for equality (ignoring time)
 *
 * @param date1 - First date
 * @param date2 - Second date
 * @returns Whether the dates are equal
 */
function isSameDay(date1, date2) {
    return (date1.getFullYear() === date2.getFullYear() &&
        date1.getMonth() === date2.getMonth() &&
        date1.getDate() === date2.getDate());
}
/**
 * Check if a date is a weekend (Saturday or Sunday)
 *
 * @param date - Date to check
 * @returns Whether the date is a weekend
 */
function isWeekend(date) {
    var day = date.getDay();
    return day === 0 || day === 6;
}
/**
 * Check if a date is disabled (outside min/max range or explicitly disabled)
 *
 * @param date - Date to check
 * @param config - Datepicker configuration
 * @returns Whether the date is disabled
 */
function isDateDisabled(date, config) {
    if (!date || !(date instanceof Date) || isNaN(date.getTime())) {
        return true;
    }
    // Set the time to noon for consistent comparison
    var normalizedDate = new Date(date);
    normalizedDate.setHours(12, 0, 0, 0);
    // Check min date
    if (config.minDate) {
        var minDate = null;
        if (config.minDate instanceof Date) {
            minDate = new Date(config.minDate);
            minDate.setHours(0, 0, 0, 0);
        }
        else {
            // Try parsing with the configured format
            minDate = parseDate(config.minDate.toString(), config.format, config);
            // If that fails, try parsing with other common formats
            if (!minDate) {
                // Try DD/MM/YYYY format
                var parts = config.minDate.toString().split('/');
                if (parts.length === 3) {
                    var day = parseInt(parts[0], 10);
                    var month = parseInt(parts[1], 10) - 1;
                    var year = parseInt(parts[2], 10);
                    if (!isNaN(day) && !isNaN(month) && !isNaN(year)) {
                        minDate = new Date(year, month, day);
                    }
                }
            }
        }
        if (minDate) {
            // Ensure minDate has time set to beginning of day for accurate comparison
            minDate.setHours(0, 0, 0, 0);
            if (normalizedDate < minDate) {
                return true;
            }
        }
    }
    // Check max date
    if (config.maxDate) {
        var maxDate = null;
        if (config.maxDate instanceof Date) {
            maxDate = new Date(config.maxDate);
            maxDate.setHours(23, 59, 59, 999);
        }
        else {
            // Try parsing with the configured format
            maxDate = parseDate(config.maxDate.toString(), config.format, config);
            // If that fails, try parsing with other common formats
            if (!maxDate) {
                // Try DD/MM/YYYY format
                var parts = config.maxDate.toString().split('/');
                if (parts.length === 3) {
                    var day = parseInt(parts[0], 10);
                    var month = parseInt(parts[1], 10) - 1;
                    var year = parseInt(parts[2], 10);
                    if (!isNaN(day) && !isNaN(month) && !isNaN(year)) {
                        maxDate = new Date(year, month, day);
                    }
                }
            }
        }
        if (maxDate) {
            // Ensure maxDate has time set to end of day for accurate comparison
            maxDate.setHours(23, 59, 59, 999);
            if (normalizedDate > maxDate) {
                return true;
            }
        }
    }
    // Check explicitly disabled dates
    if (config.disabledDates && config.disabledDates.length > 0) {
        for (var _i = 0, _a = config.disabledDates; _i < _a.length; _i++) {
            var disabledDate = _a[_i];
            var disabled = disabledDate instanceof Date
                ? disabledDate
                : parseDate(disabledDate.toString(), config.format, config);
            if (disabled && isSameDay(normalizedDate, disabled)) {
                return true;
            }
        }
    }
    return false;
}
/**
 * Generate a calender for the specified month
 *
 * @param year - Year
 * @param month - Month (0-indexed)
 * @param config - Datepicker configuration
 * @returns Calendar days matrix
 */
function generateCalendarMonth(year, month, config) {
    var daysInMonth = getDaysInMonth(year, month);
    var firstDayOfMonth = getFirstDayOfMonth(year, month);
    var locale = getLocaleConfig(config);
    var firstDayOfWeek = locale.firstDayOfWeek;
    // Calculate the offset from the first day of the month to the first day of the calendar
    var startOffset = (firstDayOfMonth - firstDayOfWeek + 7) % 7;
    // Create a 6x7 matrix for the calendar
    var calendar = [];
    var day = 1 - startOffset;
    for (var week = 0; week < 6; week++) {
        var weekDays = [];
        for (var i = 0; i < 7; i++) {
            var date = new Date(year, month, day);
            weekDays.push(date);
            day++;
        }
        calendar.push(weekDays);
        // If we've gone past the end of the month and it's a complete week, we can stop
        if (day > daysInMonth && week >= 4) {
            break;
        }
    }
    return calendar;
}
/**
 * Check if two dates are the same day
 * (ignoring time part)
 *
 * @param date1 - First date to compare
 * @param date2 - Second date to compare
 * @returns True if dates are the same day
 */
function isDateEqual(date1, date2) {
    return (date1.getDate() === date2.getDate() &&
        date1.getMonth() === date2.getMonth() &&
        date1.getFullYear() === date2.getFullYear());
}
/**
 * Check if a date is within a range (inclusive)
 *
 * @param date - Date to check
 * @param startDate - Start date of the range
 * @param endDate - End date of the range
 * @returns True if date is within the range
 */
function isDateInRange(date, startDate, endDate) {
    var time = date.getTime();
    var startTime = startDate.getTime();
    var endTime = endDate.getTime();
    return time >= startTime && time <= endTime;
}


/***/ }),

/***/ 2599:
/***/ (function(__unused_webpack_module, exports) {


/**
 * KTUI - Free & Open-Source Tailwind UI Components by Keenthemes
 * Copyright 2025 by Keenthemes Inc
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
var KTUtils = {
    geUID: function (prefix) {
        if (prefix === void 0) { prefix = ''; }
        return prefix + Math.floor(Math.random() * new Date().getTime());
    },
    getCssVar: function (variable) {
        var hex = getComputedStyle(document.documentElement).getPropertyValue(variable);
        if (hex && hex.length > 0) {
            hex = hex.trim();
        }
        return hex;
    },
    parseDataAttribute: function (value) {
        if (value === 'true') {
            return true;
        }
        if (value === 'false') {
            return false;
        }
        if (value === Number(value).toString()) {
            return Number(value);
        }
        if (value === '' || value === 'null') {
            return null;
        }
        if (typeof value !== 'string') {
            return value;
        }
        try {
            return KTUtils.parseJson(value);
        }
        catch (_a) {
            return value;
        }
    },
    parseJson: function (value) {
        return value && value.length > 0
            ? JSON.parse(decodeURIComponent(value))
            : null;
    },
    parseSelector: function (selector) {
        if (selector && window.CSS && window.CSS.escape) {
            // Escape any IDs in the selector using CSS.escape
            selector = selector.replace(/#([^\s"#']+)/g, function (match, id) { return "#".concat(window.CSS.escape(id)); });
        }
        return selector;
    },
    capitalize: function (value) {
        return value.charAt(0).toUpperCase() + value.slice(1);
    },
    uncapitalize: function (value) {
        return value.charAt(0).toLowerCase() + value.slice(1);
    },
    camelCase: function (value) {
        return value.replace(/-([a-z])/g, function (match, letter) {
            return letter.toUpperCase();
        });
    },
    camelReverseCase: function (str) {
        return str.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase();
    },
    isRTL: function () {
        var htmlElement = document.querySelector('html');
        return Boolean(htmlElement && htmlElement.getAttribute('direction') === 'rtl');
    },
    throttle: function (timer, func, delay) {
        // If setTimeout is already scheduled, no need to do anything
        if (timer) {
            return;
        }
        // Schedule a setTimeout after delay seconds
        timer = setTimeout(function () {
            func();
            // Once setTimeout function execution is finished, timerId = undefined so that in <br>
            // the next scroll event function execution can be scheduled by the setTimeout
            clearTimeout(timer);
        }, delay);
    },
    checksum: function (value) {
        var hash = 0;
        for (var i = 0; i < value.length; i++) {
            hash = ((hash << 5) - hash + value.charCodeAt(i)) | 0;
        }
        return ('0000000' + (hash >>> 0).toString(16)).slice(-8);
    },
    stringToBoolean: function (value) {
        if (typeof value === 'boolean')
            return value;
        if (typeof value !== 'string')
            return null;
        var cleanedStr = value.toLowerCase().trim();
        if (cleanedStr === 'true')
            return true;
        if (cleanedStr === 'false')
            return false;
        return null;
    },
    stringToObject: function (value) {
        try {
            var parsed = JSON.parse(value.toString());
            if (parsed && typeof parsed === 'object' && !Array.isArray(parsed)) {
                return parsed;
            }
            return null;
        }
        catch (error) {
            return null;
        }
    },
    stringToInteger: function (value) {
        // If already a number, return it as an integer
        if (typeof value === 'number' && !isNaN(value)) {
            return Math.floor(value);
        }
        // If not a string, return null
        if (typeof value !== 'string')
            return null;
        var cleanedStr = value.trim();
        var num = parseInt(cleanedStr, 10);
        if (!isNaN(num) && cleanedStr !== '') {
            return num;
        }
        return null;
    },
    stringToFloat: function (value) {
        // If already a number, return it as is
        if (typeof value === 'number' && !isNaN(value)) {
            return value;
        }
        // If not a string, return null
        if (typeof value !== 'string')
            return null;
        var cleanedStr = value.trim();
        var num = parseFloat(cleanedStr);
        if (!isNaN(num) && cleanedStr !== '') {
            return num;
        }
        return null;
    },
};
exports["default"] = KTUtils;


/***/ }),

/***/ 2626:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


/**
 * KTUI - Free & Open-Source Tailwind UI Components by Keenthemes
 * Copyright 2025 by Keenthemes Inc
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.KTDataTable = void 0;
var datatable_1 = __webpack_require__(6502);
Object.defineProperty(exports, "KTDataTable", ({ enumerable: true, get: function () { return datatable_1.KTDataTable; } }));


/***/ }),

/***/ 2658:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


/**
 * KTUI - Free & Open-Source Tailwind UI Components by Keenthemes
 * Copyright 2025 by Keenthemes Inc
 */
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var data_1 = __webpack_require__(8716);
var dom_1 = __webpack_require__(9010);
var utils_1 = __webpack_require__(2599);
var KTComponent = /** @class */ (function () {
    function KTComponent() {
        this._dataOptionPrefix = 'kt-';
        this._uid = null;
        this._element = null;
    }
    KTComponent.prototype._init = function (element) {
        element = dom_1.default.getElement(element);
        if (!element) {
            return;
        }
        this._element = element;
        this._events = new Map();
        this._uid = utils_1.default.geUID(this._name);
        this._element.setAttribute("data-kt-".concat(this._name, "-initialized"), 'true');
        data_1.default.set(this._element, this._name, this);
    };
    KTComponent.prototype._fireEvent = function (eventType, payload) {
        var _a;
        if (payload === void 0) { payload = null; }
        (_a = this._events.get(eventType)) === null || _a === void 0 ? void 0 : _a.forEach(function (callable) {
            callable(payload);
        });
    };
    KTComponent.prototype._dispatchEvent = function (eventType, payload) {
        if (payload === void 0) { payload = null; }
        var event = new CustomEvent(eventType, {
            detail: { payload: payload },
            bubbles: true,
            cancelable: true,
            composed: false,
        });
        if (!this._element)
            return;
        this._element.dispatchEvent(event);
    };
    KTComponent.prototype._getOption = function (name) {
        var value = this._config[name];
        var reponsiveValue = dom_1.default.getCssProp(this._element, "--kt-".concat(this._name, "-").concat(utils_1.default.camelReverseCase(name)));
        return reponsiveValue || value;
    };
    KTComponent.prototype._getGlobalConfig = function () {
        if (window.KTGlobalComponentsConfig &&
            window.KTGlobalComponentsConfig[this._name]) {
            return window.KTGlobalComponentsConfig[this._name];
        }
        else {
            return {};
        }
    };
    KTComponent.prototype._buildConfig = function (config) {
        if (config === void 0) { config = {}; }
        if (!this._element)
            return;
        this._config = __assign(__assign(__assign(__assign({}, this._defaultConfig), this._getGlobalConfig()), dom_1.default.getDataAttributes(this._element, this._dataOptionPrefix + this._name)), config);
    };
    KTComponent.prototype.dispose = function () {
        if (!this._element)
            return;
        this._element.removeAttribute("data-kt-".concat(this._name, "-initialized"));
        data_1.default.remove(this._element, this._name);
    };
    KTComponent.prototype.on = function (eventType, callback) {
        var eventId = utils_1.default.geUID();
        if (!this._events.get(eventType)) {
            this._events.set(eventType, new Map());
        }
        this._events.get(eventType).set(eventId, callback);
        return eventId;
    };
    KTComponent.prototype.off = function (eventType, eventId) {
        var _a;
        (_a = this._events.get(eventType)) === null || _a === void 0 ? void 0 : _a.delete(eventId);
    };
    KTComponent.prototype.getOption = function (name) {
        return this._getOption(name);
    };
    KTComponent.prototype.getElement = function () {
        if (!this._element)
            return null;
        return this._element;
    };
    return KTComponent;
}());
exports["default"] = KTComponent;


/***/ }),

/***/ 2800:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


/**
 * KTUI - Free & Open-Source Tailwind UI Components by Keenthemes
 * Copyright 2025 by Keenthemes Inc
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.KTAccordion = void 0;
var accordion_1 = __webpack_require__(5194);
Object.defineProperty(exports, "KTAccordion", ({ enumerable: true, get: function () { return accordion_1.KTAccordion; } }));


/***/ }),

/***/ 2922:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


/**
 * KTUI - Free & Open-Source Tailwind UI Components by Keenthemes
 * Copyright 2025 by Keenthemes Inc
 */
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.KTImageInput = void 0;
var data_1 = __webpack_require__(8716);
var event_handler_1 = __webpack_require__(5183);
var component_1 = __webpack_require__(2658);
var KTImageInput = /** @class */ (function (_super) {
    __extends(KTImageInput, _super);
    function KTImageInput(element, config) {
        if (config === void 0) { config = null; }
        var _this = _super.call(this) || this;
        _this._name = 'image-input';
        _this._defaultConfig = {
            hiddenClass: 'hidden',
        };
        _this._previewUrl = '';
        if (data_1.default.has(element, _this._name))
            return _this;
        _this._init(element);
        _this._buildConfig(config);
        _this._inputElement = _this._element.querySelector('input[type="file"]');
        _this._hiddenElement = _this._element.querySelector('input[type="hidden"]');
        _this._removeElement = _this._element.querySelector('[data-kt-image-input-remove]');
        _this._previewElement = _this._element.querySelector('[data-kt-image-input-preview]');
        _this._update();
        _this._handlers();
        return _this;
    }
    KTImageInput.prototype._handlers = function () {
        var _this = this;
        event_handler_1.default.on(this._element, '[data-kt-image-input-placeholder]', 'click', function (event) {
            event.preventDefault();
            _this._inputElement.click();
        });
        this._inputElement.addEventListener('change', function () {
            _this._change();
        });
        this._removeElement.addEventListener('click', function () {
            _this._remove();
        });
    };
    KTImageInput.prototype._change = function () {
        var _this = this;
        var payload = { cancel: false };
        this._fireEvent('change', payload);
        this._dispatchEvent('change', payload);
        if (payload.cancel === true) {
            return;
        }
        var reader = new FileReader();
        reader.onload = function () {
            _this._previewElement.style.backgroundImage = "url(".concat(reader.result, ")");
        };
        reader.readAsDataURL(this._inputElement.files[0]);
        this._inputElement.value = '';
        this._hiddenElement.value = '';
        this._lastMode = 'new';
        this._element.classList.add('changed');
        this._removeElement.classList.remove('hidden');
        this._element.classList.remove('empty');
        this._fireEvent('changed');
        this._dispatchEvent('changed');
    };
    KTImageInput.prototype._remove = function () {
        var payload = { cancel: false };
        this._fireEvent('remove', payload);
        this._dispatchEvent('remove', payload);
        if (payload.cancel === true) {
            return;
        }
        this._element.classList.remove('empty');
        this._element.classList.remove('changed');
        if (this._lastMode == 'new') {
            if (this._previewUrl == '')
                this._removeElement.classList.add(this._getOption('hiddenClass'));
            if (this._previewUrl) {
                this._previewElement.style.backgroundImage = "url(".concat(this._previewUrl, ")");
            }
            else {
                this._previewElement.style.backgroundImage = 'none';
                this._element.classList.add('empty');
            }
            this._inputElement.value = '';
            this._hiddenElement.value = '';
            this._lastMode = 'saved';
        }
        else if (this._lastMode == 'saved') {
            if (this._previewUrl == '')
                this._removeElement.classList.add(this._getOption('hiddenClass'));
            this._previewElement.style.backgroundImage = 'none';
            this._element.classList.add('empty');
            this._hiddenElement.value = '1';
            this._inputElement.value = '';
            this._lastMode = 'placeholder';
        }
        else if (this._lastMode == 'placeholder') {
            if (this._previewUrl == '')
                this._removeElement.classList.add(this._getOption('hiddenClass'));
            if (this._previewUrl) {
                this._previewElement.style.backgroundImage = "url(".concat(this._previewUrl, ")");
            }
            else {
                this._element.classList.add('empty');
            }
            this._inputElement.value = '';
            this._hiddenElement.value = '';
            this._lastMode = 'saved';
        }
        this._fireEvent('remove');
        this._dispatchEvent('remove');
    };
    KTImageInput.prototype._update = function () {
        if (this._previewElement.style.backgroundImage) {
            this._setPreviewUrl(this._previewElement.style.backgroundImage);
            this._removeElement.classList.remove(this._getOption('hiddenClass'));
            this._lastMode = 'saved';
        }
        else {
            this._removeElement.classList.add(this._getOption('hiddenClass'));
            this._element.classList.add('empty');
            this._lastMode = 'placeholder';
        }
    };
    KTImageInput.prototype._getPreviewUrl = function () {
        return this._previewUrl;
    };
    KTImageInput.prototype._setPreviewUrl = function (url) {
        this._previewUrl = url.replace(/(url\(|\)|")/g, '');
    };
    KTImageInput.prototype.isEmpty = function () {
        return this._inputElement.value.length === 0;
    };
    KTImageInput.prototype.isChanged = function () {
        return this._inputElement.value.length > 0;
    };
    KTImageInput.prototype.remove = function () {
        this._remove();
    };
    KTImageInput.prototype.update = function () {
        this._update();
    };
    KTImageInput.prototype.setPreviewUrl = function (url) {
        this._setPreviewUrl(url);
    };
    KTImageInput.prototype.getPreviewUrl = function () {
        return this._getPreviewUrl();
    };
    KTImageInput.getInstance = function (element) {
        if (!element)
            return null;
        if (data_1.default.has(element, 'image-input')) {
            return data_1.default.get(element, 'image-input');
        }
        if (element.getAttribute('data-kt-image-input')) {
            return new KTImageInput(element);
        }
        return null;
    };
    KTImageInput.getOrCreateInstance = function (element, config) {
        return this.getInstance(element) || new KTImageInput(element, config);
    };
    KTImageInput.createInstances = function () {
        var elements = document.querySelectorAll('[data-kt-image-input]');
        elements.forEach(function (element) {
            new KTImageInput(element);
        });
    };
    KTImageInput.init = function () {
        KTImageInput.createInstances();
    };
    return KTImageInput;
}(component_1.default));
exports.KTImageInput = KTImageInput;
if (typeof window !== 'undefined') {
    window.KTImageInput = KTImageInput;
}


/***/ }),

/***/ 3394:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


/**
 * KTUI - Free & Open-Source Tailwind UI Components by Keenthemes
 * Copyright 2025 by Keenthemes Inc
 */
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.KTSticky = void 0;
var data_1 = __webpack_require__(8716);
var dom_1 = __webpack_require__(9010);
var utils_1 = __webpack_require__(2599);
var component_1 = __webpack_require__(2658);
var KTSticky = /** @class */ (function (_super) {
    __extends(KTSticky, _super);
    function KTSticky(element, config) {
        if (config === void 0) { config = null; }
        var _this = _super.call(this) || this;
        _this._name = 'sticky';
        _this._defaultConfig = {
            target: 'body',
            name: '',
            class: '',
            top: '',
            start: '',
            end: '',
            width: '',
            zindex: '',
            offset: 0,
            reverse: false,
            release: '',
            activate: '',
        };
        _this._config = _this._defaultConfig;
        _this._targetElement = null;
        if (data_1.default.has(element, _this._name))
            return _this;
        _this._init(element);
        _this._buildConfig(config);
        _this._releaseElement = dom_1.default.getElement(_this._getOption('release'));
        _this._activateElement = dom_1.default.getElement(_this._getOption('activate'));
        _this._wrapperElement = _this._element.closest('[data-kt-sticky-wrapper]');
        _this._attributeRoot = "data-kt-sticky-".concat(_this._getOption('name'));
        _this._eventTriggerState = true;
        _this._lastScrollTop = 0;
        var targetElement = _this._getTarget() === 'body'
            ? document
            : dom_1.default.getElement(_this._getTarget());
        if (!targetElement)
            return _this;
        _this._targetElement = targetElement;
        _this._handlers();
        _this._process();
        _this._update();
        return _this;
    }
    KTSticky.prototype._getTarget = function () {
        return (this._element.getAttribute('data-kt-sticky-target') ||
            this._getOption('target'));
    };
    KTSticky.prototype._handlers = function () {
        var _this = this;
        window.addEventListener('resize', function () {
            var timer;
            utils_1.default.throttle(timer, function () {
                _this._update();
            }, 200);
        });
        this._targetElement.addEventListener('scroll', function () {
            _this._process();
        });
    };
    KTSticky.prototype._process = function () {
        var reverse = this._getOption('reverse');
        var offset = this._getOffset();
        if (offset < 0) {
            this._disable();
            return;
        }
        var st = this._getTarget() === 'body'
            ? dom_1.default.getScrollTop()
            : this._targetElement.scrollTop;
        var release = this._releaseElement && dom_1.default.isPartiallyInViewport(this._releaseElement);
        // Release on reverse scroll mode
        if (reverse === true) {
            // Forward scroll mode
            if (st > offset && !release) {
                if (document.body.hasAttribute(this._attributeRoot) === false) {
                    if (this._enable() === false) {
                        return;
                    }
                    document.body.setAttribute(this._attributeRoot, 'on');
                }
                if (this._eventTriggerState === true) {
                    var payload = { active: true };
                    this._fireEvent('change', payload);
                    this._dispatchEvent('change', payload);
                    this._eventTriggerState = false;
                }
                // Back scroll mode
            }
            else {
                if (document.body.hasAttribute(this._attributeRoot) === true) {
                    this._disable();
                    if (release) {
                        this._element.classList.add('release');
                    }
                    document.body.removeAttribute(this._attributeRoot);
                }
                if (this._eventTriggerState === false) {
                    var payload = { active: false };
                    this._fireEvent('change', payload);
                    this._dispatchEvent('change', payload);
                    this._eventTriggerState = true;
                }
            }
            this._lastScrollTop = st;
            // Classic scroll mode
        }
        else {
            // Forward scroll mode
            if (st > offset && !release) {
                if (document.body.hasAttribute(this._attributeRoot) === false) {
                    if (this._enable() === false) {
                        return;
                    }
                    document.body.setAttribute(this._attributeRoot, 'on');
                }
                if (this._eventTriggerState === true) {
                    var payload = { active: true };
                    this._fireEvent('change', payload);
                    this._dispatchEvent('change', payload);
                    this._eventTriggerState = false;
                }
                // Back scroll mode
            }
            else {
                // back scroll mode
                if (document.body.hasAttribute(this._attributeRoot) === true) {
                    this._disable();
                    if (release) {
                        this._element.classList.add('release');
                    }
                    document.body.removeAttribute(this._attributeRoot);
                }
                if (this._eventTriggerState === false) {
                    var payload = { active: false };
                    this._fireEvent('change', payload);
                    this._dispatchEvent('change', payload);
                    this._eventTriggerState = true;
                }
            }
        }
    };
    KTSticky.prototype._getOffset = function () {
        var offset = parseInt(this._getOption('offset'));
        var activateElement = dom_1.default.getElement(this._getOption('activate'));
        if (activateElement) {
            offset = Math.abs(offset - activateElement.offsetTop);
        }
        return offset;
    };
    KTSticky.prototype._enable = function () {
        if (!this._element)
            return false;
        var width = this._getOption('width');
        var top = this._getOption('top');
        var start = this._getOption('start');
        var end = this._getOption('end');
        var height = this._calculateHeight();
        var zindex = this._getOption('zindex');
        var classList = this._getOption('class');
        if (height + parseInt(top) > dom_1.default.getViewPort().height) {
            return false;
        }
        if (width) {
            var targetElement = document.querySelector(width);
            if (targetElement) {
                width = dom_1.default.getCssProp(targetElement, 'width');
            }
            else if (width == 'auto') {
                width = dom_1.default.getCssProp(this._element, 'width');
            }
            this._element.style.width = "".concat(Math.round(parseFloat(width)), "px");
        }
        if (top) {
            this._element.style.top = "".concat(top, "px");
        }
        if (start) {
            if (start === 'auto') {
                var offsetLeft = dom_1.default.offset(this._element).left;
                if (offsetLeft >= 0) {
                    this._element.style.insetInlineStart = "".concat(offsetLeft, "px");
                }
            }
            else {
                this._element.style.insetInlineStart = "".concat(start, "px");
            }
        }
        if (end) {
            if (end === 'auto') {
                var offseRight = dom_1.default.offset(this._element).right;
                if (offseRight >= 0) {
                    this._element.style.insetInlineEnd = "".concat(offseRight, "px");
                }
            }
            else {
                this._element.style.insetInlineEnd = "".concat(end, "px");
            }
        }
        if (zindex) {
            this._element.style.zIndex = zindex;
            this._element.style.position = 'fixed';
        }
        if (classList) {
            dom_1.default.addClass(this._element, classList);
        }
        if (this._wrapperElement) {
            this._wrapperElement.style.height = "".concat(height, "px");
        }
        this._element.classList.add('active');
        this._element.classList.remove('release');
        return true;
    };
    KTSticky.prototype._disable = function () {
        if (!this._element)
            return;
        this._element.style.top = '';
        this._element.style.width = '';
        this._element.style.left = '';
        this._element.style.right = '';
        this._element.style.zIndex = '';
        this._element.style.position = '';
        var classList = this._getOption('class');
        if (this._wrapperElement) {
            this._wrapperElement.style.height = '';
        }
        if (classList) {
            dom_1.default.removeClass(this._element, classList);
        }
        this._element.classList.remove('active');
    };
    KTSticky.prototype._update = function () {
        if (this._isActive()) {
            this._disable();
            this._enable();
        }
        else {
            this._disable();
        }
    };
    KTSticky.prototype._calculateHeight = function () {
        if (!this._element)
            return 0;
        var height = parseFloat(dom_1.default.getCssProp(this._element, 'height'));
        height += parseFloat(dom_1.default.getCssProp(this._element, 'margin-top'));
        height += parseFloat(dom_1.default.getCssProp(this._element, 'margin-bottom'));
        if (dom_1.default.getCssProp(this._element, 'border-top')) {
            height =
                height + parseFloat(dom_1.default.getCssProp(this._element, 'border-top'));
        }
        if (dom_1.default.getCssProp(this._element, 'border-bottom')) {
            height =
                height + parseFloat(dom_1.default.getCssProp(this._element, 'border-bottom'));
        }
        return height;
    };
    KTSticky.prototype._isActive = function () {
        return this._element.classList.contains('active');
    };
    KTSticky.prototype.update = function () {
        this._update();
    };
    KTSticky.prototype.isActive = function () {
        return this._isActive();
    };
    KTSticky.getInstance = function (element) {
        if (!element)
            return null;
        if (data_1.default.has(element, 'sticky')) {
            return data_1.default.get(element, 'sticky');
        }
        if (element.getAttribute('data-kt-sticky')) {
            return new KTSticky(element);
        }
        return null;
    };
    KTSticky.getOrCreateInstance = function (element, config) {
        return this.getInstance(element) || new KTSticky(element, config);
    };
    KTSticky.createInstances = function () {
        var elements = document.querySelectorAll('[data-kt-sticky]');
        elements.forEach(function (element) {
            new KTSticky(element);
        });
    };
    KTSticky.init = function () {
        KTSticky.createInstances();
    };
    return KTSticky;
}(component_1.default));
exports.KTSticky = KTSticky;
if (typeof window !== 'undefined') {
    window.KTSticky = KTSticky;
}


/***/ }),

/***/ 3395:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


/**
 * KTUI - Free & Open-Source Tailwind UI Components by Keenthemes
 * Copyright 2025 by Keenthemes Inc
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.KTModal = void 0;
var modal_1 = __webpack_require__(6990);
Object.defineProperty(exports, "KTModal", ({ enumerable: true, get: function () { return modal_1.KTModal; } }));


/***/ }),

/***/ 3710:
/***/ (function(__unused_webpack_module, exports) {


/**
 * KTUI - Free & Open-Source Tailwind UI Components by Keenthemes
 * Copyright 2025 by Keenthemes Inc
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.KTSelectRemote = void 0;
/**
 * KTSelectRemote class
 * Handles fetching remote data for the KTSelect component
 */
var KTSelectRemote = /** @class */ (function () {
    /**
     * Constructor
     * @param config KTSelect configuration
     * @param element The select element
     */
    function KTSelectRemote(config, element) {
        this._isLoading = false;
        this._hasError = false;
        this._errorMessage = '';
        this._currentPage = 1;
        this._totalPages = 1;
        this._lastQuery = '';
        this._element = null;
        this._config = config;
        this._element = element || null;
    }
    /**
     * Fetch data from remote URL
     * @param query Optional search query
     * @param page Page number for pagination
     * @returns Promise with fetched items
     */
    KTSelectRemote.prototype.fetchData = function (query, page) {
        var _this = this;
        if (page === void 0) { page = 1; }
        this._isLoading = true;
        this._hasError = false;
        this._errorMessage = '';
        this._lastQuery = query || '';
        this._currentPage = page;
        var url = this._buildUrl(query, page);
        if (this._config.debug)
            console.log('Fetching remote data from:', url);
        // Dispatch search start event
        this._dispatchEvent('remoteSearchStart');
        return fetch(url)
            .then(function (response) {
            if (!response.ok) {
                throw new Error("HTTP error! Status: ".concat(response.status));
            }
            return response.json();
        })
            .then(function (data) {
            // Process the data
            return _this._processData(data);
        })
            .catch(function (error) {
            console.error('Error fetching remote data:', error);
            _this._hasError = true;
            _this._errorMessage =
                _this._config.remoteErrorMessage || 'Failed to load data';
            return [];
        })
            .finally(function () {
            _this._isLoading = false;
            // Dispatch search end event
            _this._dispatchEvent('remoteSearchEnd');
        });
    };
    /**
     * Dispatch custom events to notify about search state changes
     * @param eventName Name of the event to dispatch
     */
    KTSelectRemote.prototype._dispatchEvent = function (eventName) {
        if (!this._element)
            return;
        var event = new CustomEvent("ktselect.".concat(eventName), {
            bubbles: true,
            detail: {
                query: this._lastQuery,
                isLoading: this._isLoading,
                hasError: this._hasError,
                errorMessage: this._errorMessage,
            },
        });
        this._element.dispatchEvent(event);
    };
    /**
     * Build the URL for the API request
     * @param query Search query
     * @param page Page number
     * @returns Fully formed URL
     */
    KTSelectRemote.prototype._buildUrl = function (query, page) {
        if (page === void 0) { page = 1; }
        var url = this._config.dataUrl;
        if (!url) {
            console.error('No URL specified for remote data');
            return '';
        }
        // Add parameters
        var params = new URLSearchParams();
        // Add search parameter if provided
        if (query && this._config.searchParam) {
            params.append(this._config.searchParam, query);
        }
        // Add pagination parameters if enabled
        if (this._config.pagination) {
            var limitParam = this._config.paginationLimitParam || 'limit';
            var pageParam = this._config.paginationPageParam || 'page';
            var limit = this._config.paginationLimit || 10;
            params.append(limitParam, limit.toString());
            params.append(pageParam, page.toString());
        }
        // Append parameters to URL if there are any
        var paramsString = params.toString();
        if (paramsString) {
            url += (url.includes('?') ? '&' : '?') + paramsString;
        }
        return url;
    };
    /**
     * Process the API response data
     * @param data API response data
     * @returns Array of KTSelectOptionData
     */
    KTSelectRemote.prototype._processData = function (data) {
        var _this = this;
        try {
            if (this._config.debug)
                console.log('Processing API response:', data);
            var processedData = data;
            // Extract data from the API property if specified
            if (this._config.apiDataProperty && data[this._config.apiDataProperty]) {
                if (this._config.debug)
                    console.log("Extracting data from property: ".concat(this._config.apiDataProperty));
                // If pagination metadata is available, extract it
                if (this._config.pagination) {
                    if (data.total_pages) {
                        this._totalPages = data.total_pages;
                        if (this._config.debug)
                            console.log("Total pages found: ".concat(this._totalPages));
                    }
                    if (data.total) {
                        this._totalPages = Math.ceil(data.total / (this._config.paginationLimit || 10));
                        if (this._config.debug)
                            console.log("Calculated total pages: ".concat(this._totalPages, " from total: ").concat(data.total));
                    }
                }
                processedData = data[this._config.apiDataProperty];
            }
            // Ensure data is an array
            if (!Array.isArray(processedData)) {
                console.warn('Remote data is not an array:', processedData);
                return [];
            }
            if (this._config.debug)
                console.log("Mapping ".concat(processedData.length, " items to KTSelectOptionData format"));
            // Map data to KTSelectOptionData format
            var mappedData = processedData.map(function (item) {
                var mappedItem = _this._mapItemToOption(item);
                // Add logging to trace data path extraction
                if (_this._config.dataValueField &&
                    _this._config.dataValueField.includes('.')) {
                    // For nested paths, verify extraction worked
                    var parts = _this._config.dataValueField.split('.');
                    var nestedValue = item;
                    // Try to navigate to the value manually for verification
                    for (var _i = 0, parts_1 = parts; _i < parts_1.length; _i++) {
                        var part = parts_1[_i];
                        if (nestedValue &&
                            typeof nestedValue === 'object' &&
                            part in nestedValue) {
                            nestedValue = nestedValue[part];
                        }
                        else {
                            nestedValue = null;
                            break;
                        }
                    }
                    // If we found a value, verify it matches what was extracted
                    if (nestedValue !== null && nestedValue !== undefined) {
                        var expectedValue = String(nestedValue);
                        if (_this._config.debug)
                            console.log("Data path verification for [".concat(_this._config.dataValueField, "]: Expected: ").concat(expectedValue, ", Got: ").concat(mappedItem.id));
                        if (mappedItem.id !== expectedValue && expectedValue) {
                            console.warn("Value mismatch! Path: ".concat(_this._config.dataValueField, ", Expected: ").concat(expectedValue, ", Got: ").concat(mappedItem.id));
                        }
                    }
                }
                if (_this._config.debug)
                    console.log("Mapped item: ".concat(JSON.stringify(mappedItem)));
                return mappedItem;
            });
            if (this._config.debug)
                console.log("Returned ".concat(mappedData.length, " mapped items"));
            return mappedData;
        }
        catch (error) {
            console.error('Error processing remote data:', error);
            this._hasError = true;
            this._errorMessage = 'Error processing data';
            return [];
        }
    };
    /**
     * Map a data item to KTSelectOptionData format
     * @param item Data item from API
     * @returns KTSelectOptionData object
     */
    KTSelectRemote.prototype._mapItemToOption = function (item) {
        var _this = this;
        // Get the field mapping from config with fallbacks for common field names
        var valueField = this._config.dataValueField || 'id';
        var labelField = this._config.dataFieldText || 'title';
        if (this._config.debug)
            console.log("Mapping fields: value=".concat(valueField, ", label=").concat(labelField));
        if (this._config.debug)
            console.log('Item data:', JSON.stringify(item).substring(0, 200) + '...'); // Trimmed for readability
        // Extract values using dot notation if needed
        var getValue = function (obj, path) {
            if (!path)
                return null;
            if (!obj)
                return null;
            try {
                // Handle dot notation to access nested properties
                var parts = path.split('.');
                var result_1 = obj;
                for (var _i = 0, parts_2 = parts; _i < parts_2.length; _i++) {
                    var part = parts_2[_i];
                    if (result_1 === null ||
                        result_1 === undefined ||
                        typeof result_1 !== 'object') {
                        return null;
                    }
                    result_1 = result_1[part];
                }
                // Log the extraction result
                if (_this._config.debug)
                    console.log("Extracted [".concat(path, "] => ").concat(result_1 !== null && result_1 !== undefined
                        ? typeof result_1 === 'object'
                            ? JSON.stringify(result_1).substring(0, 50)
                            : String(result_1).substring(0, 50)
                        : 'null'));
                return result_1;
            }
            catch (error) {
                console.error("Error extracting path ".concat(path, ":"), error);
                return null;
            }
        };
        // Try to get a usable ID, with fallbacks
        var id = getValue(item, valueField);
        // Ensure id is always a proper string
        if (id === null || id === undefined) {
            // If no ID found, check for id.value or item.id as fallbacks
            if (item.id &&
                typeof item.id === 'object' &&
                'value' in item.id &&
                item.id.value) {
                id = String(item.id.value);
                if (this._config.debug)
                    console.log("Using id.value as fallback: ".concat(id));
            }
            else if (item.id) {
                id = String(item.id);
                if (this._config.debug)
                    console.log("Using direct item.id as fallback: ".concat(id));
            }
            else {
                // If no ID found at all, use the title instead (will be extracted below)
                if (this._config.debug)
                    console.log("No ID found, will use title as fallback");
                id = null;
            }
        }
        else if (typeof id === 'object') {
            // If ID is an object, log the issue and set to null to use title fallback
            console.warn("ID for path ".concat(valueField, " is an object, will use title fallback instead"));
            id = null;
        }
        else {
            // Otherwise, ensure it's a string
            id = String(id);
            if (this._config.debug)
                console.log("Final ID value: ".concat(id));
        }
        // Try to get a usable title, with fallbacks
        var title = getValue(item, labelField);
        title = title !== null ? String(title) : '';
        if (this._config.debug)
            console.log("Title/label field [".concat(labelField, "]:"), title);
        // If title is still empty, try common field names
        if (!title) {
            // Try common field names if the configured one doesn't work
            if (item.name)
                title = String(item.name);
            else if (item.title)
                title = String(item.title);
            else if (item.label)
                title = String(item.label);
            else if (item.text)
                title = String(item.text);
            if (this._config.debug)
                console.log('After fallback checks, title:', title);
        }
        // Create the option object with non-empty values
        var result = {
            id: id || title || 'id-' + Math.random().toString(36).substr(2, 9), // Ensure we always have an ID
            title: title || 'Unnamed option',
        };
        if (this._config.debug)
            console.log('Final mapped item:', JSON.stringify(result));
        return result;
    };
    /**
     * Load the next page of results
     * @returns Promise with fetched items
     */
    KTSelectRemote.prototype.loadNextPage = function () {
        if (this._currentPage < this._totalPages) {
            return this.fetchData(this._lastQuery, this._currentPage + 1);
        }
        return Promise.resolve([]);
    };
    /**
     * Check if there are more pages available
     * @returns Boolean indicating if more pages exist
     */
    KTSelectRemote.prototype.hasMorePages = function () {
        return this._currentPage < this._totalPages;
    };
    /**
     * Get loading state
     * @returns Boolean indicating if data is loading
     */
    KTSelectRemote.prototype.isLoading = function () {
        return this._isLoading;
    };
    /**
     * Get error state
     * @returns Boolean indicating if there was an error
     */
    KTSelectRemote.prototype.hasError = function () {
        return this._hasError;
    };
    /**
     * Get error message
     * @returns Error message
     */
    KTSelectRemote.prototype.getErrorMessage = function () {
        return this._errorMessage;
    };
    /**
     * Reset the remote data state
     */
    KTSelectRemote.prototype.reset = function () {
        this._isLoading = false;
        this._hasError = false;
        this._errorMessage = '';
        this._currentPage = 1;
        this._totalPages = 1;
        this._lastQuery = '';
    };
    /**
     * Set the select element for event dispatching
     * @param element The select element
     */
    KTSelectRemote.prototype.setElement = function (element) {
        this._element = element;
    };
    return KTSelectRemote;
}());
exports.KTSelectRemote = KTSelectRemote;


/***/ }),

/***/ 3840:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


/**
 * KTUI - Free & Open-Source Tailwind UI Components by Keenthemes
 * Copyright 2025 by Keenthemes Inc
 */
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.KTScrollto = void 0;
/* eslint-disable max-len */
/* eslint-disable require-jsdoc */
var data_1 = __webpack_require__(8716);
var dom_1 = __webpack_require__(9010);
var component_1 = __webpack_require__(2658);
var KTScrollto = /** @class */ (function (_super) {
    __extends(KTScrollto, _super);
    function KTScrollto(element, config) {
        var _this = _super.call(this) || this;
        _this._name = 'scrollto';
        _this._defaultConfig = {
            smooth: true,
            parent: 'body',
            target: '',
            offset: 0,
        };
        _this._config = _this._defaultConfig;
        if (data_1.default.has(element, _this._name))
            return _this;
        _this._init(element);
        _this._buildConfig(config);
        if (!_this._element)
            return _this;
        _this._targetElement = _this._getTargetElement();
        if (!_this._targetElement) {
            return _this;
        }
        _this._handlers();
        return _this;
    }
    KTScrollto.prototype._getTargetElement = function () {
        return (dom_1.default.getElement(this._element.getAttribute('data-kt-scrollto')) || dom_1.default.getElement(this._getOption('target')));
    };
    KTScrollto.prototype._handlers = function () {
        var _this = this;
        if (!this._element)
            return;
        this._element.addEventListener('click', function (event) {
            event.preventDefault();
            _this._scroll();
        });
    };
    KTScrollto.prototype._scroll = function () {
        var pos = this._targetElement.offsetTop +
            parseInt(this._getOption('offset'));
        var parent = dom_1.default.getElement(this._getOption('parent'));
        if (!parent || parent === document.body) {
            parent = window;
        }
        parent.scrollTo({
            top: pos,
            behavior: this._getOption('smooth') ? 'smooth' : 'instant',
        });
    };
    KTScrollto.prototype.scroll = function () {
        this._scroll();
    };
    KTScrollto.getInstance = function (element) {
        if (!element)
            return null;
        if (data_1.default.has(element, 'scrollto')) {
            return data_1.default.get(element, 'scrollto');
        }
        if (element.getAttribute('data-kt-scrollto')) {
            return new KTScrollto(element);
        }
        return null;
    };
    KTScrollto.getOrCreateInstance = function (element, config) {
        return this.getInstance(element) || new KTScrollto(element, config);
    };
    KTScrollto.createInstances = function () {
        var elements = document.querySelectorAll('[data-kt-scrollto]');
        elements.forEach(function (element) {
            new KTScrollto(element);
        });
    };
    KTScrollto.init = function () {
        KTScrollto.createInstances();
    };
    return KTScrollto;
}(component_1.default));
exports.KTScrollto = KTScrollto;
if (typeof window !== 'undefined') {
    window.KTScrollto = KTScrollto;
}


/***/ }),

/***/ 3915:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  afterMain: function() { return /* reexport */ afterMain; },
  afterRead: function() { return /* reexport */ afterRead; },
  afterWrite: function() { return /* reexport */ afterWrite; },
  applyStyles: function() { return /* reexport */ modifiers_applyStyles; },
  arrow: function() { return /* reexport */ modifiers_arrow; },
  auto: function() { return /* reexport */ auto; },
  basePlacements: function() { return /* reexport */ basePlacements; },
  beforeMain: function() { return /* reexport */ beforeMain; },
  beforeRead: function() { return /* reexport */ beforeRead; },
  beforeWrite: function() { return /* reexport */ beforeWrite; },
  bottom: function() { return /* reexport */ bottom; },
  clippingParents: function() { return /* reexport */ clippingParents; },
  computeStyles: function() { return /* reexport */ modifiers_computeStyles; },
  createPopper: function() { return /* reexport */ popper_createPopper; },
  createPopperBase: function() { return /* reexport */ createPopper; },
  createPopperLite: function() { return /* reexport */ popper_lite_createPopper; },
  detectOverflow: function() { return /* reexport */ detectOverflow; },
  end: function() { return /* reexport */ end; },
  eventListeners: function() { return /* reexport */ eventListeners; },
  flip: function() { return /* reexport */ modifiers_flip; },
  hide: function() { return /* reexport */ modifiers_hide; },
  left: function() { return /* reexport */ left; },
  main: function() { return /* reexport */ main; },
  modifierPhases: function() { return /* reexport */ modifierPhases; },
  offset: function() { return /* reexport */ modifiers_offset; },
  placements: function() { return /* reexport */ enums_placements; },
  popper: function() { return /* reexport */ popper; },
  popperGenerator: function() { return /* reexport */ popperGenerator; },
  popperOffsets: function() { return /* reexport */ modifiers_popperOffsets; },
  preventOverflow: function() { return /* reexport */ modifiers_preventOverflow; },
  read: function() { return /* reexport */ read; },
  reference: function() { return /* reexport */ reference; },
  right: function() { return /* reexport */ right; },
  start: function() { return /* reexport */ start; },
  top: function() { return /* reexport */ enums_top; },
  variationPlacements: function() { return /* reexport */ variationPlacements; },
  viewport: function() { return /* reexport */ viewport; },
  write: function() { return /* reexport */ write; }
});

;// ./node_modules/@popperjs/core/lib/enums.js
var enums_top = 'top';
var bottom = 'bottom';
var right = 'right';
var left = 'left';
var auto = 'auto';
var basePlacements = [enums_top, bottom, right, left];
var start = 'start';
var end = 'end';
var clippingParents = 'clippingParents';
var viewport = 'viewport';
var popper = 'popper';
var reference = 'reference';
var variationPlacements = /*#__PURE__*/basePlacements.reduce(function (acc, placement) {
  return acc.concat([placement + "-" + start, placement + "-" + end]);
}, []);
var enums_placements = /*#__PURE__*/[].concat(basePlacements, [auto]).reduce(function (acc, placement) {
  return acc.concat([placement, placement + "-" + start, placement + "-" + end]);
}, []); // modifiers that need to read the DOM

var beforeRead = 'beforeRead';
var read = 'read';
var afterRead = 'afterRead'; // pure-logic modifiers

var beforeMain = 'beforeMain';
var main = 'main';
var afterMain = 'afterMain'; // modifier with the purpose to write to the DOM (or write into a framework state)

var beforeWrite = 'beforeWrite';
var write = 'write';
var afterWrite = 'afterWrite';
var modifierPhases = [beforeRead, read, afterRead, beforeMain, main, afterMain, beforeWrite, write, afterWrite];
;// ./node_modules/@popperjs/core/lib/dom-utils/getNodeName.js
function getNodeName(element) {
  return element ? (element.nodeName || '').toLowerCase() : null;
}
;// ./node_modules/@popperjs/core/lib/dom-utils/getWindow.js
function getWindow(node) {
  if (node == null) {
    return window;
  }

  if (node.toString() !== '[object Window]') {
    var ownerDocument = node.ownerDocument;
    return ownerDocument ? ownerDocument.defaultView || window : window;
  }

  return node;
}
;// ./node_modules/@popperjs/core/lib/dom-utils/instanceOf.js


function isElement(node) {
  var OwnElement = getWindow(node).Element;
  return node instanceof OwnElement || node instanceof Element;
}

function isHTMLElement(node) {
  var OwnElement = getWindow(node).HTMLElement;
  return node instanceof OwnElement || node instanceof HTMLElement;
}

function isShadowRoot(node) {
  // IE 11 has no ShadowRoot
  if (typeof ShadowRoot === 'undefined') {
    return false;
  }

  var OwnElement = getWindow(node).ShadowRoot;
  return node instanceof OwnElement || node instanceof ShadowRoot;
}


;// ./node_modules/@popperjs/core/lib/modifiers/applyStyles.js

 // This modifier takes the styles prepared by the `computeStyles` modifier
// and applies them to the HTMLElements such as popper and arrow

function applyStyles(_ref) {
  var state = _ref.state;
  Object.keys(state.elements).forEach(function (name) {
    var style = state.styles[name] || {};
    var attributes = state.attributes[name] || {};
    var element = state.elements[name]; // arrow is optional + virtual elements

    if (!isHTMLElement(element) || !getNodeName(element)) {
      return;
    } // Flow doesn't support to extend this property, but it's the most
    // effective way to apply styles to an HTMLElement
    // $FlowFixMe[cannot-write]


    Object.assign(element.style, style);
    Object.keys(attributes).forEach(function (name) {
      var value = attributes[name];

      if (value === false) {
        element.removeAttribute(name);
      } else {
        element.setAttribute(name, value === true ? '' : value);
      }
    });
  });
}

function effect(_ref2) {
  var state = _ref2.state;
  var initialStyles = {
    popper: {
      position: state.options.strategy,
      left: '0',
      top: '0',
      margin: '0'
    },
    arrow: {
      position: 'absolute'
    },
    reference: {}
  };
  Object.assign(state.elements.popper.style, initialStyles.popper);
  state.styles = initialStyles;

  if (state.elements.arrow) {
    Object.assign(state.elements.arrow.style, initialStyles.arrow);
  }

  return function () {
    Object.keys(state.elements).forEach(function (name) {
      var element = state.elements[name];
      var attributes = state.attributes[name] || {};
      var styleProperties = Object.keys(state.styles.hasOwnProperty(name) ? state.styles[name] : initialStyles[name]); // Set all values to an empty string to unset them

      var style = styleProperties.reduce(function (style, property) {
        style[property] = '';
        return style;
      }, {}); // arrow is optional + virtual elements

      if (!isHTMLElement(element) || !getNodeName(element)) {
        return;
      }

      Object.assign(element.style, style);
      Object.keys(attributes).forEach(function (attribute) {
        element.removeAttribute(attribute);
      });
    });
  };
} // eslint-disable-next-line import/no-unused-modules


/* harmony default export */ var modifiers_applyStyles = ({
  name: 'applyStyles',
  enabled: true,
  phase: 'write',
  fn: applyStyles,
  effect: effect,
  requires: ['computeStyles']
});
;// ./node_modules/@popperjs/core/lib/utils/getBasePlacement.js

function getBasePlacement(placement) {
  return placement.split('-')[0];
}
;// ./node_modules/@popperjs/core/lib/utils/math.js
var math_max = Math.max;
var math_min = Math.min;
var round = Math.round;
;// ./node_modules/@popperjs/core/lib/utils/userAgent.js
function getUAString() {
  var uaData = navigator.userAgentData;

  if (uaData != null && uaData.brands && Array.isArray(uaData.brands)) {
    return uaData.brands.map(function (item) {
      return item.brand + "/" + item.version;
    }).join(' ');
  }

  return navigator.userAgent;
}
;// ./node_modules/@popperjs/core/lib/dom-utils/isLayoutViewport.js

function isLayoutViewport() {
  return !/^((?!chrome|android).)*safari/i.test(getUAString());
}
;// ./node_modules/@popperjs/core/lib/dom-utils/getBoundingClientRect.js




function getBoundingClientRect(element, includeScale, isFixedStrategy) {
  if (includeScale === void 0) {
    includeScale = false;
  }

  if (isFixedStrategy === void 0) {
    isFixedStrategy = false;
  }

  var clientRect = element.getBoundingClientRect();
  var scaleX = 1;
  var scaleY = 1;

  if (includeScale && isHTMLElement(element)) {
    scaleX = element.offsetWidth > 0 ? round(clientRect.width) / element.offsetWidth || 1 : 1;
    scaleY = element.offsetHeight > 0 ? round(clientRect.height) / element.offsetHeight || 1 : 1;
  }

  var _ref = isElement(element) ? getWindow(element) : window,
      visualViewport = _ref.visualViewport;

  var addVisualOffsets = !isLayoutViewport() && isFixedStrategy;
  var x = (clientRect.left + (addVisualOffsets && visualViewport ? visualViewport.offsetLeft : 0)) / scaleX;
  var y = (clientRect.top + (addVisualOffsets && visualViewport ? visualViewport.offsetTop : 0)) / scaleY;
  var width = clientRect.width / scaleX;
  var height = clientRect.height / scaleY;
  return {
    width: width,
    height: height,
    top: y,
    right: x + width,
    bottom: y + height,
    left: x,
    x: x,
    y: y
  };
}
;// ./node_modules/@popperjs/core/lib/dom-utils/getLayoutRect.js
 // Returns the layout rect of an element relative to its offsetParent. Layout
// means it doesn't take into account transforms.

function getLayoutRect(element) {
  var clientRect = getBoundingClientRect(element); // Use the clientRect sizes if it's not been transformed.
  // Fixes https://github.com/popperjs/popper-core/issues/1223

  var width = element.offsetWidth;
  var height = element.offsetHeight;

  if (Math.abs(clientRect.width - width) <= 1) {
    width = clientRect.width;
  }

  if (Math.abs(clientRect.height - height) <= 1) {
    height = clientRect.height;
  }

  return {
    x: element.offsetLeft,
    y: element.offsetTop,
    width: width,
    height: height
  };
}
;// ./node_modules/@popperjs/core/lib/dom-utils/contains.js

function contains(parent, child) {
  var rootNode = child.getRootNode && child.getRootNode(); // First, attempt with faster native method

  if (parent.contains(child)) {
    return true;
  } // then fallback to custom implementation with Shadow DOM support
  else if (rootNode && isShadowRoot(rootNode)) {
      var next = child;

      do {
        if (next && parent.isSameNode(next)) {
          return true;
        } // $FlowFixMe[prop-missing]: need a better way to handle this...


        next = next.parentNode || next.host;
      } while (next);
    } // Give up, the result is false


  return false;
}
;// ./node_modules/@popperjs/core/lib/dom-utils/getComputedStyle.js

function getComputedStyle(element) {
  return getWindow(element).getComputedStyle(element);
}
;// ./node_modules/@popperjs/core/lib/dom-utils/isTableElement.js

function isTableElement(element) {
  return ['table', 'td', 'th'].indexOf(getNodeName(element)) >= 0;
}
;// ./node_modules/@popperjs/core/lib/dom-utils/getDocumentElement.js

function getDocumentElement(element) {
  // $FlowFixMe[incompatible-return]: assume body is always available
  return ((isElement(element) ? element.ownerDocument : // $FlowFixMe[prop-missing]
  element.document) || window.document).documentElement;
}
;// ./node_modules/@popperjs/core/lib/dom-utils/getParentNode.js



function getParentNode(element) {
  if (getNodeName(element) === 'html') {
    return element;
  }

  return (// this is a quicker (but less type safe) way to save quite some bytes from the bundle
    // $FlowFixMe[incompatible-return]
    // $FlowFixMe[prop-missing]
    element.assignedSlot || // step into the shadow DOM of the parent of a slotted node
    element.parentNode || ( // DOM Element detected
    isShadowRoot(element) ? element.host : null) || // ShadowRoot detected
    // $FlowFixMe[incompatible-call]: HTMLElement is a Node
    getDocumentElement(element) // fallback

  );
}
;// ./node_modules/@popperjs/core/lib/dom-utils/getOffsetParent.js








function getTrueOffsetParent(element) {
  if (!isHTMLElement(element) || // https://github.com/popperjs/popper-core/issues/837
  getComputedStyle(element).position === 'fixed') {
    return null;
  }

  return element.offsetParent;
} // `.offsetParent` reports `null` for fixed elements, while absolute elements
// return the containing block


function getContainingBlock(element) {
  var isFirefox = /firefox/i.test(getUAString());
  var isIE = /Trident/i.test(getUAString());

  if (isIE && isHTMLElement(element)) {
    // In IE 9, 10 and 11 fixed elements containing block is always established by the viewport
    var elementCss = getComputedStyle(element);

    if (elementCss.position === 'fixed') {
      return null;
    }
  }

  var currentNode = getParentNode(element);

  if (isShadowRoot(currentNode)) {
    currentNode = currentNode.host;
  }

  while (isHTMLElement(currentNode) && ['html', 'body'].indexOf(getNodeName(currentNode)) < 0) {
    var css = getComputedStyle(currentNode); // This is non-exhaustive but covers the most common CSS properties that
    // create a containing block.
    // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block

    if (css.transform !== 'none' || css.perspective !== 'none' || css.contain === 'paint' || ['transform', 'perspective'].indexOf(css.willChange) !== -1 || isFirefox && css.willChange === 'filter' || isFirefox && css.filter && css.filter !== 'none') {
      return currentNode;
    } else {
      currentNode = currentNode.parentNode;
    }
  }

  return null;
} // Gets the closest ancestor positioned element. Handles some edge cases,
// such as table ancestors and cross browser bugs.


function getOffsetParent(element) {
  var window = getWindow(element);
  var offsetParent = getTrueOffsetParent(element);

  while (offsetParent && isTableElement(offsetParent) && getComputedStyle(offsetParent).position === 'static') {
    offsetParent = getTrueOffsetParent(offsetParent);
  }

  if (offsetParent && (getNodeName(offsetParent) === 'html' || getNodeName(offsetParent) === 'body' && getComputedStyle(offsetParent).position === 'static')) {
    return window;
  }

  return offsetParent || getContainingBlock(element) || window;
}
;// ./node_modules/@popperjs/core/lib/utils/getMainAxisFromPlacement.js
function getMainAxisFromPlacement(placement) {
  return ['top', 'bottom'].indexOf(placement) >= 0 ? 'x' : 'y';
}
;// ./node_modules/@popperjs/core/lib/utils/within.js

function within(min, value, max) {
  return math_max(min, math_min(value, max));
}
function withinMaxClamp(min, value, max) {
  var v = within(min, value, max);
  return v > max ? max : v;
}
;// ./node_modules/@popperjs/core/lib/utils/getFreshSideObject.js
function getFreshSideObject() {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0
  };
}
;// ./node_modules/@popperjs/core/lib/utils/mergePaddingObject.js

function mergePaddingObject(paddingObject) {
  return Object.assign({}, getFreshSideObject(), paddingObject);
}
;// ./node_modules/@popperjs/core/lib/utils/expandToHashMap.js
function expandToHashMap(value, keys) {
  return keys.reduce(function (hashMap, key) {
    hashMap[key] = value;
    return hashMap;
  }, {});
}
;// ./node_modules/@popperjs/core/lib/modifiers/arrow.js








 // eslint-disable-next-line import/no-unused-modules

var toPaddingObject = function toPaddingObject(padding, state) {
  padding = typeof padding === 'function' ? padding(Object.assign({}, state.rects, {
    placement: state.placement
  })) : padding;
  return mergePaddingObject(typeof padding !== 'number' ? padding : expandToHashMap(padding, basePlacements));
};

function arrow(_ref) {
  var _state$modifiersData$;

  var state = _ref.state,
      name = _ref.name,
      options = _ref.options;
  var arrowElement = state.elements.arrow;
  var popperOffsets = state.modifiersData.popperOffsets;
  var basePlacement = getBasePlacement(state.placement);
  var axis = getMainAxisFromPlacement(basePlacement);
  var isVertical = [left, right].indexOf(basePlacement) >= 0;
  var len = isVertical ? 'height' : 'width';

  if (!arrowElement || !popperOffsets) {
    return;
  }

  var paddingObject = toPaddingObject(options.padding, state);
  var arrowRect = getLayoutRect(arrowElement);
  var minProp = axis === 'y' ? enums_top : left;
  var maxProp = axis === 'y' ? bottom : right;
  var endDiff = state.rects.reference[len] + state.rects.reference[axis] - popperOffsets[axis] - state.rects.popper[len];
  var startDiff = popperOffsets[axis] - state.rects.reference[axis];
  var arrowOffsetParent = getOffsetParent(arrowElement);
  var clientSize = arrowOffsetParent ? axis === 'y' ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;
  var centerToReference = endDiff / 2 - startDiff / 2; // Make sure the arrow doesn't overflow the popper if the center point is
  // outside of the popper bounds

  var min = paddingObject[minProp];
  var max = clientSize - arrowRect[len] - paddingObject[maxProp];
  var center = clientSize / 2 - arrowRect[len] / 2 + centerToReference;
  var offset = within(min, center, max); // Prevents breaking syntax highlighting...

  var axisProp = axis;
  state.modifiersData[name] = (_state$modifiersData$ = {}, _state$modifiersData$[axisProp] = offset, _state$modifiersData$.centerOffset = offset - center, _state$modifiersData$);
}

function arrow_effect(_ref2) {
  var state = _ref2.state,
      options = _ref2.options;
  var _options$element = options.element,
      arrowElement = _options$element === void 0 ? '[data-popper-arrow]' : _options$element;

  if (arrowElement == null) {
    return;
  } // CSS selector


  if (typeof arrowElement === 'string') {
    arrowElement = state.elements.popper.querySelector(arrowElement);

    if (!arrowElement) {
      return;
    }
  }

  if (!contains(state.elements.popper, arrowElement)) {
    return;
  }

  state.elements.arrow = arrowElement;
} // eslint-disable-next-line import/no-unused-modules


/* harmony default export */ var modifiers_arrow = ({
  name: 'arrow',
  enabled: true,
  phase: 'main',
  fn: arrow,
  effect: arrow_effect,
  requires: ['popperOffsets'],
  requiresIfExists: ['preventOverflow']
});
;// ./node_modules/@popperjs/core/lib/utils/getVariation.js
function getVariation(placement) {
  return placement.split('-')[1];
}
;// ./node_modules/@popperjs/core/lib/modifiers/computeStyles.js







 // eslint-disable-next-line import/no-unused-modules

var unsetSides = {
  top: 'auto',
  right: 'auto',
  bottom: 'auto',
  left: 'auto'
}; // Round the offsets to the nearest suitable subpixel based on the DPR.
// Zooming can change the DPR, but it seems to report a value that will
// cleanly divide the values into the appropriate subpixels.

function roundOffsetsByDPR(_ref, win) {
  var x = _ref.x,
      y = _ref.y;
  var dpr = win.devicePixelRatio || 1;
  return {
    x: round(x * dpr) / dpr || 0,
    y: round(y * dpr) / dpr || 0
  };
}

function mapToStyles(_ref2) {
  var _Object$assign2;

  var popper = _ref2.popper,
      popperRect = _ref2.popperRect,
      placement = _ref2.placement,
      variation = _ref2.variation,
      offsets = _ref2.offsets,
      position = _ref2.position,
      gpuAcceleration = _ref2.gpuAcceleration,
      adaptive = _ref2.adaptive,
      roundOffsets = _ref2.roundOffsets,
      isFixed = _ref2.isFixed;
  var _offsets$x = offsets.x,
      x = _offsets$x === void 0 ? 0 : _offsets$x,
      _offsets$y = offsets.y,
      y = _offsets$y === void 0 ? 0 : _offsets$y;

  var _ref3 = typeof roundOffsets === 'function' ? roundOffsets({
    x: x,
    y: y
  }) : {
    x: x,
    y: y
  };

  x = _ref3.x;
  y = _ref3.y;
  var hasX = offsets.hasOwnProperty('x');
  var hasY = offsets.hasOwnProperty('y');
  var sideX = left;
  var sideY = enums_top;
  var win = window;

  if (adaptive) {
    var offsetParent = getOffsetParent(popper);
    var heightProp = 'clientHeight';
    var widthProp = 'clientWidth';

    if (offsetParent === getWindow(popper)) {
      offsetParent = getDocumentElement(popper);

      if (getComputedStyle(offsetParent).position !== 'static' && position === 'absolute') {
        heightProp = 'scrollHeight';
        widthProp = 'scrollWidth';
      }
    } // $FlowFixMe[incompatible-cast]: force type refinement, we compare offsetParent with window above, but Flow doesn't detect it


    offsetParent = offsetParent;

    if (placement === enums_top || (placement === left || placement === right) && variation === end) {
      sideY = bottom;
      var offsetY = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.height : // $FlowFixMe[prop-missing]
      offsetParent[heightProp];
      y -= offsetY - popperRect.height;
      y *= gpuAcceleration ? 1 : -1;
    }

    if (placement === left || (placement === enums_top || placement === bottom) && variation === end) {
      sideX = right;
      var offsetX = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.width : // $FlowFixMe[prop-missing]
      offsetParent[widthProp];
      x -= offsetX - popperRect.width;
      x *= gpuAcceleration ? 1 : -1;
    }
  }

  var commonStyles = Object.assign({
    position: position
  }, adaptive && unsetSides);

  var _ref4 = roundOffsets === true ? roundOffsetsByDPR({
    x: x,
    y: y
  }, getWindow(popper)) : {
    x: x,
    y: y
  };

  x = _ref4.x;
  y = _ref4.y;

  if (gpuAcceleration) {
    var _Object$assign;

    return Object.assign({}, commonStyles, (_Object$assign = {}, _Object$assign[sideY] = hasY ? '0' : '', _Object$assign[sideX] = hasX ? '0' : '', _Object$assign.transform = (win.devicePixelRatio || 1) <= 1 ? "translate(" + x + "px, " + y + "px)" : "translate3d(" + x + "px, " + y + "px, 0)", _Object$assign));
  }

  return Object.assign({}, commonStyles, (_Object$assign2 = {}, _Object$assign2[sideY] = hasY ? y + "px" : '', _Object$assign2[sideX] = hasX ? x + "px" : '', _Object$assign2.transform = '', _Object$assign2));
}

function computeStyles(_ref5) {
  var state = _ref5.state,
      options = _ref5.options;
  var _options$gpuAccelerat = options.gpuAcceleration,
      gpuAcceleration = _options$gpuAccelerat === void 0 ? true : _options$gpuAccelerat,
      _options$adaptive = options.adaptive,
      adaptive = _options$adaptive === void 0 ? true : _options$adaptive,
      _options$roundOffsets = options.roundOffsets,
      roundOffsets = _options$roundOffsets === void 0 ? true : _options$roundOffsets;
  var commonStyles = {
    placement: getBasePlacement(state.placement),
    variation: getVariation(state.placement),
    popper: state.elements.popper,
    popperRect: state.rects.popper,
    gpuAcceleration: gpuAcceleration,
    isFixed: state.options.strategy === 'fixed'
  };

  if (state.modifiersData.popperOffsets != null) {
    state.styles.popper = Object.assign({}, state.styles.popper, mapToStyles(Object.assign({}, commonStyles, {
      offsets: state.modifiersData.popperOffsets,
      position: state.options.strategy,
      adaptive: adaptive,
      roundOffsets: roundOffsets
    })));
  }

  if (state.modifiersData.arrow != null) {
    state.styles.arrow = Object.assign({}, state.styles.arrow, mapToStyles(Object.assign({}, commonStyles, {
      offsets: state.modifiersData.arrow,
      position: 'absolute',
      adaptive: false,
      roundOffsets: roundOffsets
    })));
  }

  state.attributes.popper = Object.assign({}, state.attributes.popper, {
    'data-popper-placement': state.placement
  });
} // eslint-disable-next-line import/no-unused-modules


/* harmony default export */ var modifiers_computeStyles = ({
  name: 'computeStyles',
  enabled: true,
  phase: 'beforeWrite',
  fn: computeStyles,
  data: {}
});
;// ./node_modules/@popperjs/core/lib/modifiers/eventListeners.js
 // eslint-disable-next-line import/no-unused-modules

var passive = {
  passive: true
};

function eventListeners_effect(_ref) {
  var state = _ref.state,
      instance = _ref.instance,
      options = _ref.options;
  var _options$scroll = options.scroll,
      scroll = _options$scroll === void 0 ? true : _options$scroll,
      _options$resize = options.resize,
      resize = _options$resize === void 0 ? true : _options$resize;
  var window = getWindow(state.elements.popper);
  var scrollParents = [].concat(state.scrollParents.reference, state.scrollParents.popper);

  if (scroll) {
    scrollParents.forEach(function (scrollParent) {
      scrollParent.addEventListener('scroll', instance.update, passive);
    });
  }

  if (resize) {
    window.addEventListener('resize', instance.update, passive);
  }

  return function () {
    if (scroll) {
      scrollParents.forEach(function (scrollParent) {
        scrollParent.removeEventListener('scroll', instance.update, passive);
      });
    }

    if (resize) {
      window.removeEventListener('resize', instance.update, passive);
    }
  };
} // eslint-disable-next-line import/no-unused-modules


/* harmony default export */ var eventListeners = ({
  name: 'eventListeners',
  enabled: true,
  phase: 'write',
  fn: function fn() {},
  effect: eventListeners_effect,
  data: {}
});
;// ./node_modules/@popperjs/core/lib/utils/getOppositePlacement.js
var hash = {
  left: 'right',
  right: 'left',
  bottom: 'top',
  top: 'bottom'
};
function getOppositePlacement(placement) {
  return placement.replace(/left|right|bottom|top/g, function (matched) {
    return hash[matched];
  });
}
;// ./node_modules/@popperjs/core/lib/utils/getOppositeVariationPlacement.js
var getOppositeVariationPlacement_hash = {
  start: 'end',
  end: 'start'
};
function getOppositeVariationPlacement(placement) {
  return placement.replace(/start|end/g, function (matched) {
    return getOppositeVariationPlacement_hash[matched];
  });
}
;// ./node_modules/@popperjs/core/lib/dom-utils/getWindowScroll.js

function getWindowScroll(node) {
  var win = getWindow(node);
  var scrollLeft = win.pageXOffset;
  var scrollTop = win.pageYOffset;
  return {
    scrollLeft: scrollLeft,
    scrollTop: scrollTop
  };
}
;// ./node_modules/@popperjs/core/lib/dom-utils/getWindowScrollBarX.js



function getWindowScrollBarX(element) {
  // If <html> has a CSS width greater than the viewport, then this will be
  // incorrect for RTL.
  // Popper 1 is broken in this case and never had a bug report so let's assume
  // it's not an issue. I don't think anyone ever specifies width on <html>
  // anyway.
  // Browsers where the left scrollbar doesn't cause an issue report `0` for
  // this (e.g. Edge 2019, IE11, Safari)
  return getBoundingClientRect(getDocumentElement(element)).left + getWindowScroll(element).scrollLeft;
}
;// ./node_modules/@popperjs/core/lib/dom-utils/getViewportRect.js




function getViewportRect(element, strategy) {
  var win = getWindow(element);
  var html = getDocumentElement(element);
  var visualViewport = win.visualViewport;
  var width = html.clientWidth;
  var height = html.clientHeight;
  var x = 0;
  var y = 0;

  if (visualViewport) {
    width = visualViewport.width;
    height = visualViewport.height;
    var layoutViewport = isLayoutViewport();

    if (layoutViewport || !layoutViewport && strategy === 'fixed') {
      x = visualViewport.offsetLeft;
      y = visualViewport.offsetTop;
    }
  }

  return {
    width: width,
    height: height,
    x: x + getWindowScrollBarX(element),
    y: y
  };
}
;// ./node_modules/@popperjs/core/lib/dom-utils/getDocumentRect.js




 // Gets the entire size of the scrollable document area, even extending outside
// of the `<html>` and `<body>` rect bounds if horizontally scrollable

function getDocumentRect(element) {
  var _element$ownerDocumen;

  var html = getDocumentElement(element);
  var winScroll = getWindowScroll(element);
  var body = (_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body;
  var width = math_max(html.scrollWidth, html.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0);
  var height = math_max(html.scrollHeight, html.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0);
  var x = -winScroll.scrollLeft + getWindowScrollBarX(element);
  var y = -winScroll.scrollTop;

  if (getComputedStyle(body || html).direction === 'rtl') {
    x += math_max(html.clientWidth, body ? body.clientWidth : 0) - width;
  }

  return {
    width: width,
    height: height,
    x: x,
    y: y
  };
}
;// ./node_modules/@popperjs/core/lib/dom-utils/isScrollParent.js

function isScrollParent(element) {
  // Firefox wants us to check `-x` and `-y` variations as well
  var _getComputedStyle = getComputedStyle(element),
      overflow = _getComputedStyle.overflow,
      overflowX = _getComputedStyle.overflowX,
      overflowY = _getComputedStyle.overflowY;

  return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX);
}
;// ./node_modules/@popperjs/core/lib/dom-utils/getScrollParent.js




function getScrollParent(node) {
  if (['html', 'body', '#document'].indexOf(getNodeName(node)) >= 0) {
    // $FlowFixMe[incompatible-return]: assume body is always available
    return node.ownerDocument.body;
  }

  if (isHTMLElement(node) && isScrollParent(node)) {
    return node;
  }

  return getScrollParent(getParentNode(node));
}
;// ./node_modules/@popperjs/core/lib/dom-utils/listScrollParents.js




/*
given a DOM element, return the list of all scroll parents, up the list of ancesors
until we get to the top window object. This list is what we attach scroll listeners
to, because if any of these parent elements scroll, we'll need to re-calculate the
reference element's position.
*/

function listScrollParents(element, list) {
  var _element$ownerDocumen;

  if (list === void 0) {
    list = [];
  }

  var scrollParent = getScrollParent(element);
  var isBody = scrollParent === ((_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body);
  var win = getWindow(scrollParent);
  var target = isBody ? [win].concat(win.visualViewport || [], isScrollParent(scrollParent) ? scrollParent : []) : scrollParent;
  var updatedList = list.concat(target);
  return isBody ? updatedList : // $FlowFixMe[incompatible-call]: isBody tells us target will be an HTMLElement here
  updatedList.concat(listScrollParents(getParentNode(target)));
}
;// ./node_modules/@popperjs/core/lib/utils/rectToClientRect.js
function rectToClientRect(rect) {
  return Object.assign({}, rect, {
    left: rect.x,
    top: rect.y,
    right: rect.x + rect.width,
    bottom: rect.y + rect.height
  });
}
;// ./node_modules/@popperjs/core/lib/dom-utils/getClippingRect.js















function getInnerBoundingClientRect(element, strategy) {
  var rect = getBoundingClientRect(element, false, strategy === 'fixed');
  rect.top = rect.top + element.clientTop;
  rect.left = rect.left + element.clientLeft;
  rect.bottom = rect.top + element.clientHeight;
  rect.right = rect.left + element.clientWidth;
  rect.width = element.clientWidth;
  rect.height = element.clientHeight;
  rect.x = rect.left;
  rect.y = rect.top;
  return rect;
}

function getClientRectFromMixedType(element, clippingParent, strategy) {
  return clippingParent === viewport ? rectToClientRect(getViewportRect(element, strategy)) : isElement(clippingParent) ? getInnerBoundingClientRect(clippingParent, strategy) : rectToClientRect(getDocumentRect(getDocumentElement(element)));
} // A "clipping parent" is an overflowable container with the characteristic of
// clipping (or hiding) overflowing elements with a position different from
// `initial`


function getClippingParents(element) {
  var clippingParents = listScrollParents(getParentNode(element));
  var canEscapeClipping = ['absolute', 'fixed'].indexOf(getComputedStyle(element).position) >= 0;
  var clipperElement = canEscapeClipping && isHTMLElement(element) ? getOffsetParent(element) : element;

  if (!isElement(clipperElement)) {
    return [];
  } // $FlowFixMe[incompatible-return]: https://github.com/facebook/flow/issues/1414


  return clippingParents.filter(function (clippingParent) {
    return isElement(clippingParent) && contains(clippingParent, clipperElement) && getNodeName(clippingParent) !== 'body';
  });
} // Gets the maximum area that the element is visible in due to any number of
// clipping parents


function getClippingRect(element, boundary, rootBoundary, strategy) {
  var mainClippingParents = boundary === 'clippingParents' ? getClippingParents(element) : [].concat(boundary);
  var clippingParents = [].concat(mainClippingParents, [rootBoundary]);
  var firstClippingParent = clippingParents[0];
  var clippingRect = clippingParents.reduce(function (accRect, clippingParent) {
    var rect = getClientRectFromMixedType(element, clippingParent, strategy);
    accRect.top = math_max(rect.top, accRect.top);
    accRect.right = math_min(rect.right, accRect.right);
    accRect.bottom = math_min(rect.bottom, accRect.bottom);
    accRect.left = math_max(rect.left, accRect.left);
    return accRect;
  }, getClientRectFromMixedType(element, firstClippingParent, strategy));
  clippingRect.width = clippingRect.right - clippingRect.left;
  clippingRect.height = clippingRect.bottom - clippingRect.top;
  clippingRect.x = clippingRect.left;
  clippingRect.y = clippingRect.top;
  return clippingRect;
}
;// ./node_modules/@popperjs/core/lib/utils/computeOffsets.js




function computeOffsets(_ref) {
  var reference = _ref.reference,
      element = _ref.element,
      placement = _ref.placement;
  var basePlacement = placement ? getBasePlacement(placement) : null;
  var variation = placement ? getVariation(placement) : null;
  var commonX = reference.x + reference.width / 2 - element.width / 2;
  var commonY = reference.y + reference.height / 2 - element.height / 2;
  var offsets;

  switch (basePlacement) {
    case enums_top:
      offsets = {
        x: commonX,
        y: reference.y - element.height
      };
      break;

    case bottom:
      offsets = {
        x: commonX,
        y: reference.y + reference.height
      };
      break;

    case right:
      offsets = {
        x: reference.x + reference.width,
        y: commonY
      };
      break;

    case left:
      offsets = {
        x: reference.x - element.width,
        y: commonY
      };
      break;

    default:
      offsets = {
        x: reference.x,
        y: reference.y
      };
  }

  var mainAxis = basePlacement ? getMainAxisFromPlacement(basePlacement) : null;

  if (mainAxis != null) {
    var len = mainAxis === 'y' ? 'height' : 'width';

    switch (variation) {
      case start:
        offsets[mainAxis] = offsets[mainAxis] - (reference[len] / 2 - element[len] / 2);
        break;

      case end:
        offsets[mainAxis] = offsets[mainAxis] + (reference[len] / 2 - element[len] / 2);
        break;

      default:
    }
  }

  return offsets;
}
;// ./node_modules/@popperjs/core/lib/utils/detectOverflow.js








 // eslint-disable-next-line import/no-unused-modules

function detectOverflow(state, options) {
  if (options === void 0) {
    options = {};
  }

  var _options = options,
      _options$placement = _options.placement,
      placement = _options$placement === void 0 ? state.placement : _options$placement,
      _options$strategy = _options.strategy,
      strategy = _options$strategy === void 0 ? state.strategy : _options$strategy,
      _options$boundary = _options.boundary,
      boundary = _options$boundary === void 0 ? clippingParents : _options$boundary,
      _options$rootBoundary = _options.rootBoundary,
      rootBoundary = _options$rootBoundary === void 0 ? viewport : _options$rootBoundary,
      _options$elementConte = _options.elementContext,
      elementContext = _options$elementConte === void 0 ? popper : _options$elementConte,
      _options$altBoundary = _options.altBoundary,
      altBoundary = _options$altBoundary === void 0 ? false : _options$altBoundary,
      _options$padding = _options.padding,
      padding = _options$padding === void 0 ? 0 : _options$padding;
  var paddingObject = mergePaddingObject(typeof padding !== 'number' ? padding : expandToHashMap(padding, basePlacements));
  var altContext = elementContext === popper ? reference : popper;
  var popperRect = state.rects.popper;
  var element = state.elements[altBoundary ? altContext : elementContext];
  var clippingClientRect = getClippingRect(isElement(element) ? element : element.contextElement || getDocumentElement(state.elements.popper), boundary, rootBoundary, strategy);
  var referenceClientRect = getBoundingClientRect(state.elements.reference);
  var popperOffsets = computeOffsets({
    reference: referenceClientRect,
    element: popperRect,
    strategy: 'absolute',
    placement: placement
  });
  var popperClientRect = rectToClientRect(Object.assign({}, popperRect, popperOffsets));
  var elementClientRect = elementContext === popper ? popperClientRect : referenceClientRect; // positive = overflowing the clipping rect
  // 0 or negative = within the clipping rect

  var overflowOffsets = {
    top: clippingClientRect.top - elementClientRect.top + paddingObject.top,
    bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,
    left: clippingClientRect.left - elementClientRect.left + paddingObject.left,
    right: elementClientRect.right - clippingClientRect.right + paddingObject.right
  };
  var offsetData = state.modifiersData.offset; // Offsets can be applied only to the popper element

  if (elementContext === popper && offsetData) {
    var offset = offsetData[placement];
    Object.keys(overflowOffsets).forEach(function (key) {
      var multiply = [right, bottom].indexOf(key) >= 0 ? 1 : -1;
      var axis = [enums_top, bottom].indexOf(key) >= 0 ? 'y' : 'x';
      overflowOffsets[key] += offset[axis] * multiply;
    });
  }

  return overflowOffsets;
}
;// ./node_modules/@popperjs/core/lib/utils/computeAutoPlacement.js




function computeAutoPlacement(state, options) {
  if (options === void 0) {
    options = {};
  }

  var _options = options,
      placement = _options.placement,
      boundary = _options.boundary,
      rootBoundary = _options.rootBoundary,
      padding = _options.padding,
      flipVariations = _options.flipVariations,
      _options$allowedAutoP = _options.allowedAutoPlacements,
      allowedAutoPlacements = _options$allowedAutoP === void 0 ? enums_placements : _options$allowedAutoP;
  var variation = getVariation(placement);
  var placements = variation ? flipVariations ? variationPlacements : variationPlacements.filter(function (placement) {
    return getVariation(placement) === variation;
  }) : basePlacements;
  var allowedPlacements = placements.filter(function (placement) {
    return allowedAutoPlacements.indexOf(placement) >= 0;
  });

  if (allowedPlacements.length === 0) {
    allowedPlacements = placements;
  } // $FlowFixMe[incompatible-type]: Flow seems to have problems with two array unions...


  var overflows = allowedPlacements.reduce(function (acc, placement) {
    acc[placement] = detectOverflow(state, {
      placement: placement,
      boundary: boundary,
      rootBoundary: rootBoundary,
      padding: padding
    })[getBasePlacement(placement)];
    return acc;
  }, {});
  return Object.keys(overflows).sort(function (a, b) {
    return overflows[a] - overflows[b];
  });
}
;// ./node_modules/@popperjs/core/lib/modifiers/flip.js






 // eslint-disable-next-line import/no-unused-modules

function getExpandedFallbackPlacements(placement) {
  if (getBasePlacement(placement) === auto) {
    return [];
  }

  var oppositePlacement = getOppositePlacement(placement);
  return [getOppositeVariationPlacement(placement), oppositePlacement, getOppositeVariationPlacement(oppositePlacement)];
}

function flip(_ref) {
  var state = _ref.state,
      options = _ref.options,
      name = _ref.name;

  if (state.modifiersData[name]._skip) {
    return;
  }

  var _options$mainAxis = options.mainAxis,
      checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis,
      _options$altAxis = options.altAxis,
      checkAltAxis = _options$altAxis === void 0 ? true : _options$altAxis,
      specifiedFallbackPlacements = options.fallbackPlacements,
      padding = options.padding,
      boundary = options.boundary,
      rootBoundary = options.rootBoundary,
      altBoundary = options.altBoundary,
      _options$flipVariatio = options.flipVariations,
      flipVariations = _options$flipVariatio === void 0 ? true : _options$flipVariatio,
      allowedAutoPlacements = options.allowedAutoPlacements;
  var preferredPlacement = state.options.placement;
  var basePlacement = getBasePlacement(preferredPlacement);
  var isBasePlacement = basePlacement === preferredPlacement;
  var fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipVariations ? [getOppositePlacement(preferredPlacement)] : getExpandedFallbackPlacements(preferredPlacement));
  var placements = [preferredPlacement].concat(fallbackPlacements).reduce(function (acc, placement) {
    return acc.concat(getBasePlacement(placement) === auto ? computeAutoPlacement(state, {
      placement: placement,
      boundary: boundary,
      rootBoundary: rootBoundary,
      padding: padding,
      flipVariations: flipVariations,
      allowedAutoPlacements: allowedAutoPlacements
    }) : placement);
  }, []);
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var checksMap = new Map();
  var makeFallbackChecks = true;
  var firstFittingPlacement = placements[0];

  for (var i = 0; i < placements.length; i++) {
    var placement = placements[i];

    var _basePlacement = getBasePlacement(placement);

    var isStartVariation = getVariation(placement) === start;
    var isVertical = [enums_top, bottom].indexOf(_basePlacement) >= 0;
    var len = isVertical ? 'width' : 'height';
    var overflow = detectOverflow(state, {
      placement: placement,
      boundary: boundary,
      rootBoundary: rootBoundary,
      altBoundary: altBoundary,
      padding: padding
    });
    var mainVariationSide = isVertical ? isStartVariation ? right : left : isStartVariation ? bottom : enums_top;

    if (referenceRect[len] > popperRect[len]) {
      mainVariationSide = getOppositePlacement(mainVariationSide);
    }

    var altVariationSide = getOppositePlacement(mainVariationSide);
    var checks = [];

    if (checkMainAxis) {
      checks.push(overflow[_basePlacement] <= 0);
    }

    if (checkAltAxis) {
      checks.push(overflow[mainVariationSide] <= 0, overflow[altVariationSide] <= 0);
    }

    if (checks.every(function (check) {
      return check;
    })) {
      firstFittingPlacement = placement;
      makeFallbackChecks = false;
      break;
    }

    checksMap.set(placement, checks);
  }

  if (makeFallbackChecks) {
    // `2` may be desired in some cases  research later
    var numberOfChecks = flipVariations ? 3 : 1;

    var _loop = function _loop(_i) {
      var fittingPlacement = placements.find(function (placement) {
        var checks = checksMap.get(placement);

        if (checks) {
          return checks.slice(0, _i).every(function (check) {
            return check;
          });
        }
      });

      if (fittingPlacement) {
        firstFittingPlacement = fittingPlacement;
        return "break";
      }
    };

    for (var _i = numberOfChecks; _i > 0; _i--) {
      var _ret = _loop(_i);

      if (_ret === "break") break;
    }
  }

  if (state.placement !== firstFittingPlacement) {
    state.modifiersData[name]._skip = true;
    state.placement = firstFittingPlacement;
    state.reset = true;
  }
} // eslint-disable-next-line import/no-unused-modules


/* harmony default export */ var modifiers_flip = ({
  name: 'flip',
  enabled: true,
  phase: 'main',
  fn: flip,
  requiresIfExists: ['offset'],
  data: {
    _skip: false
  }
});
;// ./node_modules/@popperjs/core/lib/modifiers/hide.js



function getSideOffsets(overflow, rect, preventedOffsets) {
  if (preventedOffsets === void 0) {
    preventedOffsets = {
      x: 0,
      y: 0
    };
  }

  return {
    top: overflow.top - rect.height - preventedOffsets.y,
    right: overflow.right - rect.width + preventedOffsets.x,
    bottom: overflow.bottom - rect.height + preventedOffsets.y,
    left: overflow.left - rect.width - preventedOffsets.x
  };
}

function isAnySideFullyClipped(overflow) {
  return [enums_top, right, bottom, left].some(function (side) {
    return overflow[side] >= 0;
  });
}

function hide(_ref) {
  var state = _ref.state,
      name = _ref.name;
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var preventedOffsets = state.modifiersData.preventOverflow;
  var referenceOverflow = detectOverflow(state, {
    elementContext: 'reference'
  });
  var popperAltOverflow = detectOverflow(state, {
    altBoundary: true
  });
  var referenceClippingOffsets = getSideOffsets(referenceOverflow, referenceRect);
  var popperEscapeOffsets = getSideOffsets(popperAltOverflow, popperRect, preventedOffsets);
  var isReferenceHidden = isAnySideFullyClipped(referenceClippingOffsets);
  var hasPopperEscaped = isAnySideFullyClipped(popperEscapeOffsets);
  state.modifiersData[name] = {
    referenceClippingOffsets: referenceClippingOffsets,
    popperEscapeOffsets: popperEscapeOffsets,
    isReferenceHidden: isReferenceHidden,
    hasPopperEscaped: hasPopperEscaped
  };
  state.attributes.popper = Object.assign({}, state.attributes.popper, {
    'data-popper-reference-hidden': isReferenceHidden,
    'data-popper-escaped': hasPopperEscaped
  });
} // eslint-disable-next-line import/no-unused-modules


/* harmony default export */ var modifiers_hide = ({
  name: 'hide',
  enabled: true,
  phase: 'main',
  requiresIfExists: ['preventOverflow'],
  fn: hide
});
;// ./node_modules/@popperjs/core/lib/modifiers/offset.js

 // eslint-disable-next-line import/no-unused-modules

function distanceAndSkiddingToXY(placement, rects, offset) {
  var basePlacement = getBasePlacement(placement);
  var invertDistance = [left, enums_top].indexOf(basePlacement) >= 0 ? -1 : 1;

  var _ref = typeof offset === 'function' ? offset(Object.assign({}, rects, {
    placement: placement
  })) : offset,
      skidding = _ref[0],
      distance = _ref[1];

  skidding = skidding || 0;
  distance = (distance || 0) * invertDistance;
  return [left, right].indexOf(basePlacement) >= 0 ? {
    x: distance,
    y: skidding
  } : {
    x: skidding,
    y: distance
  };
}

function offset(_ref2) {
  var state = _ref2.state,
      options = _ref2.options,
      name = _ref2.name;
  var _options$offset = options.offset,
      offset = _options$offset === void 0 ? [0, 0] : _options$offset;
  var data = enums_placements.reduce(function (acc, placement) {
    acc[placement] = distanceAndSkiddingToXY(placement, state.rects, offset);
    return acc;
  }, {});
  var _data$state$placement = data[state.placement],
      x = _data$state$placement.x,
      y = _data$state$placement.y;

  if (state.modifiersData.popperOffsets != null) {
    state.modifiersData.popperOffsets.x += x;
    state.modifiersData.popperOffsets.y += y;
  }

  state.modifiersData[name] = data;
} // eslint-disable-next-line import/no-unused-modules


/* harmony default export */ var modifiers_offset = ({
  name: 'offset',
  enabled: true,
  phase: 'main',
  requires: ['popperOffsets'],
  fn: offset
});
;// ./node_modules/@popperjs/core/lib/modifiers/popperOffsets.js


function popperOffsets(_ref) {
  var state = _ref.state,
      name = _ref.name;
  // Offsets are the actual position the popper needs to have to be
  // properly positioned near its reference element
  // This is the most basic placement, and will be adjusted by
  // the modifiers in the next step
  state.modifiersData[name] = computeOffsets({
    reference: state.rects.reference,
    element: state.rects.popper,
    strategy: 'absolute',
    placement: state.placement
  });
} // eslint-disable-next-line import/no-unused-modules


/* harmony default export */ var modifiers_popperOffsets = ({
  name: 'popperOffsets',
  enabled: true,
  phase: 'read',
  fn: popperOffsets,
  data: {}
});
;// ./node_modules/@popperjs/core/lib/utils/getAltAxis.js
function getAltAxis(axis) {
  return axis === 'x' ? 'y' : 'x';
}
;// ./node_modules/@popperjs/core/lib/modifiers/preventOverflow.js












function preventOverflow(_ref) {
  var state = _ref.state,
      options = _ref.options,
      name = _ref.name;
  var _options$mainAxis = options.mainAxis,
      checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis,
      _options$altAxis = options.altAxis,
      checkAltAxis = _options$altAxis === void 0 ? false : _options$altAxis,
      boundary = options.boundary,
      rootBoundary = options.rootBoundary,
      altBoundary = options.altBoundary,
      padding = options.padding,
      _options$tether = options.tether,
      tether = _options$tether === void 0 ? true : _options$tether,
      _options$tetherOffset = options.tetherOffset,
      tetherOffset = _options$tetherOffset === void 0 ? 0 : _options$tetherOffset;
  var overflow = detectOverflow(state, {
    boundary: boundary,
    rootBoundary: rootBoundary,
    padding: padding,
    altBoundary: altBoundary
  });
  var basePlacement = getBasePlacement(state.placement);
  var variation = getVariation(state.placement);
  var isBasePlacement = !variation;
  var mainAxis = getMainAxisFromPlacement(basePlacement);
  var altAxis = getAltAxis(mainAxis);
  var popperOffsets = state.modifiersData.popperOffsets;
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var tetherOffsetValue = typeof tetherOffset === 'function' ? tetherOffset(Object.assign({}, state.rects, {
    placement: state.placement
  })) : tetherOffset;
  var normalizedTetherOffsetValue = typeof tetherOffsetValue === 'number' ? {
    mainAxis: tetherOffsetValue,
    altAxis: tetherOffsetValue
  } : Object.assign({
    mainAxis: 0,
    altAxis: 0
  }, tetherOffsetValue);
  var offsetModifierState = state.modifiersData.offset ? state.modifiersData.offset[state.placement] : null;
  var data = {
    x: 0,
    y: 0
  };

  if (!popperOffsets) {
    return;
  }

  if (checkMainAxis) {
    var _offsetModifierState$;

    var mainSide = mainAxis === 'y' ? enums_top : left;
    var altSide = mainAxis === 'y' ? bottom : right;
    var len = mainAxis === 'y' ? 'height' : 'width';
    var offset = popperOffsets[mainAxis];
    var min = offset + overflow[mainSide];
    var max = offset - overflow[altSide];
    var additive = tether ? -popperRect[len] / 2 : 0;
    var minLen = variation === start ? referenceRect[len] : popperRect[len];
    var maxLen = variation === start ? -popperRect[len] : -referenceRect[len]; // We need to include the arrow in the calculation so the arrow doesn't go
    // outside the reference bounds

    var arrowElement = state.elements.arrow;
    var arrowRect = tether && arrowElement ? getLayoutRect(arrowElement) : {
      width: 0,
      height: 0
    };
    var arrowPaddingObject = state.modifiersData['arrow#persistent'] ? state.modifiersData['arrow#persistent'].padding : getFreshSideObject();
    var arrowPaddingMin = arrowPaddingObject[mainSide];
    var arrowPaddingMax = arrowPaddingObject[altSide]; // If the reference length is smaller than the arrow length, we don't want
    // to include its full size in the calculation. If the reference is small
    // and near the edge of a boundary, the popper can overflow even if the
    // reference is not overflowing as well (e.g. virtual elements with no
    // width or height)

    var arrowLen = within(0, referenceRect[len], arrowRect[len]);
    var minOffset = isBasePlacement ? referenceRect[len] / 2 - additive - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis : minLen - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis;
    var maxOffset = isBasePlacement ? -referenceRect[len] / 2 + additive + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis : maxLen + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis;
    var arrowOffsetParent = state.elements.arrow && getOffsetParent(state.elements.arrow);
    var clientOffset = arrowOffsetParent ? mainAxis === 'y' ? arrowOffsetParent.clientTop || 0 : arrowOffsetParent.clientLeft || 0 : 0;
    var offsetModifierValue = (_offsetModifierState$ = offsetModifierState == null ? void 0 : offsetModifierState[mainAxis]) != null ? _offsetModifierState$ : 0;
    var tetherMin = offset + minOffset - offsetModifierValue - clientOffset;
    var tetherMax = offset + maxOffset - offsetModifierValue;
    var preventedOffset = within(tether ? math_min(min, tetherMin) : min, offset, tether ? math_max(max, tetherMax) : max);
    popperOffsets[mainAxis] = preventedOffset;
    data[mainAxis] = preventedOffset - offset;
  }

  if (checkAltAxis) {
    var _offsetModifierState$2;

    var _mainSide = mainAxis === 'x' ? enums_top : left;

    var _altSide = mainAxis === 'x' ? bottom : right;

    var _offset = popperOffsets[altAxis];

    var _len = altAxis === 'y' ? 'height' : 'width';

    var _min = _offset + overflow[_mainSide];

    var _max = _offset - overflow[_altSide];

    var isOriginSide = [enums_top, left].indexOf(basePlacement) !== -1;

    var _offsetModifierValue = (_offsetModifierState$2 = offsetModifierState == null ? void 0 : offsetModifierState[altAxis]) != null ? _offsetModifierState$2 : 0;

    var _tetherMin = isOriginSide ? _min : _offset - referenceRect[_len] - popperRect[_len] - _offsetModifierValue + normalizedTetherOffsetValue.altAxis;

    var _tetherMax = isOriginSide ? _offset + referenceRect[_len] + popperRect[_len] - _offsetModifierValue - normalizedTetherOffsetValue.altAxis : _max;

    var _preventedOffset = tether && isOriginSide ? withinMaxClamp(_tetherMin, _offset, _tetherMax) : within(tether ? _tetherMin : _min, _offset, tether ? _tetherMax : _max);

    popperOffsets[altAxis] = _preventedOffset;
    data[altAxis] = _preventedOffset - _offset;
  }

  state.modifiersData[name] = data;
} // eslint-disable-next-line import/no-unused-modules


/* harmony default export */ var modifiers_preventOverflow = ({
  name: 'preventOverflow',
  enabled: true,
  phase: 'main',
  fn: preventOverflow,
  requiresIfExists: ['offset']
});
;// ./node_modules/@popperjs/core/lib/modifiers/index.js









;// ./node_modules/@popperjs/core/lib/dom-utils/getHTMLElementScroll.js
function getHTMLElementScroll(element) {
  return {
    scrollLeft: element.scrollLeft,
    scrollTop: element.scrollTop
  };
}
;// ./node_modules/@popperjs/core/lib/dom-utils/getNodeScroll.js




function getNodeScroll(node) {
  if (node === getWindow(node) || !isHTMLElement(node)) {
    return getWindowScroll(node);
  } else {
    return getHTMLElementScroll(node);
  }
}
;// ./node_modules/@popperjs/core/lib/dom-utils/getCompositeRect.js









function isElementScaled(element) {
  var rect = element.getBoundingClientRect();
  var scaleX = round(rect.width) / element.offsetWidth || 1;
  var scaleY = round(rect.height) / element.offsetHeight || 1;
  return scaleX !== 1 || scaleY !== 1;
} // Returns the composite rect of an element relative to its offsetParent.
// Composite means it takes into account transforms as well as layout.


function getCompositeRect(elementOrVirtualElement, offsetParent, isFixed) {
  if (isFixed === void 0) {
    isFixed = false;
  }

  var isOffsetParentAnElement = isHTMLElement(offsetParent);
  var offsetParentIsScaled = isHTMLElement(offsetParent) && isElementScaled(offsetParent);
  var documentElement = getDocumentElement(offsetParent);
  var rect = getBoundingClientRect(elementOrVirtualElement, offsetParentIsScaled, isFixed);
  var scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  var offsets = {
    x: 0,
    y: 0
  };

  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent) !== 'body' || // https://github.com/popperjs/popper-core/issues/1078
    isScrollParent(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }

    if (isHTMLElement(offsetParent)) {
      offsets = getBoundingClientRect(offsetParent, true);
      offsets.x += offsetParent.clientLeft;
      offsets.y += offsetParent.clientTop;
    } else if (documentElement) {
      offsets.x = getWindowScrollBarX(documentElement);
    }
  }

  return {
    x: rect.left + scroll.scrollLeft - offsets.x,
    y: rect.top + scroll.scrollTop - offsets.y,
    width: rect.width,
    height: rect.height
  };
}
;// ./node_modules/@popperjs/core/lib/utils/orderModifiers.js
 // source: https://stackoverflow.com/questions/49875255

function order(modifiers) {
  var map = new Map();
  var visited = new Set();
  var result = [];
  modifiers.forEach(function (modifier) {
    map.set(modifier.name, modifier);
  }); // On visiting object, check for its dependencies and visit them recursively

  function sort(modifier) {
    visited.add(modifier.name);
    var requires = [].concat(modifier.requires || [], modifier.requiresIfExists || []);
    requires.forEach(function (dep) {
      if (!visited.has(dep)) {
        var depModifier = map.get(dep);

        if (depModifier) {
          sort(depModifier);
        }
      }
    });
    result.push(modifier);
  }

  modifiers.forEach(function (modifier) {
    if (!visited.has(modifier.name)) {
      // check for visited object
      sort(modifier);
    }
  });
  return result;
}

function orderModifiers(modifiers) {
  // order based on dependencies
  var orderedModifiers = order(modifiers); // order based on phase

  return modifierPhases.reduce(function (acc, phase) {
    return acc.concat(orderedModifiers.filter(function (modifier) {
      return modifier.phase === phase;
    }));
  }, []);
}
;// ./node_modules/@popperjs/core/lib/utils/debounce.js
function debounce(fn) {
  var pending;
  return function () {
    if (!pending) {
      pending = new Promise(function (resolve) {
        Promise.resolve().then(function () {
          pending = undefined;
          resolve(fn());
        });
      });
    }

    return pending;
  };
}
;// ./node_modules/@popperjs/core/lib/utils/mergeByName.js
function mergeByName(modifiers) {
  var merged = modifiers.reduce(function (merged, current) {
    var existing = merged[current.name];
    merged[current.name] = existing ? Object.assign({}, existing, current, {
      options: Object.assign({}, existing.options, current.options),
      data: Object.assign({}, existing.data, current.data)
    }) : current;
    return merged;
  }, {}); // IE11 does not support Object.values

  return Object.keys(merged).map(function (key) {
    return merged[key];
  });
}
;// ./node_modules/@popperjs/core/lib/createPopper.js









var DEFAULT_OPTIONS = {
  placement: 'bottom',
  modifiers: [],
  strategy: 'absolute'
};

function areValidElements() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }

  return !args.some(function (element) {
    return !(element && typeof element.getBoundingClientRect === 'function');
  });
}

function popperGenerator(generatorOptions) {
  if (generatorOptions === void 0) {
    generatorOptions = {};
  }

  var _generatorOptions = generatorOptions,
      _generatorOptions$def = _generatorOptions.defaultModifiers,
      defaultModifiers = _generatorOptions$def === void 0 ? [] : _generatorOptions$def,
      _generatorOptions$def2 = _generatorOptions.defaultOptions,
      defaultOptions = _generatorOptions$def2 === void 0 ? DEFAULT_OPTIONS : _generatorOptions$def2;
  return function createPopper(reference, popper, options) {
    if (options === void 0) {
      options = defaultOptions;
    }

    var state = {
      placement: 'bottom',
      orderedModifiers: [],
      options: Object.assign({}, DEFAULT_OPTIONS, defaultOptions),
      modifiersData: {},
      elements: {
        reference: reference,
        popper: popper
      },
      attributes: {},
      styles: {}
    };
    var effectCleanupFns = [];
    var isDestroyed = false;
    var instance = {
      state: state,
      setOptions: function setOptions(setOptionsAction) {
        var options = typeof setOptionsAction === 'function' ? setOptionsAction(state.options) : setOptionsAction;
        cleanupModifierEffects();
        state.options = Object.assign({}, defaultOptions, state.options, options);
        state.scrollParents = {
          reference: isElement(reference) ? listScrollParents(reference) : reference.contextElement ? listScrollParents(reference.contextElement) : [],
          popper: listScrollParents(popper)
        }; // Orders the modifiers based on their dependencies and `phase`
        // properties

        var orderedModifiers = orderModifiers(mergeByName([].concat(defaultModifiers, state.options.modifiers))); // Strip out disabled modifiers

        state.orderedModifiers = orderedModifiers.filter(function (m) {
          return m.enabled;
        });
        runModifierEffects();
        return instance.update();
      },
      // Sync update  it will always be executed, even if not necessary. This
      // is useful for low frequency updates where sync behavior simplifies the
      // logic.
      // For high frequency updates (e.g. `resize` and `scroll` events), always
      // prefer the async Popper#update method
      forceUpdate: function forceUpdate() {
        if (isDestroyed) {
          return;
        }

        var _state$elements = state.elements,
            reference = _state$elements.reference,
            popper = _state$elements.popper; // Don't proceed if `reference` or `popper` are not valid elements
        // anymore

        if (!areValidElements(reference, popper)) {
          return;
        } // Store the reference and popper rects to be read by modifiers


        state.rects = {
          reference: getCompositeRect(reference, getOffsetParent(popper), state.options.strategy === 'fixed'),
          popper: getLayoutRect(popper)
        }; // Modifiers have the ability to reset the current update cycle. The
        // most common use case for this is the `flip` modifier changing the
        // placement, which then needs to re-run all the modifiers, because the
        // logic was previously ran for the previous placement and is therefore
        // stale/incorrect

        state.reset = false;
        state.placement = state.options.placement; // On each update cycle, the `modifiersData` property for each modifier
        // is filled with the initial data specified by the modifier. This means
        // it doesn't persist and is fresh on each update.
        // To ensure persistent data, use `${name}#persistent`

        state.orderedModifiers.forEach(function (modifier) {
          return state.modifiersData[modifier.name] = Object.assign({}, modifier.data);
        });

        for (var index = 0; index < state.orderedModifiers.length; index++) {
          if (state.reset === true) {
            state.reset = false;
            index = -1;
            continue;
          }

          var _state$orderedModifie = state.orderedModifiers[index],
              fn = _state$orderedModifie.fn,
              _state$orderedModifie2 = _state$orderedModifie.options,
              _options = _state$orderedModifie2 === void 0 ? {} : _state$orderedModifie2,
              name = _state$orderedModifie.name;

          if (typeof fn === 'function') {
            state = fn({
              state: state,
              options: _options,
              name: name,
              instance: instance
            }) || state;
          }
        }
      },
      // Async and optimistically optimized update  it will not be executed if
      // not necessary (debounced to run at most once-per-tick)
      update: debounce(function () {
        return new Promise(function (resolve) {
          instance.forceUpdate();
          resolve(state);
        });
      }),
      destroy: function destroy() {
        cleanupModifierEffects();
        isDestroyed = true;
      }
    };

    if (!areValidElements(reference, popper)) {
      return instance;
    }

    instance.setOptions(options).then(function (state) {
      if (!isDestroyed && options.onFirstUpdate) {
        options.onFirstUpdate(state);
      }
    }); // Modifiers have the ability to execute arbitrary code before the first
    // update cycle runs. They will be executed in the same order as the update
    // cycle. This is useful when a modifier adds some persistent data that
    // other modifiers need to use, but the modifier is run after the dependent
    // one.

    function runModifierEffects() {
      state.orderedModifiers.forEach(function (_ref) {
        var name = _ref.name,
            _ref$options = _ref.options,
            options = _ref$options === void 0 ? {} : _ref$options,
            effect = _ref.effect;

        if (typeof effect === 'function') {
          var cleanupFn = effect({
            state: state,
            name: name,
            instance: instance,
            options: options
          });

          var noopFn = function noopFn() {};

          effectCleanupFns.push(cleanupFn || noopFn);
        }
      });
    }

    function cleanupModifierEffects() {
      effectCleanupFns.forEach(function (fn) {
        return fn();
      });
      effectCleanupFns = [];
    }

    return instance;
  };
}
var createPopper = /*#__PURE__*/popperGenerator(); // eslint-disable-next-line import/no-unused-modules


;// ./node_modules/@popperjs/core/lib/popper.js










var defaultModifiers = [eventListeners, modifiers_popperOffsets, modifiers_computeStyles, modifiers_applyStyles, modifiers_offset, modifiers_flip, modifiers_preventOverflow, modifiers_arrow, modifiers_hide];
var popper_createPopper = /*#__PURE__*/popperGenerator({
  defaultModifiers: defaultModifiers
}); // eslint-disable-next-line import/no-unused-modules

 // eslint-disable-next-line import/no-unused-modules

 // eslint-disable-next-line import/no-unused-modules


;// ./node_modules/@popperjs/core/lib/popper-lite.js





var popper_lite_defaultModifiers = [eventListeners, modifiers_popperOffsets, modifiers_computeStyles, modifiers_applyStyles];
var popper_lite_createPopper = /*#__PURE__*/popperGenerator({
  defaultModifiers: popper_lite_defaultModifiers
}); // eslint-disable-next-line import/no-unused-modules


;// ./node_modules/@popperjs/core/lib/index.js

 // eslint-disable-next-line import/no-unused-modules

 // eslint-disable-next-line import/no-unused-modules

 // eslint-disable-next-line import/no-unused-modules



/***/ }),

/***/ 3998:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


/**
 * KTUI - Free & Open-Source Tailwind UI Components by Keenthemes
 * Copyright 2025 by Keenthemes Inc
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.KTScrollto = void 0;
var scrollto_1 = __webpack_require__(3840);
Object.defineProperty(exports, "KTScrollto", ({ enumerable: true, get: function () { return scrollto_1.KTScrollto; } }));


/***/ }),

/***/ 4139:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


/**
 * KTUI - Free & Open-Source Tailwind UI Components by Keenthemes
 * Copyright 2025 by Keenthemes Inc
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.KTReparent = void 0;
var reparent_1 = __webpack_require__(642);
Object.defineProperty(exports, "KTReparent", ({ enumerable: true, get: function () { return reparent_1.KTReparent; } }));


/***/ }),

/***/ 4241:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


/**
 * KTUI - Free & Open-Source Tailwind UI Components by Keenthemes
 * Copyright 2025 by Keenthemes Inc
 */
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.KTSelectOption = void 0;
var component_1 = __webpack_require__(2658);
var templates_1 = __webpack_require__(9069);
var KTSelectOption = /** @class */ (function (_super) {
    __extends(KTSelectOption, _super);
    function KTSelectOption(element, config) {
        var _this = _super.call(this) || this;
        _this._name = 'select-option';
        _this._dataOptionPrefix = 'kt-'; // Use 'kt-' prefix to support data-kt-select-option attributes
        // Always initialize a new option instance
        _this._init(element);
        _this._globalConfig = config;
        _this._buildConfig();
        // Clean the config
        _this._config = _this._config[''] || {};
        // Add the option config to the global config
        // Ensure optionsConfig is initialized
        if (_this._globalConfig) {
            _this._globalConfig.optionsConfig = _this._globalConfig.optionsConfig || {};
            _this._globalConfig.optionsConfig[element.value] = _this._config;
            // console.log('[KTSelectOption] Populating _globalConfig.optionsConfig for value', (element as HTMLInputElement).value, 'with:', JSON.parse(JSON.stringify(this._config)));
            // console.log('[KTSelectOption] _globalConfig.optionsConfig is now:', JSON.parse(JSON.stringify(this._globalConfig.optionsConfig)));
        }
        else {
            // Handle case where _globalConfig might be undefined, though constructor expects it.
            // This might indicate a need to ensure config is always passed or has a default.
            console.warn('KTSelectOption: _globalConfig is undefined during constructor.');
        }
        // Don't store in KTData to avoid Singleton pattern issues
        // Each option should be a unique instance
        element.instance = _this;
        return _this;
    }
    Object.defineProperty(KTSelectOption.prototype, "id", {
        get: function () {
            return this.getHTMLOptionElement().value;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(KTSelectOption.prototype, "title", {
        get: function () {
            return this.getHTMLOptionElement().textContent || '';
        },
        enumerable: false,
        configurable: true
    });
    KTSelectOption.prototype.getHTMLOptionElement = function () {
        return this._element;
    };
    /**
     * Gathers all necessary data for rendering this option,
     * including standard HTML attributes and custom data-kt-* attributes.
     */
    KTSelectOption.prototype.getOptionDataForTemplate = function () {
        var el = this.getHTMLOptionElement();
        var text = el.textContent || '';
        return __assign(__assign({}, this._config), { 
            // Standard HTMLOptionElement properties
            value: el.value, text: text, selected: el.selected, disabled: el.disabled, 
            // Provide 'content' for convenience in templates, defaulting to text.
            // User's optionTemplate can then use {{content}} or specific fields like {{text}}, {{icon}}, etc.
            content: text });
    };
    KTSelectOption.prototype.render = function () {
        // 'this' is the KTSelectOption instance.
        // defaultTemplates.option will handle using this instance's data along with _globalConfig.
        return templates_1.defaultTemplates.option(this, this._globalConfig);
    };
    return KTSelectOption;
}(component_1.default));
exports.KTSelectOption = KTSelectOption;


/***/ }),

/***/ 4592:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


/**
 * KTUI - Free & Open-Source Tailwind UI Components by Keenthemes
 * Copyright 2025 by Keenthemes Inc
 */
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.KTThemeSwitch = void 0;
/* eslint-disable max-len */
/* eslint-disable require-jsdoc */
var data_1 = __webpack_require__(8716);
var event_handler_1 = __webpack_require__(5183);
var component_1 = __webpack_require__(2658);
var KTThemeSwitch = /** @class */ (function (_super) {
    __extends(KTThemeSwitch, _super);
    function KTThemeSwitch(element, config) {
        if (config === void 0) { config = null; }
        var _this = _super.call(this) || this;
        _this._name = 'theme-swtich';
        _this._defaultConfig = {
            mode: 'light',
        };
        _this._mode = null;
        _this._currentMode = null;
        if (data_1.default.has(element, _this._name))
            return _this;
        _this._init(element);
        _this._buildConfig(config);
        _this._setMode((localStorage.getItem('kt-theme') ||
            _this._getOption('mode')));
        _this._handlers();
        return _this;
    }
    KTThemeSwitch.prototype._handlers = function () {
        var _this = this;
        if (!this._element)
            return;
        event_handler_1.default.on(document.body, '[data-kt-theme-switch-toggle]', 'click', function () {
            _this._toggle();
        });
        event_handler_1.default.on(document.body, '[data-kt-theme-switch-set]', 'click', function (event, target) {
            event.preventDefault();
            var mode = target.getAttribute('data-kt-theme-switch-set');
            _this._setMode(mode);
        });
    };
    KTThemeSwitch.prototype._toggle = function () {
        var mode = this._currentMode === 'light' ? 'dark' : 'light';
        this._setMode(mode);
    };
    KTThemeSwitch.prototype._setMode = function (mode) {
        if (!this._element)
            return;
        var payload = { cancel: false };
        this._fireEvent('change', payload);
        this._dispatchEvent('change', payload);
        if (payload.cancel === true) {
            return;
        }
        var currentMode = mode;
        if (mode === 'system') {
            currentMode = this._getSystemMode();
        }
        this._mode = mode;
        this._currentMode = currentMode;
        this._bindMode();
        this._updateState();
        localStorage.setItem('kt-theme', this._mode);
        this._element.setAttribute('data-kt-theme-switch-mode', mode);
        this._fireEvent('changed', {});
        this._dispatchEvent('changed', {});
    };
    KTThemeSwitch.prototype._getMode = function () {
        return (localStorage.getItem('kt-theme') || this._mode);
    };
    KTThemeSwitch.prototype._getSystemMode = function () {
        return window.matchMedia('(prefers-color-scheme: dark)').matches
            ? 'dark'
            : 'light';
    };
    KTThemeSwitch.prototype._bindMode = function () {
        if (!this._currentMode || !this._element) {
            return;
        }
        this._element.classList.remove('dark');
        this._element.classList.remove('light');
        this._element.removeAttribute(this._getOption('attribute'));
        this._element.classList.add(this._currentMode);
    };
    KTThemeSwitch.prototype._updateState = function () {
        var _this = this;
        var elements = document.querySelectorAll('input[type="checkbox"][data-kt-theme-switch-state]');
        elements.forEach(function (element) {
            if (element.getAttribute('data-kt-theme-switch-state') === _this._mode) {
                element.checked = true;
            }
        });
    };
    KTThemeSwitch.prototype.getMode = function () {
        return this._getMode();
    };
    KTThemeSwitch.prototype.setMode = function (mode) {
        this.setMode(mode);
    };
    KTThemeSwitch.getInstance = function () {
        var root = document.documentElement;
        if (data_1.default.has(root, 'theme-switch')) {
            return data_1.default.get(root, 'theme-switch');
        }
        if (root) {
            return new KTThemeSwitch(root);
        }
        return null;
    };
    KTThemeSwitch.createInstances = function () {
        var root = document.documentElement;
        if (root)
            new KTThemeSwitch(root);
    };
    KTThemeSwitch.init = function () {
        KTThemeSwitch.createInstances();
    };
    return KTThemeSwitch;
}(component_1.default));
exports.KTThemeSwitch = KTThemeSwitch;
if (typeof window !== 'undefined') {
    window.KTThemeSwitch = KTThemeSwitch;
}


/***/ }),

/***/ 4850:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


/**
 * KTUI - Free & Open-Source Tailwind UI Components by Keenthemes
 * Copyright 2025 by Keenthemes Inc
 */
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.KTScrollable = void 0;
var data_1 = __webpack_require__(8716);
var dom_1 = __webpack_require__(9010);
var utils_1 = __webpack_require__(2599);
var component_1 = __webpack_require__(2658);
var KTScrollable = /** @class */ (function (_super) {
    __extends(KTScrollable, _super);
    function KTScrollable(element, config) {
        var _this = _super.call(this) || this;
        _this._name = 'scrollable';
        _this._defaultConfig = {
            save: true,
            dependencies: '',
            wrappers: '',
            offset: '',
        };
        _this._config = _this._defaultConfig;
        _this._elementId = null;
        if (data_1.default.has(element, _this._name))
            return _this;
        _this._init(element);
        _this._buildConfig(config);
        if (!_this._element)
            return _this;
        _this._elementId = _this._element.getAttribute('id');
        _this._handlers();
        _this._update();
        return _this;
    }
    KTScrollable.prototype._handlers = function () {
        var _this = this;
        if (!this._element)
            return;
        this._element.addEventListener('scroll', function () {
            if (!_this._element)
                return;
            localStorage.setItem("".concat(_this._elementId, "st"), _this._element.scrollTop.toString());
        });
    };
    KTScrollable.prototype._update = function () {
        this._setupHeight();
        this._setupState();
    };
    KTScrollable.prototype._setupHeight = function () {
        if (!this._element)
            return;
        var heightType = this._getHeightType();
        var height = this._getHeight();
        // Set height
        if (height && height != '0' && height.length > 0) {
            this._element.style.setProperty(heightType, height);
        }
        else {
            this._element.style.setProperty(heightType, '');
        }
    };
    KTScrollable.prototype._setupState = function () {
        if (!this._element)
            return;
        var stateEnabled = this._getOption('state') === true;
        var elementIdExists = Boolean(this._elementId);
        if (stateEnabled && elementIdExists) {
            var storedPosition = localStorage.getItem(this._elementId + 'st');
            if (storedPosition) {
                var pos = parseInt(storedPosition);
                if (pos > 0) {
                    this._element.scroll({
                        top: pos,
                        behavior: 'instant',
                    });
                }
            }
        }
    };
    KTScrollable.prototype._getHeight = function () {
        var height = this._getHeightOption();
        if (height !== null &&
            typeof height === 'string' &&
            height.toLowerCase() === 'auto') {
            return this._getAutoHeight();
        }
        else if (height) {
            return parseInt(height).toString() + 'px';
        }
        else {
            return '0';
        }
    };
    KTScrollable.prototype._getAutoHeight = function () {
        var _this = this;
        if (!this._element)
            return '';
        var height = dom_1.default.getViewPort().height;
        var dependencies = this._getOption('dependencies');
        var wrappers = this._getOption('wrappers');
        var offset = this._getOption('offset');
        height -= this._getElementSpacing(this._element);
        if (dependencies && dependencies.length > 0) {
            var elements = document.querySelectorAll(dependencies);
            elements.forEach(function (element) {
                if (dom_1.default.getCssProp(element, 'display') === 'none') {
                    return;
                }
                height -= _this._getElementHeight(element);
            });
        }
        if (wrappers && wrappers.length > 0) {
            var elements = document.querySelectorAll(wrappers);
            elements.forEach(function (element) {
                if (dom_1.default.getCssProp(element, 'display') === 'none') {
                    return;
                }
                height -= _this._getElementSpacing(element);
            });
        }
        if (offset && offset.length > 0) {
            height -= parseInt(offset);
        }
        return height.toString() + 'px';
    };
    KTScrollable.prototype._getElementHeight = function (element) {
        var height = 0;
        if (!element) {
            return height;
        }
        var computedStyle = window.getComputedStyle(element);
        if (computedStyle.height) {
            height += parseInt(computedStyle.height);
        }
        if (computedStyle.marginTop) {
            height += parseInt(computedStyle.marginTop);
        }
        if (computedStyle.marginBottom) {
            height += parseInt(computedStyle.marginBottom);
        }
        if (computedStyle.borderTopWidth) {
            height += parseInt(computedStyle.borderTopWidth);
        }
        if (computedStyle.borderBottomWidth) {
            height += parseInt(computedStyle.borderBottomWidth);
        }
        return height;
    };
    KTScrollable.prototype._getElementSpacing = function (element) {
        var spacing = 0;
        if (!element) {
            return spacing;
        }
        var computedStyle = window.getComputedStyle(element);
        if (computedStyle.marginTop) {
            spacing += parseInt(computedStyle.marginTop);
        }
        if (computedStyle.marginBottom) {
            spacing += parseInt(computedStyle.marginBottom);
        }
        if (computedStyle.paddingTop) {
            spacing += parseInt(computedStyle.paddingTop);
        }
        if (computedStyle.paddingBottom) {
            spacing += parseInt(computedStyle.paddingBottom);
        }
        if (computedStyle.borderTopWidth) {
            spacing += parseInt(computedStyle.borderTopWidth);
        }
        if (computedStyle.borderBottomWidth) {
            spacing += parseInt(computedStyle.borderBottomWidth);
        }
        return spacing;
    };
    KTScrollable.prototype._getHeightType = function () {
        if (this._getOption('minHeight')) {
            return 'min-height';
        }
        if (this._getOption('maxHeight')) {
            return 'max-height';
        }
        else {
            return 'height';
        }
    };
    KTScrollable.prototype._getHeightOption = function () {
        var heightType = this._getHeightType();
        if (heightType == 'min-height') {
            return this._getOption('minHeight');
        }
        if (heightType == 'max-height') {
            return this._getOption('maxHeight');
        }
        else {
            return this._getOption('height');
        }
    };
    KTScrollable.prototype.update = function () {
        return this._update();
    };
    KTScrollable.prototype.getHeight = function () {
        return this._getHeight();
    };
    KTScrollable.getInstance = function (element) {
        if (!element)
            return null;
        if (data_1.default.has(element, 'scrollable')) {
            return data_1.default.get(element, 'scrollable');
        }
        if (element.getAttribute('data-kt-scrollable')) {
            return new KTScrollable(element);
        }
        return null;
    };
    KTScrollable.getOrCreateInstance = function (element, config) {
        return this.getInstance(element) || new KTScrollable(element, config);
    };
    KTScrollable.createInstances = function () {
        var elements = document.querySelectorAll('[data-kt-scrollable]');
        elements.forEach(function (element) {
            new KTScrollable(element);
        });
    };
    KTScrollable.handleResize = function () {
        window.addEventListener('resize', function () {
            var timer;
            utils_1.default.throttle(timer, function () {
                // Locate and update scrollable instances on window resize
                var elements = document.querySelectorAll('[data-kt-scrollable-initialized]');
                elements.forEach(function (element) {
                    var _a;
                    (_a = KTScrollable.getInstance(element)) === null || _a === void 0 ? void 0 : _a.update();
                });
            }, 200);
        });
    };
    KTScrollable.init = function () {
        KTScrollable.createInstances();
        if (window.KT_SCROLLABLE_INITIALIZED !== true) {
            KTScrollable.handleResize();
            window.KT_SCROLLABLE_INITIALIZED = true;
        }
    };
    return KTScrollable;
}(component_1.default));
exports.KTScrollable = KTScrollable;
if (typeof window !== 'undefined') {
    window.KTScrollable = KTScrollable;
}


/***/ }),

/***/ 5071:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


/**
 * KTUI - Free & Open-Source Tailwind UI Components by Keenthemes
 * Copyright 2025 by Keenthemes Inc
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.KTDropdown = void 0;
var dropdown_1 = __webpack_require__(8474);
Object.defineProperty(exports, "KTDropdown", ({ enumerable: true, get: function () { return dropdown_1.KTDropdown; } }));


/***/ }),

/***/ 5116:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


/**
 * KTUI - Free & Open-Source Tailwind UI Components by Keenthemes
 * Copyright 2025 by Keenthemes Inc
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DatepickerTypes = exports.KTDatepicker = void 0;
var datepicker_1 = __webpack_require__(7952);
Object.defineProperty(exports, "KTDatepicker", ({ enumerable: true, get: function () { return datepicker_1.KTDatepicker; } }));
var DatepickerTypes = __webpack_require__(1069);
exports.DatepickerTypes = DatepickerTypes;
exports["default"] = datepicker_1.KTDatepicker;


/***/ }),

/***/ 5183:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


/**
 * KTUI - Free & Open-Source Tailwind UI Components by Keenthemes
 * Copyright 2025 by Keenthemes Inc
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
var utils_1 = __webpack_require__(2599);
var KTDelegatedEventHandlers = {};
var KTEventHandler = {
    on: function (element, selector, eventName, handler) {
        var _this = this;
        if (element === null) {
            return null;
        }
        var eventId = utils_1.default.geUID('event');
        KTDelegatedEventHandlers[eventId] = function (event) {
            var targets = element.querySelectorAll(selector);
            var target = event.target;
            while (target && target !== element) {
                for (var i = 0, j = targets.length; i < j; i++) {
                    if (target === targets[i]) {
                        handler.call(_this, event, target);
                    }
                }
                target = target.parentNode;
            }
        };
        element.addEventListener(eventName, KTDelegatedEventHandlers[eventId]);
        return eventId;
    },
    off: function (element, eventName, eventId) {
        if (!element || KTDelegatedEventHandlers[eventId] === null) {
            return;
        }
        element.removeEventListener(eventName, KTDelegatedEventHandlers[eventId]);
        delete KTDelegatedEventHandlers[eventId];
    },
};
exports["default"] = KTEventHandler;


/***/ }),

/***/ 5194:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


/**
 * KTUI - Free & Open-Source Tailwind UI Components by Keenthemes
 * Copyright 2025 by Keenthemes Inc
 */
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.KTAccordion = void 0;
var data_1 = __webpack_require__(8716);
var dom_1 = __webpack_require__(9010);
var event_handler_1 = __webpack_require__(5183);
var component_1 = __webpack_require__(2658);
var KTAccordion = /** @class */ (function (_super) {
    __extends(KTAccordion, _super);
    function KTAccordion(element, config) {
        var _this = _super.call(this) || this;
        _this._name = 'accordion';
        _this._defaultConfig = {
            hiddenClass: 'hidden',
            activeClass: 'active',
            expandAll: false,
        };
        _this._config = _this._defaultConfig;
        if (data_1.default.has(element, _this._name))
            return _this;
        _this._init(element);
        _this._buildConfig(config);
        _this._handlers();
        return _this;
    }
    KTAccordion.prototype._handlers = function () {
        var _this = this;
        event_handler_1.default.on(this._element, '[data-kt-accordion-toggle]', 'click', function (event, target) {
            event.preventDefault();
            var accordionElement = target.closest('[data-kt-accordion-item]');
            if (accordionElement)
                _this._toggle(accordionElement);
        });
    };
    KTAccordion.prototype._toggle = function (accordionElement) {
        var payload = { cancel: false };
        this._fireEvent('toggle', payload);
        this._dispatchEvent('toggle', payload);
        if (payload.cancel === true) {
            return;
        }
        if (accordionElement.classList.contains('active')) {
            this._hide(accordionElement);
        }
        else {
            this._show(accordionElement);
        }
    };
    KTAccordion.prototype._show = function (accordionElement) {
        var _this = this;
        if (accordionElement.hasAttribute('animating') ||
            accordionElement.classList.contains(this._getOption('activeClass')))
            return;
        var toggleElement = dom_1.default.child(accordionElement, '[data-kt-accordion-toggle]');
        if (!toggleElement)
            return;
        var contentElement = dom_1.default.getElement("#".concat(toggleElement.getAttribute('aria-controls')));
        if (!contentElement)
            return;
        var payload = { cancel: false };
        this._fireEvent('show', payload);
        this._dispatchEvent('show', payload);
        if (payload.cancel === true) {
            return;
        }
        if (this._getOption('expandAll') === false) {
            this._hideSiblings(accordionElement);
        }
        accordionElement.setAttribute('aria-expanded', 'true');
        accordionElement.classList.add(this._getOption('activeClass'));
        accordionElement.setAttribute('animating', 'true');
        contentElement.classList.remove(this._getOption('hiddenClass'));
        contentElement.style.height = "0px";
        dom_1.default.reflow(contentElement);
        contentElement.style.height = "".concat(contentElement.scrollHeight, "px");
        dom_1.default.transitionEnd(contentElement, function () {
            accordionElement.removeAttribute('animating');
            contentElement.style.height = '';
            _this._fireEvent('shown');
            _this._dispatchEvent('shown');
        });
    };
    KTAccordion.prototype._hide = function (accordionElement) {
        var _this = this;
        if (accordionElement.hasAttribute('animating') ||
            !accordionElement.classList.contains(this._getOption('activeClass')))
            return;
        var toggleElement = dom_1.default.child(accordionElement, '[data-kt-accordion-toggle]');
        if (!toggleElement)
            return;
        var contentElement = dom_1.default.getElement("#".concat(toggleElement.getAttribute('aria-controls')));
        if (!contentElement)
            return;
        var payload = { cancel: false };
        this._fireEvent('hide', payload);
        this._dispatchEvent('hide', payload);
        if (payload.cancel === true) {
            return;
        }
        accordionElement.setAttribute('aria-expanded', 'false');
        contentElement.style.height = "".concat(contentElement.scrollHeight, "px");
        dom_1.default.reflow(contentElement);
        contentElement.style.height = '0px';
        accordionElement.setAttribute('animating', 'true');
        dom_1.default.transitionEnd(contentElement, function () {
            accordionElement.removeAttribute('animating');
            accordionElement.classList.remove(_this._getOption('activeClass'));
            contentElement.classList.add(_this._getOption('hiddenClass'));
            _this._fireEvent('hidden');
            _this._dispatchEvent('hidden');
        });
    };
    KTAccordion.prototype._hideSiblings = function (accordionElement) {
        var _this = this;
        var siblings = dom_1.default.siblings(accordionElement);
        siblings === null || siblings === void 0 ? void 0 : siblings.forEach(function (sibling) {
            _this._hide(sibling);
        });
    };
    KTAccordion.prototype.show = function (accordionElement) {
        this._show(accordionElement);
    };
    KTAccordion.prototype.hide = function (accordionElement) {
        this._hide(accordionElement);
    };
    KTAccordion.prototype.toggle = function (accordionElement) {
        this._toggle(accordionElement);
    };
    KTAccordion.getInstance = function (element) {
        if (!element)
            return null;
        if (data_1.default.has(element, 'accordion')) {
            return data_1.default.get(element, 'accordion');
        }
        if (element.getAttribute('data-kt-accordion-initialized') === 'true') {
            return new KTAccordion(element);
        }
        return null;
    };
    KTAccordion.getOrCreateInstance = function (element, config) {
        return this.getInstance(element) || new KTAccordion(element, config);
    };
    KTAccordion.createInstances = function () {
        var elements = document.querySelectorAll('[data-kt-accordion]');
        elements.forEach(function (element) {
            new KTAccordion(element);
        });
    };
    KTAccordion.init = function () {
        KTAccordion.createInstances();
    };
    return KTAccordion;
}(component_1.default));
exports.KTAccordion = KTAccordion;
if (typeof window !== 'undefined') {
    window.KTAccordion = KTAccordion;
}


/***/ }),

/***/ 5199:
/***/ (function(__unused_webpack_module, exports) {


/**
 * KTUI - Free & Open-Source Tailwind UI Components by Keenthemes
 * Copyright 2025 by Keenthemes Inc
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.createSortHandler = createSortHandler;
function createSortHandler(config, theadElement, getState, setState, fireEvent, dispatchEvent, updateData) {
    // Helper to compare values for sorting
    function compareValues(a, b, sortOrder) {
        var aText = String(a).replace(/<[^>]*>|&nbsp;/g, '');
        var bText = String(b).replace(/<[^>]*>|&nbsp;/g, '');
        return aText > bText
            ? sortOrder === 'asc'
                ? 1
                : -1
            : aText < bText
                ? sortOrder === 'asc'
                    ? -1
                    : 1
                : 0;
    }
    function sortData(data, sortField, sortOrder) {
        return data.sort(function (a, b) {
            var aValue = a[sortField];
            var bValue = b[sortField];
            return compareValues(aValue, bValue, sortOrder);
        });
    }
    function toggleSortOrder(currentField, currentOrder, newField) {
        if (currentField === newField) {
            switch (currentOrder) {
                case 'asc':
                    return 'desc';
                case 'desc':
                    return '';
                default:
                    return 'asc';
            }
        }
        return 'asc';
    }
    function setSortIcon(sortField, sortOrder) {
        var _a, _b, _c, _d, _e, _f, _g, _h;
        var sortClass = sortOrder
            ? sortOrder === 'asc'
                ? ((_b = (_a = config.sort) === null || _a === void 0 ? void 0 : _a.classes) === null || _b === void 0 ? void 0 : _b.asc) || ''
                : ((_d = (_c = config.sort) === null || _c === void 0 ? void 0 : _c.classes) === null || _d === void 0 ? void 0 : _d.desc) || ''
            : '';
        var th = typeof sortField === 'number'
            ? theadElement.querySelectorAll('th')[sortField]
            : theadElement.querySelector("th[data-kt-datatable-column=\"".concat(String(sortField), "\"], th[data-kt-datatable-column-sort=\"").concat(String(sortField), "\"]"));
        if (th) {
            var sortElement = th.querySelector(".".concat((_f = (_e = config.sort) === null || _e === void 0 ? void 0 : _e.classes) === null || _f === void 0 ? void 0 : _f.base));
            if (sortElement) {
                sortElement.className =
                    "".concat((_h = (_g = config.sort) === null || _g === void 0 ? void 0 : _g.classes) === null || _h === void 0 ? void 0 : _h.base, " ").concat(sortClass).trim();
            }
        }
    }
    function initSort() {
        if (!theadElement)
            return;
        // Set the initial sort icon
        setSortIcon(getState().sortField, getState().sortOrder);
        // Get all the table headers
        var headers = Array.from(theadElement.querySelectorAll('th'));
        headers.forEach(function (header) {
            var _a, _b;
            // If the sort class is not found, it's not a sortable column
            if (!header.querySelector(".".concat((_b = (_a = config.sort) === null || _a === void 0 ? void 0 : _a.classes) === null || _b === void 0 ? void 0 : _b.base)))
                return;
            var sortAttribute = header.getAttribute('data-kt-datatable-column-sort') ||
                header.getAttribute('data-kt-datatable-column');
            var sortField = sortAttribute
                ? sortAttribute
                : header.cellIndex;
            header.addEventListener('click', function () {
                var state = getState();
                var sortOrder = toggleSortOrder(state.sortField, state.sortOrder, sortField);
                setSortIcon(sortField, sortOrder);
                setState(sortField, sortOrder);
                fireEvent('sort', { field: sortField, order: sortOrder });
                dispatchEvent('sort', { field: sortField, order: sortOrder });
                updateData();
            });
        });
    }
    return { initSort: initSort, sortData: sortData, toggleSortOrder: toggleSortOrder, setSortIcon: setSortIcon };
}


/***/ }),

/***/ 5251:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


/**
 * KTUI - Free & Open-Source Tailwind UI Components by Keenthemes
 * Copyright 2025 by Keenthemes Inc
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.KTScrollspy = void 0;
var scrollspy_1 = __webpack_require__(9742);
Object.defineProperty(exports, "KTScrollspy", ({ enumerable: true, get: function () { return scrollspy_1.KTScrollspy; } }));


/***/ }),

/***/ 5539:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


/**
 * KTUI - Free & Open-Source Tailwind UI Components by Keenthemes
 * Copyright 2025 by Keenthemes Inc
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.KTSelectCombobox = void 0;
var utils_1 = __webpack_require__(9011);
var templates_1 = __webpack_require__(9069);
/**
 * KTSelectCombobox - Handles combobox-specific functionality for KTSelect
 */
var KTSelectCombobox = /** @class */ (function () {
    function KTSelectCombobox(select) {
        var _this = this;
        this._select = select;
        this._config = select.getConfig();
        var displayElement = select.getDisplayElement(); // KTSelect's main display element for combobox
        this._searchInputElement = displayElement.querySelector('input[data-kt-select-search]');
        this._clearButtonElement = displayElement.querySelector('[data-kt-select-clear-button]');
        this._valuesContainerElement = displayElement.querySelector('[data-kt-select-combobox-values]');
        this._boundInputHandler = this._handleComboboxInput.bind(this);
        this._boundClearHandler = this._handleClearButtonClick.bind(this);
        this._attachEventListeners();
        this._select.getElement().addEventListener('dropdown.close', function () {
            // When dropdown closes, if not multi-select and not using displayTemplate,
            // ensure input shows the selected value or placeholder.
            if (!_this._config.multiple && !_this._config.displayTemplate) {
                _this.updateDisplay(_this._select.getSelectedOptions());
            }
            else {
                // For tags or displayTemplate, the input should be clear for typing.
                _this._searchInputElement.value = '';
            }
            _this._toggleClearButtonVisibility(_this._searchInputElement.value);
            // this._select.showAllOptions(); // showAllOptions might be too broad, filtering is managed by typing.
        });
        if (this._config.debug)
            console.log('KTSelectCombobox initialized');
    }
    /**
     * Attach event listeners specific to combobox
     */
    KTSelectCombobox.prototype._attachEventListeners = function () {
        this._removeEventListeners();
        if (this._searchInputElement) { // Ensure element exists
            this._searchInputElement.addEventListener('input', this._boundInputHandler);
        }
        if (this._clearButtonElement) {
            this._clearButtonElement.addEventListener('click', this._boundClearHandler);
        }
    };
    /**
     * Remove event listeners to prevent memory leaks or duplicates
     */
    KTSelectCombobox.prototype._removeEventListeners = function () {
        if (this._searchInputElement) {
            this._searchInputElement.removeEventListener('input', this._boundInputHandler);
        }
        if (this._clearButtonElement) {
            this._clearButtonElement.removeEventListener('click', this._boundClearHandler);
        }
    };
    /**
     * Handle combobox input events
     */
    KTSelectCombobox.prototype._handleComboboxInput = function (event) {
        var inputElement = event.target;
        var query = inputElement.value;
        this._toggleClearButtonVisibility(query);
        if (!this._select.isDropdownOpen()) { // Use public getter
            this._select.openDropdown();
        }
        // For single select without displayTemplate, if user types, they are essentially clearing the previous selection text
        // The actual selection state isn't cleared until they pick a new option or clear explicitly.
        // For multi-select or with displayTemplate, the input is purely for search.
        if (this._config.multiple || this._config.displayTemplate) {
            // Values are in _valuesContainerElement, input is for search
        }
        else {
            // Single select, no displayTemplate: If user types, it implies they might be changing selection.
            // We don't clear the actual _select state here, just the visual in input.
        }
        this._filterOptionsForCombobox(query);
    };
    /**
     * Handle clear button click
     */
    KTSelectCombobox.prototype._handleClearButtonClick = function (event) {
        event.preventDefault();
        event.stopPropagation();
        this._searchInputElement.value = '';
        this._toggleClearButtonVisibility('');
        if (this._valuesContainerElement) {
            this._valuesContainerElement.innerHTML = '';
        }
        this._select.clearSelection(); // This will also trigger updateSelectedOptionDisplay
        this._select.showAllOptions(); // Show all options after clearing
        this._select.openDropdown();
        this._searchInputElement.focus();
    };
    /**
     * Toggle clear button visibility based on input value and selection state.
     * Clear button should be visible if there's text in input OR if there are selected items (for multi/displayTemplate modes).
     */
    KTSelectCombobox.prototype._toggleClearButtonVisibility = function (inputValue) {
        if (!this._clearButtonElement)
            return;
        var hasSelectedItems = this._select.getSelectedOptions().length > 0;
        if (inputValue.length > 0 || (hasSelectedItems && (this._config.multiple || this._config.displayTemplate))) {
            this._clearButtonElement.classList.remove('hidden');
        }
        else {
            this._clearButtonElement.classList.add('hidden');
        }
    };
    /**
     * Filter options for combobox based on input query
     */
    KTSelectCombobox.prototype._filterOptionsForCombobox = function (query) {
        var options = Array.from(this._select.getOptionsElement());
        var config = this._select.getConfig();
        var dropdownElement = this._select.getDropdownElement();
        (0, utils_1.filterOptions)(options, query, config, dropdownElement);
        // After filtering, focusManager in KTSelectSearch (if search is also enabled there)
        // or the main FocusManager should adjust focus if needed.
        // For combobox, this filtering is the primary search mechanism.
        // We might need to tell select's focus manager to focus first option.
        this._select._focusManager.focusFirst(); // Consider if this is always right
    };
    /**
     * Updates the combobox display (input field or values container) based on selection.
     */
    KTSelectCombobox.prototype.updateDisplay = function (selectedOptions) {
        var _this = this;
        if (!this._searchInputElement)
            return;
        // Always clear the values container first if it exists
        if (this._valuesContainerElement) {
            this._valuesContainerElement.innerHTML = '';
        }
        if (this._config.tags && this._valuesContainerElement) { // Combobox + Tags
            selectedOptions.forEach(function (value) {
                // Ensure value is properly escaped for querySelector
                var optionElement = _this._select.getElement().querySelector("option[value=\"".concat(CSS.escape(value), "\"]"));
                if (optionElement) {
                    var tagElement = templates_1.defaultTemplates.tag(optionElement, _this._config);
                    _this._valuesContainerElement.appendChild(tagElement);
                }
            });
            this._searchInputElement.value = ''; // Input field is for typing new searches
            this._searchInputElement.placeholder = selectedOptions.length > 0 ? '' : (this._config.placeholder || 'Select...');
        }
        else if (this._config.displayTemplate && this._valuesContainerElement) { // Combobox + DisplayTemplate (no tags)
            this._valuesContainerElement.innerHTML = this._select.renderDisplayTemplateForSelected(selectedOptions);
            this._searchInputElement.value = ''; // Input field is for typing new searches
            this._searchInputElement.placeholder = selectedOptions.length > 0 ? '' : (this._config.placeholder || 'Select...');
        }
        else if (this._config.multiple && this._valuesContainerElement) { // Combobox + Multiple (no tags, no display template)
            // For simplicity, join text. A proper tag implementation would be more complex here.
            this._valuesContainerElement.innerHTML = selectedOptions.map(function (value) {
                var optionEl = _this._select.getElement().querySelector("option[value=\"".concat(CSS.escape(value), "\"]"));
                return optionEl ? optionEl.textContent : '';
            }).join(', '); // Basic comma separation
            this._searchInputElement.value = '';
            this._searchInputElement.placeholder = selectedOptions.length > 0 ? '' : (this._config.placeholder || 'Select...');
        }
        else if (!this._config.multiple && selectedOptions.length > 0) { // Single select combobox: display selected option's text in the input
            var selectedValue = selectedOptions[0];
            var optionElement = this._select.getElement().querySelector("option[value=\"".concat(CSS.escape(selectedValue), "\"]"));
            this._searchInputElement.value = optionElement ? optionElement.textContent || '' : '';
            // placeholder is implicitly handled by input value for single select
        }
        else { // No selection or not fitting above categories (e.g. single select, no items)
            this._searchInputElement.value = '';
            this._searchInputElement.placeholder = this._config.placeholder || 'Select...';
            // _valuesContainerElement is already cleared if it exists
        }
        this._toggleClearButtonVisibility(this._searchInputElement.value);
    };
    /**
     * Destroy the combobox component and clean up event listeners
     */
    KTSelectCombobox.prototype.destroy = function () {
        this._removeEventListeners();
    };
    return KTSelectCombobox;
}());
exports.KTSelectCombobox = KTSelectCombobox;


/***/ }),

/***/ 5562:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


/**
 * KTUI - Free & Open-Source Tailwind UI Components by Keenthemes
 * Copyright 2025 by Keenthemes Inc
 */
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.createCheckboxHandler = createCheckboxHandler;
var event_handler_1 = __webpack_require__(5183);
// Main function to create checkbox logic for a datatable instance
function createCheckboxHandler(element, config, fireEvent) {
    var _a;
    var headerChecked = false;
    var headerCheckElement = null;
    var targetElements = null;
    // Default: preserve selection across all pages
    var preserveSelection = ((_a = config.checkbox) === null || _a === void 0 ? void 0 : _a.preserveSelection) !== false;
    // Helper: get selectedRows from state, always as string[]
    function getSelectedRows() {
        if (!config._state)
            config._state = {};
        if (!Array.isArray(config._state.selectedRows))
            config._state.selectedRows = [];
        return config._state.selectedRows.map(String);
    }
    // Helper: set selectedRows in state
    function setSelectedRows(rows) {
        if (!config._state)
            config._state = {};
        config._state.selectedRows = Array.from(new Set(rows.map(String)));
    }
    // Helper: get all visible row IDs (values)
    function getVisibleRowIds() {
        if (!targetElements)
            return [];
        return Array.from(targetElements)
            .map(function (el) { return el.value; })
            .filter(function (v) { return v != null && v !== ''; });
    }
    // Listener for header checkbox
    var checkboxListener = function (event) {
        checkboxToggle(event);
    };
    function init() {
        headerCheckElement = element.querySelector(config.attributes.check);
        if (!headerCheckElement)
            return;
        headerChecked = headerCheckElement.checked;
        targetElements = element.querySelectorAll(config.attributes.checkbox);
        checkboxHandler();
        reapplyCheckedStates();
        updateHeaderCheckboxState();
    }
    function checkboxHandler() {
        if (!headerCheckElement)
            return;
        headerCheckElement.addEventListener('click', checkboxListener);
        event_handler_1.default.on(document.body, config.attributes.checkbox, 'input', function (event) {
            handleRowCheckboxChange(event);
        });
    }
    // When a row checkbox is changed
    function handleRowCheckboxChange(event) {
        var input = event.target;
        if (!input)
            return;
        var value = input.value;
        var selectedRows = getSelectedRows();
        if (input.checked) {
            if (!selectedRows.includes(value))
                selectedRows.push(value);
        }
        else {
            selectedRows = selectedRows.filter(function (v) { return v !== value; });
        }
        setSelectedRows(selectedRows);
        updateHeaderCheckboxState();
        fireEvent('changed');
    }
    // When the header checkbox is toggled
    function checkboxToggle(event) {
        var checked = !isChecked();
        var eventType = checked ? 'checked' : 'unchecked';
        fireEvent(eventType);
        change(checked);
    }
    // Change all visible checkboxes and update selectedRows
    function change(checked) {
        var payload = { cancel: false };
        fireEvent('change', payload);
        if (payload.cancel === true)
            return;
        headerChecked = checked;
        if (headerCheckElement)
            headerCheckElement.checked = checked;
        if (targetElements) {
            var visibleIds_1 = getVisibleRowIds();
            var selectedRows = getSelectedRows();
            if (checked) {
                // Add all visible IDs to selectedRows
                selectedRows = preserveSelection
                    ? Array.from(new Set(__spreadArray(__spreadArray([], selectedRows, true), visibleIds_1, true)))
                    : visibleIds_1;
            }
            else {
                // Remove all visible IDs from selectedRows
                selectedRows = preserveSelection
                    ? selectedRows.filter(function (v) { return !visibleIds_1.includes(v); })
                    : [];
            }
            setSelectedRows(selectedRows);
            // Update visible checkboxes
            targetElements.forEach(function (element) {
                if (element) {
                    element.checked = checked;
                }
            });
        }
        updateHeaderCheckboxState();
        fireEvent('changed');
    }
    // Reapply checked state to visible checkboxes based on selectedRows
    function reapplyCheckedStates() {
        var selectedRows = getSelectedRows();
        if (!targetElements)
            return;
        targetElements.forEach(function (element) {
            var _a;
            if (!element)
                return;
            var value = element.value;
            element.checked = selectedRows.includes(value);
            // Update row class
            var row = element.closest('tr');
            if (row && ((_a = config.checkbox) === null || _a === void 0 ? void 0 : _a.checkedClass)) {
                if (element.checked) {
                    row.classList.add(config.checkbox.checkedClass);
                }
                else {
                    row.classList.remove(config.checkbox.checkedClass);
                }
            }
        });
    }
    // Update header checkbox state (checked/indeterminate/unchecked)
    function updateHeaderCheckboxState() {
        if (!headerCheckElement || !targetElements)
            return;
        var total = targetElements.length;
        var checked = 0;
        for (var i = 0; i < total; i++) {
            if (targetElements[i].checked)
                checked++;
        }
        if (checked === 0) {
            headerCheckElement.indeterminate = false;
            headerCheckElement.checked = false;
            headerChecked = false;
        }
        else if (checked > 0 && checked < total) {
            headerCheckElement.indeterminate = true;
            headerCheckElement.checked = false;
            headerChecked = false;
        }
        else if (checked === total) {
            headerCheckElement.indeterminate = false;
            headerCheckElement.checked = true;
            headerChecked = true;
        }
    }
    // Fix: isChecked() implementation
    function isChecked() {
        return headerChecked;
    }
    function getChecked() {
        return getSelectedRows();
    }
    function check() {
        change(true);
        reapplyCheckedStates();
        updateHeaderCheckboxState();
    }
    function uncheck() {
        change(false);
        reapplyCheckedStates();
        updateHeaderCheckboxState();
    }
    function toggle() {
        checkboxToggle();
        reapplyCheckedStates();
        updateHeaderCheckboxState();
    }
    function updateState() {
        // Called after redraw/pagination
        targetElements = element.querySelectorAll(config.attributes.checkbox);
        reapplyCheckedStates();
        updateHeaderCheckboxState();
    }
    return {
        init: init,
        check: check,
        uncheck: uncheck,
        toggle: toggle,
        isChecked: isChecked,
        getChecked: getChecked,
        updateState: updateState,
    };
}


/***/ }),

/***/ 5634:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


/**
 * KTUI - Free & Open-Source Tailwind UI Components by Keenthemes
 * Copyright 2025 by Keenthemes Inc
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.KTTabs = void 0;
var tabs_1 = __webpack_require__(1396);
Object.defineProperty(exports, "KTTabs", ({ enumerable: true, get: function () { return tabs_1.KTTabs; } }));


/***/ }),

/***/ 5650:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


/**
 * KTUI - Free & Open-Source Tailwind UI Components by Keenthemes
 * Copyright 2025 by Keenthemes Inc
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.KTToggle = void 0;
var toggle_1 = __webpack_require__(1132);
Object.defineProperty(exports, "KTToggle", ({ enumerable: true, get: function () { return toggle_1.KTToggle; } }));


/***/ }),

/***/ 5795:
/***/ (function(__unused_webpack_module, exports) {


/**
 * KTUI - Free & Open-Source Tailwind UI Components by Keenthemes
 * Copyright 2025 by Keenthemes Inc
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.KTDatepickerEventManager = exports.KTDatepickerEventName = void 0;
/**
 * Event names used by the datepicker component
 */
var KTDatepickerEventName;
(function (KTDatepickerEventName) {
    KTDatepickerEventName["DATE_CHANGE"] = "date-change";
    KTDatepickerEventName["STATE_CHANGE"] = "stateChange";
    KTDatepickerEventName["OPEN"] = "open";
    KTDatepickerEventName["CLOSE"] = "close";
    KTDatepickerEventName["UPDATE"] = "update";
    KTDatepickerEventName["KEYBOARD_OPEN"] = "keyboard-open";
    KTDatepickerEventName["VIEW_CHANGE"] = "view-change";
    KTDatepickerEventName["TIME_CHANGE"] = "time-change";
})(KTDatepickerEventName || (exports.KTDatepickerEventName = KTDatepickerEventName = {}));
/**
 * Centralized event manager for the datepicker component
 * Handles all event dispatching and listening
 */
var KTDatepickerEventManager = /** @class */ (function () {
    /**
     * Constructor
     *
     * @param element - The root element to attach events to
     */
    function KTDatepickerEventManager(element) {
        this._element = element;
    }
    /**
     * Dispatch a custom event on the datepicker element
     *
     * @param eventName - Name of the event to dispatch
     * @param payload - Optional payload data
     */
    KTDatepickerEventManager.prototype.dispatchEvent = function (eventName, payload) {
        var event = new CustomEvent(eventName, {
            bubbles: true,
            detail: { payload: payload },
        });
        this._element.dispatchEvent(event);
    };
    /**
     * Add an event listener to the datepicker element
     *
     * @param eventName - Name of the event to listen for
     * @param listener - Callback function
     * @param options - Event listener options
     */
    KTDatepickerEventManager.prototype.addEventListener = function (eventName, listener, options) {
        this._element.addEventListener(eventName, listener, options);
    };
    /**
     * Remove an event listener from the datepicker element
     *
     * @param eventName - Name of the event to remove listener for
     * @param listener - Callback function to remove
     * @param options - Event listener options
     */
    KTDatepickerEventManager.prototype.removeEventListener = function (eventName, listener, options) {
        this._element.removeEventListener(eventName, listener, options);
    };
    /**
     * Dispatch the date change event with the current selection
     *
     * @param payload - Object containing date selection information
     */
    KTDatepickerEventManager.prototype.dispatchDateChangeEvent = function (payload) {
        this.dispatchEvent(KTDatepickerEventName.DATE_CHANGE, payload);
    };
    /**
     * Dispatch the open event when the datepicker opens
     */
    KTDatepickerEventManager.prototype.dispatchOpenEvent = function () {
        this.dispatchEvent(KTDatepickerEventName.OPEN);
    };
    /**
     * Dispatch the close event when the datepicker closes
     */
    KTDatepickerEventManager.prototype.dispatchCloseEvent = function () {
        this.dispatchEvent(KTDatepickerEventName.CLOSE);
    };
    /**
     * Dispatch the update event to refresh the datepicker
     */
    KTDatepickerEventManager.prototype.dispatchUpdateEvent = function () {
        this.dispatchEvent(KTDatepickerEventName.UPDATE);
    };
    /**
     * Dispatch the keyboard open event when datepicker is opened via keyboard
     */
    KTDatepickerEventManager.prototype.dispatchKeyboardOpenEvent = function () {
        this.dispatchEvent(KTDatepickerEventName.KEYBOARD_OPEN);
    };
    /**
     * Dispatch the view change event when the datepicker view changes
     *
     * @param viewMode - The new view mode (days, months, years)
     */
    KTDatepickerEventManager.prototype.dispatchViewChangeEvent = function (viewMode) {
        this.dispatchEvent(KTDatepickerEventName.VIEW_CHANGE, { viewMode: viewMode });
    };
    /**
     * Dispatch the time change event when the time selection changes
     *
     * @param timeData - Object containing time selection information
     */
    KTDatepickerEventManager.prototype.dispatchTimeChangeEvent = function (timeData) {
        this.dispatchEvent(KTDatepickerEventName.TIME_CHANGE, timeData);
    };
    /**
     * Dispatch a change event on the given input element
     *
     * @param inputElement - The input element to dispatch change event on
     */
    KTDatepickerEventManager.prototype.dispatchInputChangeEvent = function (inputElement) {
        if (inputElement) {
            inputElement.dispatchEvent(new Event('change', { bubbles: true }));
        }
    };
    return KTDatepickerEventManager;
}());
exports.KTDatepickerEventManager = KTDatepickerEventManager;


/***/ }),

/***/ 5907:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


/**
 * KTUI - Free & Open-Source Tailwind UI Components by Keenthemes
 * Copyright 2025 by Keenthemes Inc
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.KTStepper = void 0;
var stepper_1 = __webpack_require__(770);
Object.defineProperty(exports, "KTStepper", ({ enumerable: true, get: function () { return stepper_1.KTStepper; } }));


/***/ }),

/***/ 6265:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


/**
 * KTUI - Free & Open-Source Tailwind UI Components by Keenthemes
 * Copyright 2025 by Keenthemes Inc
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.KTToast = void 0;
var toast_1 = __webpack_require__(8834);
Object.defineProperty(exports, "KTToast", ({ enumerable: true, get: function () { return toast_1.KTToast; } }));


/***/ }),

/***/ 6292:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


/**
 * KTUI - Free & Open-Source Tailwind UI Components by Keenthemes
 * Copyright 2025 by Keenthemes Inc
 */
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.KTDatepickerStateManager = exports.DefaultConfig = void 0;
var locales_1 = __webpack_require__(7727);
var utils_1 = __webpack_require__(2393);
var events_1 = __webpack_require__(5795);
exports.DefaultConfig = {
    locale: 'en-US',
    locales: locales_1.DefaultLocales, // all locales
    weekDays: 'min',
    forceLeadingZero: true,
    // 0-indexed month
    // minDate: new Date(2024, 7, 20),
    // maxDate: new Date(2024, 8, 10),
    // supported formats: refer to dateFormat
    // minDate: '20/08/2024',
    // maxDate: '10/09/2024',
    // Calendar
    visibleMonths: 1, // visible months calendar to show
    visibleYears: 10, // visible years span to show on year selection
    keepViewModeOnSelection: false, // automatically switch view modes when selecting month/year
    // Date
    format: 'dd/MM/yyyy',
    // Time
    enableTime: false,
    timeFormat: 'hh:mm:ss A ZZZ', // 12-hours time format
    // timeFormat: 'HH:mm:ss ZZZ', // 24-hours time format
    am: 'AM',
    pm: 'PM',
    hourStep: 1,
    // minuteStep: 5,
    // secondStep: 10,
    // disabledHours: [0, 1, 2, 3, 4, 5, 6, 22, 23],
    // disabledMinutes: [0, 1, 2, 3],
    // Date range
    range: false,
    rangeSeparator: ' - ',
    // Multi-date selection
    multiDateSelection: false,
    maxDates: 0, // 0 means unlimited
    // Date blocking patterns
    disabledDates: [],
    enableNaturalLanguage: true,
    // Animation settings
    animationDuration: 250,
    animationEasing: '',
    animationEnterClass: '',
    animationExitClass: '',
};
/**
 * State manager class for KTDatepicker
 * Handles state management and configuration
 */
var KTDatepickerStateManager = /** @class */ (function () {
    /**
     * Constructor for the KTDatepickerStateManager class
     *
     * @param element - The datepicker element
     * @param config - Configuration object
     */
    function KTDatepickerStateManager(element, config) {
        this._element = element;
        this._config = this._mergeConfig(config || {});
        this._state = this._initializeState();
        this._events = new events_1.KTDatepickerEventManager(element);
    }
    /**
     * Merge provided configuration with default configuration
     *
     * @param config - User provided configuration
     * @returns Merged configuration
     */
    KTDatepickerStateManager.prototype._mergeConfig = function (config) {
        return __assign(__assign({}, exports.DefaultConfig), config);
    };
    /**
     * Initialize the state object with default values
     */
    KTDatepickerStateManager.prototype._initializeState = function () {
        var now = new Date();
        var state = {
            currentDate: now,
            selectedDate: null,
            selectedDateRange: null,
            selectedDates: [],
            viewMode: 'days',
            isOpen: false,
            isFocused: false,
            isRangeSelectionStart: true,
            isRangeSelectionInProgress: false,
            selectedTime: null,
            prevIsOpen: false,
        };
        return state;
    };
    /**
     * Get the current configuration
     *
     * @returns Current configuration
     */
    KTDatepickerStateManager.prototype.getConfig = function () {
        return this._config;
    };
    /**
     * Get the current state
     *
     * @returns Current state
     */
    KTDatepickerStateManager.prototype.getState = function () {
        return this._state;
    };
    /**
     * Set the selected date
     *
     * @param date - Date to select
     */
    KTDatepickerStateManager.prototype.setSelectedDate = function (date) {
        var state = this._state;
        var config = this._config;
        if (date === null) {
            // Clear selection
            state.selectedDate = null;
            state.selectedDateRange = null;
            state.isRangeSelectionInProgress = false;
            this._dispatchChangeEvent();
            return;
        }
        // Check if the date is disabled (outside min/max range or explicitly disabled)
        // We add this check here as a second defense layer beyond the UI checks
        if ((0, utils_1.isDateDisabled)(date, config)) {
            console.log('Date is disabled in setSelectedDate, ignoring selection:', date.toISOString());
            return;
        }
        if (config.range) {
            // Handle range selection
            if (!state.selectedDateRange) {
                // Initialize range object if it doesn't exist
                state.selectedDateRange = { startDate: null, endDate: null };
            }
            // If start date isn't set or if we're resetting the range, set the start date
            if (!state.selectedDateRange.startDate ||
                state.isRangeSelectionStart ||
                state.selectedDateRange.endDate) {
                // Reset the range with a new start date
                state.selectedDateRange.startDate = date;
                state.selectedDateRange.endDate = null;
                state.isRangeSelectionStart = false; // We've selected the start, next will be end
                // Set the flag to keep dropdown open during range selection
                state.isRangeSelectionInProgress = true;
                console.log('Range start selected - setting isRangeSelectionInProgress to true');
            }
            else {
                // Set the end date if the start date is already set
                // Ensure that start is before end (swap if needed)
                if (date < state.selectedDateRange.startDate) {
                    // Swap dates if the selected date is before the start date
                    state.selectedDateRange.endDate = state.selectedDateRange.startDate;
                    state.selectedDateRange.startDate = date;
                }
                else {
                    state.selectedDateRange.endDate = date;
                }
                state.isRangeSelectionStart = true; // Reset for next range selection
                // Clear the flag as range selection is complete
                state.isRangeSelectionInProgress = false;
                console.log('Range end selected - setting isRangeSelectionInProgress to false');
            }
            // For date range, we still set selectedDate for current focus
            state.selectedDate = date;
            // Trigger event with range data
            this._dispatchChangeEvent();
        }
        else {
            // Single date selection
            state.selectedDate = date;
            // Multi-date selection
            if (config.multiDateSelection) {
                // Add or remove the date from the array
                var existingIndex = state.selectedDates.findIndex(function (d) {
                    return (0, utils_1.isSameDay)(d, date);
                });
                if (existingIndex !== -1) {
                    // Remove if already selected
                    state.selectedDates.splice(existingIndex, 1);
                }
                else if (state.selectedDates.length < config.maxDates) {
                    // Add if not exceeding max
                    state.selectedDates.push(date);
                }
            }
            // Trigger event with single date data
            this._dispatchChangeEvent();
        }
    };
    /**
     * Set the current view date (month/year being viewed)
     *
     * @param date - Date to set as current view
     */
    KTDatepickerStateManager.prototype.setCurrentDate = function (date) {
        this._state.currentDate = date;
        this._dispatchEvent('month-change', {
            month: date.getMonth(),
            year: date.getFullYear(),
        });
    };
    /**
     * Set the selected time
     *
     * @param time - Time configuration to set
     */
    KTDatepickerStateManager.prototype.setSelectedTime = function (time) {
        this._state.selectedTime = time;
        this._dispatchChangeEvent();
    };
    /**
     * Set the view mode (days, months, years)
     *
     * @param mode - View mode to set
     */
    KTDatepickerStateManager.prototype.setViewMode = function (mode) {
        this._state.viewMode = mode;
        this._dispatchEvent('view-mode-change', { mode: mode });
    };
    /**
     * Set the open state of the datepicker
     *
     * @param isOpen - Whether the datepicker is open
     */
    KTDatepickerStateManager.prototype.setOpen = function (isOpen) {
        this._state.isOpen = isOpen;
        this._dispatchEvent(isOpen ? 'open' : 'close');
        // Call callback if defined
        if (isOpen && this._config.onOpen) {
            this._config.onOpen();
        }
        else if (!isOpen && this._config.onClose) {
            this._config.onClose();
        }
    };
    /**
     * Set the focus state of the datepicker
     *
     * @param isFocused - Whether the datepicker is focused
     */
    KTDatepickerStateManager.prototype.setFocused = function (isFocused) {
        this._state.isFocused = isFocused;
        this._dispatchEvent(isFocused ? 'focus' : 'blur');
    };
    /**
     * Reset the state to initial values
     */
    KTDatepickerStateManager.prototype.resetState = function () {
        this._state = this._initializeState();
        this._dispatchEvent('reset');
    };
    /**
     * Dispatch change event with current date/time selection
     */
    KTDatepickerStateManager.prototype._dispatchChangeEvent = function () {
        var payload = {};
        if (this._config.range && this._state.selectedDateRange) {
            payload.selectedDateRange = this._state.selectedDateRange;
        }
        else if (this._config.multiDateSelection) {
            payload.selectedDates = __spreadArray([], this._state.selectedDates, true);
        }
        else {
            payload.selectedDate = this._state.selectedDate;
        }
        if (this._config.enableTime && this._state.selectedTime) {
            payload.selectedTime = __assign({}, this._state.selectedTime);
        }
        this._events.dispatchDateChangeEvent(payload);
        // Call onChange callback if defined
        if (this._config.onChange) {
            var value = void 0;
            if (this._config.range) {
                value = this._state.selectedDateRange || {
                    startDate: null,
                    endDate: null,
                };
            }
            else {
                value = this._state.selectedDate;
            }
            this._config.onChange(value);
        }
    };
    /**
     * Dispatch custom event
     *
     * @param eventName - Name of the event
     * @param payload - Optional payload data
     */
    KTDatepickerStateManager.prototype._dispatchEvent = function (eventName, payload) {
        this._events.dispatchEvent(eventName, payload);
    };
    /**
     * Get the event manager instance
     */
    KTDatepickerStateManager.prototype.getEventManager = function () {
        return this._events;
    };
    return KTDatepickerStateManager;
}());
exports.KTDatepickerStateManager = KTDatepickerStateManager;


/***/ }),

/***/ 6502:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


/**
 * KTUI - Free & Open-Source Tailwind UI Components by Keenthemes
 * Copyright 2025 by Keenthemes Inc
 */
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g = Object.create((typeof Iterator === "function" ? Iterator : Object).prototype);
    return g.next = verb(0), g["throw"] = verb(1), g["return"] = verb(2), typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.KTDataTable = void 0;
var component_1 = __webpack_require__(2658);
var utils_1 = __webpack_require__(2599);
var index_1 = __webpack_require__(8156);
var data_1 = __webpack_require__(8716);
var datatable_checkbox_1 = __webpack_require__(5562);
var datatable_sort_1 = __webpack_require__(5199);
/**
 * Custom DataTable plugin class with server-side API, pagination, and sorting
 * @classdesc A custom KTComponent class that integrates server-side API, pagination, and sorting functionality into a table.
 * It supports fetching data from a server-side API, pagination, and sorting of the fetched data.
 * @class
 * @extends {KTComponent}
 * @param {HTMLElement} element The table element
 * @param {KTDataTableConfigInterface} [config] Additional configuration options
 */
var KTDataTable = /** @class */ (function (_super) {
    __extends(KTDataTable, _super);
    function KTDataTable(element, config) {
        var _this = _super.call(this) || this;
        _this._name = 'datatable';
        _this._originalTbodyClass = ''; // Store original tbody class
        _this._originalTrClasses = []; // Store original tr classes
        _this._originalTheadClass = ''; // Store original thead class
        _this._originalTdClasses = []; // Store original td classes as a 2D array [row][col]
        _this._originalThClasses = []; // Store original th classes
        _this._data = [];
        _this._isFetching = false;
        if (data_1.default.has(element, _this._name))
            return _this;
        _this._defaultConfig = _this._initDefaultConfig(config);
        _this._init(element);
        _this._buildConfig();
        // Store the instance directly on the element
        element.instance = _this;
        _this._initElements();
        // Initialize checkbox handler
        _this._checkbox = (0, datatable_checkbox_1.createCheckboxHandler)(_this._element, _this._config, function (eventName, eventData) {
            _this._fireEvent(eventName, eventData);
            _this._dispatchEvent(eventName, eventData);
        });
        // Initialize sort handler
        _this._sortHandler = (0, datatable_sort_1.createSortHandler)(_this._config, _this._theadElement, function () { return ({
            sortField: _this.getState().sortField,
            sortOrder: _this.getState().sortOrder,
        }); }, function (field, order) {
            _this._config._state.sortField = field;
            _this._config._state.sortOrder = order;
        }, _this._fireEvent.bind(_this), _this._dispatchEvent.bind(_this), _this._updateData.bind(_this));
        _this._sortHandler.initSort();
        if (_this._config.stateSave === false) {
            _this._deleteState();
        }
        if (_this._config.stateSave) {
            _this._loadState();
        }
        _this._updateData();
        _this._fireEvent('init');
        _this._dispatchEvent('init');
        return _this;
    }
    /**
     * Initialize default configuration for the datatable
     * @param config User-provided configuration options
     * @returns Default configuration merged with user-provided options
     */
    KTDataTable.prototype._initDefaultConfig = function (config) {
        var _this = this;
        return __assign({ 
            /**
             * HTTP method for server-side API call
             */
            requestMethod: 'GET', 
            /**
             * Custom HTTP headers for the API request
             */
            requestHeaders: {
                'Content-Type': 'application/x-www-form-urlencoded',
            }, 
            /**
             * Pagination info template
             */
            info: '{start}-{end} of {total}', 
            /**
             * Info text when there is no data
             */
            infoEmpty: 'No records found', 
            /**
             * Available page sizes
             */
            pageSizes: [5, 10, 20, 30, 50], 
            /**
             * Default page size
             */
            pageSize: 10, 
            /**
             * Enable or disable pagination more button
             */
            pageMore: true, 
            /**
             * Maximum number of pages before enabling pagination more button
             */
            pageMoreLimit: 3, 
            /**
             * Pagination button templates
             */
            pagination: {
                number: {
                    /**
                     * CSS classes to be added to the pagination button
                     */
                    class: 'kt-datatable-pagination-button',
                    /**
                     * Text to be displayed in the pagination button
                     */
                    text: '{page}',
                },
                previous: {
                    /**
                     * CSS classes to be added to the previous pagination button
                     */
                    class: 'kt-datatable-pagination-button kt-datatable-pagination-prev',
                    /**
                     * Text to be displayed in the previous pagination button
                     */
                    text: "\n\t\t\t\t\t\t<svg class=\"rtl:transform rtl:rotate-180 size-3.5 shrink-0\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\">\n\t\t\t\t\t\t\t<path d=\"M8.86501 16.7882V12.8481H21.1459C21.3724 12.8481 21.5897 12.7581 21.7498 12.5979C21.91 12.4378 22 12.2205 22 11.994C22 11.7675 21.91 11.5503 21.7498 11.3901C21.5897 11.2299 21.3724 11.1399 21.1459 11.1399H8.86501V7.2112C8.86628 7.10375 8.83517 6.9984 8.77573 6.90887C8.7163 6.81934 8.63129 6.74978 8.53177 6.70923C8.43225 6.66869 8.32283 6.65904 8.21775 6.68155C8.11267 6.70405 8.0168 6.75766 7.94262 6.83541L2.15981 11.6182C2.1092 11.668 2.06901 11.7274 2.04157 11.7929C2.01413 11.8584 2 11.9287 2 11.9997C2 12.0707 2.01413 12.141 2.04157 12.2065C2.06901 12.272 2.1092 12.3314 2.15981 12.3812L7.94262 17.164C8.0168 17.2417 8.11267 17.2953 8.21775 17.3178C8.32283 17.3403 8.43225 17.3307 8.53177 17.2902C8.63129 17.2496 8.7163 17.18 8.77573 17.0905C8.83517 17.001 8.86628 16.8956 8.86501 16.7882Z\" fill=\"currentColor\"/>\n\t\t\t\t\t\t</svg>\n\t\t\t\t\t",
                },
                next: {
                    /**
                     * CSS classes to be added to the next pagination button
                     */
                    class: 'kt-datatable-pagination-button kt-datatable-pagination-next',
                    /**
                     * Text to be displayed in the next pagination button
                     */
                    text: "\n\t\t\t\t\t\t<svg class=\"rtl:transform rtl:rotate-180 size-3.5 shrink-0\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\">\n\t\t\t\t\t\t\t<path d=\"M15.135 7.21144V11.1516H2.85407C2.62756 11.1516 2.41032 11.2415 2.25015 11.4017C2.08998 11.5619 2 11.7791 2 12.0056C2 12.2321 2.08998 12.4494 2.25015 12.6096C2.41032 12.7697 2.62756 12.8597 2.85407 12.8597H15.135V16.7884C15.1337 16.8959 15.1648 17.0012 15.2243 17.0908C15.2837 17.1803 15.3687 17.2499 15.4682 17.2904C15.5677 17.3309 15.6772 17.3406 15.7822 17.3181C15.8873 17.2956 15.9832 17.242 16.0574 17.1642L21.8402 12.3814C21.8908 12.3316 21.931 12.2722 21.9584 12.2067C21.9859 12.1412 22 12.0709 22 11.9999C22 11.9289 21.9859 11.8586 21.9584 11.7931C21.931 11.7276 21.8908 11.6683 21.8402 11.6185L16.0574 6.83565C15.9832 6.75791 15.8873 6.70429 15.7822 6.68179C15.6772 6.65929 15.5677 6.66893 15.4682 6.70948C15.3687 6.75002 15.2837 6.81959 15.2243 6.90911C15.1648 6.99864 15.1337 7.10399 15.135 7.21144Z\" fill=\"currentColor\"/>\n\t\t\t\t\t\t</svg>\n\t\t\t\t\t",
                },
                more: {
                    /**
                     * CSS classes to be added to the pagination more button
                     */
                    class: 'kt-datatable-pagination-button kt-datatable-pagination-more',
                    /**
                     * Text to be displayed in the pagination more button
                     */
                    text: '...',
                },
            }, 
            /**
             * Sorting options
             */
            sort: {
                /**
                 * CSS classes to be added to the sortable headers
                 */
                classes: {
                    base: 'kt-table-col',
                    asc: 'asc',
                    desc: 'desc',
                },
                /**
                 * Local sorting callback function
                 * Sorts the data array based on the sort field and order
                 * @param data Data array to be sorted
                 * @param sortField Property name of the data object to be sorted by
                 * @param sortOrder Sorting order (ascending or descending)
                 * @returns Sorted data array
                 */
                callback: function (data, sortField, sortOrder) {
                    return _this._sortHandler
                        ? _this._sortHandler.sortData(data, sortField, sortOrder)
                        : data;
                },
            }, search: {
                /**
                 * Delay in milliseconds before the search function is applied to the data array
                 * @default 500
                 */
                delay: 500, // ms
                /**
                 * Local search callback function
                 * Filters the data array based on the search string
                 * @param data Data array to be filtered
                 * @param search Search string used to filter the data array
                 * @returns Filtered data array
                 */
                callback: function (data, search) {
                    if (!data || !search) {
                        return [];
                    }
                    return data.filter(function (item) {
                        if (!item) {
                            return false;
                        }
                        return Object.values(item).some(function (value) {
                            if (typeof value !== 'string' &&
                                typeof value !== 'number' &&
                                typeof value !== 'boolean') {
                                return false;
                            }
                            var valueText = String(value)
                                .replace(/<[^>]*>|&nbsp;/g, '')
                                .toLowerCase();
                            return valueText.includes(search.toLowerCase());
                        });
                    });
                },
            }, 
            /**
             * Loading spinner options
             */
            loading: {
                /**
                 * Template to be displayed during data fetching process
                 */
                template: "\n\t\t\t\t\t<div class=\"absolute top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2\">\n\t\t\t\t\t\t<div class=\"kt-datatable-loading\">\n\t\t\t\t\t\t\t<svg class=\"animate-spin -ml-1 h-5 w-5 text-gray-600\" xmlns=\"http://www.w3.org/2000/svg\" fill=\"none\" viewBox=\"0 0 24 24\">\n\t\t\t\t\t\t\t\t<circle class=\"opacity-25\" cx=\"12\" cy=\"12\" r=\"10\" stroke=\"currentColor\" stroke-width=\"3\"></circle>\n\t\t\t\t\t\t\t\t<path class=\"opacity-75\" fill=\"currentColor\" d=\"M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z\"></path>\n\t\t\t\t\t\t\t</svg>\n\t\t\t\t\t\t\t{content}\n\t\t\t\t\t\t</div>\n\t\t\t\t\t</div>\n\t\t\t\t",
                /**
                 * Loading text to be displayed in the template
                 */
                content: 'Loading...',
            }, 
            /**
             * Selectors of the elements to be targeted
             */
            attributes: {
                /**
                 * Data table element
                 */
                table: 'table[data-kt-datatable-table="true"]',
                /**
                 * Pagination info element
                 */
                info: '[data-kt-datatable-info="true"]',
                /**
                 * Page size dropdown element
                 */
                size: '[data-kt-datatable-size="true"]',
                /**
                 * Pagination element
                 */
                pagination: '[data-kt-datatable-pagination="true"]',
                /**
                 * Spinner element
                 */
                spinner: '[data-kt-datatable-spinner="true"]',
                /**
                 * Checkbox element
                 */
                check: '[data-kt-datatable-check="true"]',
                checkbox: '[data-kt-datatable-row-check="true"]',
            }, 
            /**
             * Enable or disable state saving
             */
            stateSave: true, checkbox: {
                checkedClass: 'checked',
            }, 
            /**
             * Private properties
             */
            _state: {}, loadingClass: 'loading' }, config);
    };
    /**
     * Initialize table, tbody, thead, info, size, and pagination elements
     * @returns {void}
     */
    KTDataTable.prototype._initElements = function () {
        /**
         * Data table element
         */
        this._tableElement = this._element.querySelector(this._config.attributes.table);
        /**
         * Table body element
         */
        this._tbodyElement =
            this._tableElement.tBodies[0] || this._tableElement.createTBody();
        /**
         * Table head element
         */
        this._theadElement = this._tableElement.tHead;
        // Store original classes
        this._storeOriginalClasses();
        /**
         * Pagination info element
         */
        this._infoElement = this._element.querySelector(this._config.attributes.info);
        /**
         * Page size dropdown element
         */
        this._sizeElement = this._element.querySelector(this._config.attributes.size);
        /**
         * Pagination element
         */
        this._paginationElement = this._element.querySelector(this._config.attributes.pagination);
    };
    /**
     * Store original classes from table elements
     * @returns {void}
     */
    KTDataTable.prototype._storeOriginalClasses = function () {
        var _this = this;
        // Store tbody class
        if (this._tbodyElement) {
            this._originalTbodyClass = this._tbodyElement.className || '';
        }
        // Store thead class and th classes
        if (this._theadElement) {
            this._originalTheadClass = this._theadElement.className || '';
            // Store th classes
            var thElements = this._theadElement.querySelectorAll('th');
            this._originalThClasses = Array.from(thElements).map(function (th) { return th.className || ''; });
        }
        // Store tr and td classes
        if (this._tbodyElement) {
            var originalRows = this._tbodyElement.querySelectorAll('tr');
            this._originalTrClasses = Array.from(originalRows).map(function (row) { return row.className || ''; });
            // Store td classes as a 2D array
            this._originalTdClasses = [];
            Array.from(originalRows).forEach(function (row, rowIndex) {
                var tdElements = row.querySelectorAll('td');
                _this._originalTdClasses[rowIndex] = Array.from(tdElements).map(function (td) { return td.className || ''; });
            });
        }
    };
    /**
     * Fetch data from the server or from the DOM if `apiEndpoint` is not defined.
     * @returns {Promise<void>} Promise which is resolved after data has been fetched and checkbox plugin initialized.
     */
    KTDataTable.prototype._updateData = function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                if (this._isFetching)
                    return [2 /*return*/]; // Prevent duplicate fetches
                this._isFetching = true;
                try {
                    this._showSpinner(); // Show spinner before fetching data
                    // Fetch data from the DOM and initialize the checkbox plugin
                    return [2 /*return*/, typeof this._config.apiEndpoint === 'undefined'
                            ? this._fetchDataFromLocal().then(this._finalize.bind(this))
                            : this._fetchDataFromServer().then(this._finalize.bind(this))];
                }
                finally {
                    this._isFetching = false;
                }
                // removed by dead control flow
{}
            });
        });
    };
    /**
     * Finalize data table after data has been fetched
     * @returns {void}
     */
    KTDataTable.prototype._finalize = function () {
        this._element.classList.add('datatable-initialized');
        // Initialize checkbox logic
        this._checkbox.init();
        this._attachSearchEvent();
        if (typeof index_1.default !== 'undefined') {
            index_1.default.init();
        }
        /**
         * Hide spinner
         */
        this._hideSpinner();
    };
    /**
     * Attach search event to the search input element
     * @returns {void}
     */
    KTDataTable.prototype._attachSearchEvent = function () {
        var _this = this;
        var tableId = this._tableId();
        var searchElement = document.querySelector("[data-kt-datatable-search=\"#".concat(tableId, "\"]"));
        // Get search state
        var search = this.getState().search;
        // Set search value
        if (searchElement) {
            searchElement.value =
                search === undefined || search === null ? '' : typeof search === 'string' ? search : String(search);
        }
        if (searchElement) {
            // Check if a debounced search function already exists
            if (searchElement._debouncedSearch) {
                // Remove the existing debounced event listener
                searchElement.removeEventListener('keyup', searchElement._debouncedSearch);
            }
            // Create a new debounced search function
            var debouncedSearch = this._debounce(function () {
                _this.search(searchElement.value);
            }, this._config.search.delay);
            // Store the new debounced function as a property of the element
            searchElement._debouncedSearch = debouncedSearch;
            // Add the new debounced event listener
            searchElement.addEventListener('keyup', debouncedSearch);
        }
    };
    /**
     * Fetch data from the DOM
     * Fetch data from the table element and save it to the `originalData` state property.
     * This method is used when the data is not fetched from the server via an API endpoint.
     */
    KTDataTable.prototype._fetchDataFromLocal = function () {
        return __awaiter(this, void 0, void 0, function () {
            var _a, sortField, sortOrder, page, pageSize, search, originalData, _b, originalData_1, originalDataAttributes, _temp, startIndex, endIndex;
            var _c;
            return __generator(this, function (_d) {
                switch (_d.label) {
                    case 0:
                        this._fireEvent('fetch');
                        this._dispatchEvent('fetch');
                        _a = this.getState(), sortField = _a.sortField, sortOrder = _a.sortOrder, page = _a.page, pageSize = _a.pageSize, search = _a.search;
                        originalData = this.getState().originalData;
                        // If the table element or the original data is not defined, bail
                        if (!this._tableElement ||
                            originalData === undefined ||
                            this._tableConfigInvalidate() ||
                            this._localTableHeaderInvalidate() ||
                            this._localTableContentInvalidate()) {
                            this._deleteState();
                            _b = this._localExtractTableContent(), originalData_1 = _b.originalData, originalDataAttributes = _b.originalDataAttributes;
                            this._config._state.originalData = originalData_1;
                            this._config._state.originalDataAttributes = originalDataAttributes;
                        }
                        // Update the original data variable
                        originalData = this.getState().originalData;
                        _temp = (this._data = __spreadArray([], originalData, true));
                        if (search) {
                            _temp = this._data = this._config.search.callback.call(this, this._data, search);
                        }
                        // If sorting is defined, sort the data
                        if (sortField !== undefined &&
                            sortOrder !== undefined &&
                            sortOrder !== '') {
                            if (typeof this._config.sort.callback === 'function') {
                                this._data = this._config.sort.callback.call(this, this._data, sortField, sortOrder);
                            }
                        }
                        // If there is data, slice it to the current page size
                        if (((_c = this._data) === null || _c === void 0 ? void 0 : _c.length) > 0) {
                            startIndex = (page - 1) * pageSize;
                            endIndex = startIndex + pageSize;
                            this._data = this._data.slice(startIndex, endIndex);
                        }
                        // Determine number of total rows
                        this._config._state.totalItems = _temp.length;
                        // Draw the data
                        return [4 /*yield*/, this._draw()];
                    case 1:
                        // Draw the data
                        _d.sent();
                        this._fireEvent('fetched');
                        this._dispatchEvent('fetched');
                        return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Checks if the table content has been invalidated by comparing the current checksum of the table body
     * with the stored checksum in the state. If the checksums are different, the state is updated with the
     * new checksum and `true` is returned. Otherwise, `false` is returned.
     *
     * @returns {boolean} `true` if the table content has been invalidated, `false` otherwise.
     */
    KTDataTable.prototype._localTableContentInvalidate = function () {
        var checksum = utils_1.default.checksum(JSON.stringify(this._tbodyElement.innerHTML));
        if (this.getState()._contentChecksum !== checksum) {
            this._config._state._contentChecksum = checksum;
            return true;
        }
        return false;
    };
    KTDataTable.prototype._tableConfigInvalidate = function () {
        // Remove _data and _state from config
        var _a = this._config, _data = _a._data, _state = _a._state, restConfig = __rest(_a, ["_data", "_state"]);
        var checksum = utils_1.default.checksum(JSON.stringify(restConfig));
        if (_state._configChecksum !== checksum) {
            this._config._state._configChecksum = checksum;
            return true;
        }
        return false;
    };
    /**
     * Extract the table content and returns it as an object containing an array of original data and an array of original data attributes.
     *
     * @returns {{originalData: T[], originalDataAttributes: KTDataTableAttributeInterface[]}} - An object containing an array of original data and an array of original data attributes.
     */
    KTDataTable.prototype._localExtractTableContent = function () {
        var originalData = [];
        var originalDataAttributes = [];
        this._storeOriginalClasses();
        var rows = this._tbodyElement.querySelectorAll('tr');
        var ths = this._theadElement
            ? this._theadElement.querySelectorAll('th')
            : [];
        rows.forEach(function (row) {
            var dataRow = {};
            var dataRowAttribute = {};
            row.querySelectorAll('td').forEach(function (td, index) {
                var _a, _b, _c;
                var colName = (_a = ths[index]) === null || _a === void 0 ? void 0 : _a.getAttribute('data-kt-datatable-column');
                if (colName) {
                    dataRow[colName] = (_b = td.innerHTML) === null || _b === void 0 ? void 0 : _b.trim();
                }
                else {
                    // Store the original HTML for fallback
                    dataRow[index] = (_c = td.innerHTML) === null || _c === void 0 ? void 0 : _c.trim();
                }
            });
            if (Object.keys(dataRow).length > 0) {
                originalData.push(dataRow);
                originalDataAttributes.push(dataRowAttribute);
            }
        });
        return { originalData: originalData, originalDataAttributes: originalDataAttributes };
    };
    /**
     * Check if the table header is invalidated
     * @returns {boolean} - Returns true if the table header is invalidated, false otherwise
     */
    KTDataTable.prototype._localTableHeaderInvalidate = function () {
        var originalData = this.getState().originalData;
        var currentTableHeaders = this._theadElement
            ? this._theadElement.querySelectorAll('th').length
            : 0;
        var totalColumns = originalData.length
            ? Object.keys(originalData[0]).length
            : 0;
        return currentTableHeaders !== totalColumns;
    };
    /**
     * Fetch data from the server
     */
    KTDataTable.prototype._fetchDataFromServer = function () {
        return __awaiter(this, void 0, void 0, function () {
            var queryParams, response, responseData, error_1;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        this._fireEvent('fetch');
                        this._dispatchEvent('fetch');
                        queryParams = this._getQueryParamsForFetchRequest();
                        return [4 /*yield*/, this._performFetchRequest(queryParams)];
                    case 1:
                        response = _a.sent();
                        responseData = null;
                        _a.label = 2;
                    case 2:
                        _a.trys.push([2, 4, , 5]);
                        return [4 /*yield*/, response.json()];
                    case 3:
                        responseData = _a.sent();
                        return [3 /*break*/, 5];
                    case 4:
                        error_1 = _a.sent();
                        this._noticeOnTable('Error parsing API response as JSON: ' + String(error_1));
                        return [2 /*return*/];
                    case 5:
                        this._fireEvent('fetched', { response: responseData });
                        this._dispatchEvent('fetched', { response: responseData });
                        // Use the mapResponse function to transform the data if provided
                        if (typeof this._config.mapResponse === 'function') {
                            responseData = this._config.mapResponse.call(this, responseData);
                        }
                        this._data = responseData.data;
                        this._config._state.totalItems = responseData.totalCount;
                        return [4 /*yield*/, this._draw()];
                    case 6:
                        _a.sent();
                        this._fireEvent('fetched');
                        this._dispatchEvent('fetched');
                        return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Get the query params for a fetch request
     * @returns The query params for the fetch request
     */
    KTDataTable.prototype._getQueryParamsForFetchRequest = function () {
        // Get the current state of the datatable
        var _a = this.getState(), page = _a.page, pageSize = _a.pageSize, sortField = _a.sortField, sortOrder = _a.sortOrder, filters = _a.filters, search = _a.search;
        // Create a new URLSearchParams object to store the query params
        var queryParams = new URLSearchParams();
        // Add the current page number and page size to the query params
        queryParams.set('page', String(page));
        queryParams.set('size', String(pageSize));
        // If there is a sort order and field set, add them to the query params
        if (sortOrder !== undefined) {
            queryParams.set('sortOrder', String(sortOrder));
        }
        if (sortField !== undefined) {
            queryParams.set('sortField', String(sortField));
        }
        // If there are any filters set, add them to the query params
        if (Array.isArray(filters) && filters.length) {
            queryParams.set('filters', JSON.stringify(filters.map(function (filter) { return ({
                // Map the filter object to a simpler object with just the necessary properties
                column: filter.column,
                type: filter.type,
                value: filter.value,
            }); })));
        }
        if (search) {
            queryParams.set('search', typeof search === 'object' ? JSON.stringify(search) : search);
        }
        // If a mapRequest function is provided, call it with the query params object
        if (typeof this._config.mapRequest === 'function') {
            queryParams = this._config.mapRequest.call(this, queryParams);
        }
        // Return the query params object
        return queryParams;
    };
    KTDataTable.prototype._performFetchRequest = function (queryParams) {
        return __awaiter(this, void 0, void 0, function () {
            var requestMethod, requestBody, apiEndpointWithQueryParams;
            var _this = this;
            return __generator(this, function (_a) {
                requestMethod = this._config.requestMethod;
                requestBody = undefined;
                // If the request method is POST, send the query params as the request body
                if (requestMethod === 'POST') {
                    requestBody = queryParams;
                }
                else if (requestMethod === 'GET') {
                    apiEndpointWithQueryParams = this._createUrl(this._config.apiEndpoint);
                    apiEndpointWithQueryParams.search = queryParams.toString();
                    this._config.apiEndpoint = apiEndpointWithQueryParams.toString();
                }
                return [2 /*return*/, fetch(this._config.apiEndpoint, {
                        method: requestMethod,
                        body: requestBody,
                        headers: this._config.requestHeaders,
                    }).catch(function (error) {
                        // Trigger an error event
                        _this._fireEvent('error', { error: error });
                        _this._dispatchEvent('error', { error: error });
                        _this._noticeOnTable('Error performing fetch request: ' + String(error));
                        throw error;
                    })];
            });
        });
    };
    /**
     * Creates a complete URL from a relative path or a full URL.
     *
     * This method accepts a string that can be either a relative path or a full URL.
     * If the string is a complete URL (i.e., it contains a valid protocol), a URL
     * object based on that string is returned. Otherwise, it ensures the path starts
     * with a "/" and combines it with the provided base URL (or the current window's origin)
     * to form a complete URL.
     *
     * @param {string} pathOrUrl - The path or URL to process.
     * @param {string | null} [baseUrl=window.location.origin] - The base URL for resolving the relative path.
     *                                                           Defaults to the current window's origin.
     * @returns {URL} The resulting URL object.
     */
    KTDataTable.prototype._createUrl = function (pathOrUrl, baseUrl) {
        if (baseUrl === void 0) { baseUrl = window.location.origin; }
        // Regular expression to check if the input is a full URL
        var isFullUrl = /^[a-zA-Z][a-zA-Z\d+\-.]*:\/\//.test(pathOrUrl);
        if (isFullUrl) {
            return new URL(pathOrUrl); // Return full URL as URL object
        }
        // Ensure path starts with a slash to avoid incorrect concatenation
        var normalizedPath = pathOrUrl.startsWith('/')
            ? pathOrUrl
            : "/".concat(pathOrUrl);
        return new URL(normalizedPath, baseUrl);
    };
    /**
     * Update the table and pagination controls with new data
     * @returns {Promise<void>} A promise that resolves when the table and pagination controls are updated
     */
    KTDataTable.prototype._draw = function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                this._config._state.totalPages =
                    Math.ceil(this.getState().totalItems / this.getState().pageSize) || 0;
                this._fireEvent('draw');
                this._dispatchEvent('draw');
                this._dispose();
                // Update the table and pagination controls
                if (this._theadElement && this._tbodyElement) {
                    this._updateTable();
                }
                if (this._infoElement && this._paginationElement) {
                    this._updatePagination();
                }
                this._fireEvent('drew');
                this._dispatchEvent('drew');
                this._hideSpinner(); // Hide spinner after data is fetched
                if (this._config.stateSave) {
                    this._saveState();
                }
                return [2 /*return*/];
            });
        });
    };
    /**
     * Update the HTML table with new data
     * @returns {HTMLTableSectionElement} The new table body element
     */
    KTDataTable.prototype._updateTable = function () {
        // Clear the existing table contents using a more efficient method
        while (this._tableElement.tBodies.length) {
            this._tableElement.removeChild(this._tableElement.tBodies[0]);
        }
        // Create the table body with the new data
        var tbodyElement = this._tableElement.createTBody();
        // Apply the original class to the new tbody element
        if (this._originalTbodyClass) {
            tbodyElement.className = this._originalTbodyClass;
        }
        this._updateTableContent(tbodyElement);
        return tbodyElement;
    };
    /**
     * Update the table content
     * @param tbodyElement The table body element
     * @returns {HTMLTableSectionElement} The updated table body element
     */
    KTDataTable.prototype._updateTableContent = function (tbodyElement) {
        var _this = this;
        var fragment = document.createDocumentFragment();
        tbodyElement.textContent = ''; // Clear the tbody element
        if (this._data.length === 0) {
            this._noticeOnTable(this._config.infoEmpty || '');
            return tbodyElement;
        }
        var ths = this._theadElement
            ? this._theadElement.querySelectorAll('th')
            : [];
        this._data.forEach(function (item, rowIndex) {
            var row = document.createElement('tr');
            // Apply original tr class if available
            if (_this._originalTrClasses && _this._originalTrClasses[rowIndex]) {
                row.className = _this._originalTrClasses[rowIndex];
            }
            if (!_this._config.columns) {
                var dataRowAttributes_1 = _this.getState().originalDataAttributes
                    ? _this.getState().originalDataAttributes[rowIndex]
                    : null;
                // Use the order of <th> elements to render <td>s in the correct order
                ths.forEach(function (th, colIndex) {
                    var colName = th.getAttribute('data-kt-datatable-column');
                    var td = document.createElement('td');
                    var value;
                    if (colName && Object.prototype.hasOwnProperty.call(item, colName)) {
                        value = item[colName];
                    }
                    else if (Object.prototype.hasOwnProperty.call(item, colIndex)) {
                        value = item[colIndex];
                    }
                    else {
                        value = '';
                    }
                    td.innerHTML = value;
                    // Apply original td class if available
                    if (_this._originalTdClasses &&
                        _this._originalTdClasses[rowIndex] &&
                        _this._originalTdClasses[rowIndex][colIndex]) {
                        td.className = _this._originalTdClasses[rowIndex][colIndex];
                    }
                    if (dataRowAttributes_1 && dataRowAttributes_1[colIndex]) {
                        for (var attr in dataRowAttributes_1[colIndex]) {
                            td.setAttribute(attr, dataRowAttributes_1[colIndex][attr]);
                        }
                    }
                    row.appendChild(td);
                });
            }
            else {
                Object.keys(_this._config.columns).forEach(function (key, colIndex) {
                    var td = document.createElement('td');
                    var columnDef = _this._config.columns[key];
                    // Apply original td class if available
                    if (_this._originalTdClasses &&
                        _this._originalTdClasses[rowIndex] &&
                        _this._originalTdClasses[rowIndex][colIndex]) {
                        td.className = _this._originalTdClasses[rowIndex][colIndex];
                    }
                    if (typeof columnDef.render === 'function') {
                        var result = columnDef.render.call(_this, item[key], item, _this);
                        if (result instanceof HTMLElement || result instanceof DocumentFragment) {
                            td.appendChild(result);
                        }
                        else if (typeof result === 'string') {
                            td.innerHTML = result;
                        }
                    }
                    else {
                        td.textContent = item[key];
                    }
                    if (typeof columnDef.createdCell === 'function') {
                        columnDef.createdCell.call(_this, td, item[key], item, row);
                    }
                    row.appendChild(td);
                });
            }
            fragment.appendChild(row);
        });
        tbodyElement.appendChild(fragment);
        return tbodyElement;
    };
    /**
     * Show a notice on the table
     * @param message The message to show. If empty, the message will be removed
     * @returns {void}
     */
    KTDataTable.prototype._noticeOnTable = function (message) {
        if (message === void 0) { message = ''; }
        var row = this._tableElement.tBodies[0].insertRow();
        var cell = row.insertCell();
        cell.colSpan = this._theadElement
            ? this._theadElement.querySelectorAll('th').length
            : 0;
        cell.innerHTML = message;
    };
    KTDataTable.prototype._updatePagination = function () {
        this._removeChildElements(this._sizeElement);
        this._createPageSizeControls(this._sizeElement);
        this._removeChildElements(this._paginationElement);
        this._createPaginationControls(this._infoElement, this._paginationElement);
    };
    /**
     * Removes all child elements from the given container element.
     * @param container The container element to remove the child elements from.
     */
    KTDataTable.prototype._removeChildElements = function (container) {
        if (!container) {
            return;
        }
        // Loop through all child elements of the container and remove them one by one
        while (container.firstChild) {
            // Remove the first child element (which is the first element in the list of child elements)
            container.removeChild(container.firstChild);
        }
    };
    /**
     * Creates a container element for the items per page selector.
     * @param _sizeElement The element to create the page size controls in.
     * @returns The container element.
     */
    KTDataTable.prototype._createPageSizeControls = function (_sizeElement) {
        var _this = this;
        // If no element is provided, return early
        if (!_sizeElement) {
            return _sizeElement;
        }
        // Wait for the element to be attached to the DOM
        setTimeout(function () {
            // Create <option> elements for each page size option
            var options = _this._config.pageSizes.map(function (size) {
                var option = document.createElement('option');
                option.value = String(size);
                option.text = String(size);
                option.selected = _this.getState().pageSize === size;
                return option;
            });
            // Add the <option> elements to the provided element
            _sizeElement.append.apply(_sizeElement, options);
        }, 100);
        // Create an event listener for the "change" event on the element
        var _pageSizeControlsEvent = function (event) {
            // When the element changes, reload the page with the new page size and page number 1
            _this._reloadPageSize(Number(event.target.value), 1);
        };
        // Bind the event listener to the component instance
        _sizeElement.onchange = _pageSizeControlsEvent.bind(this);
        // Return the element
        return _sizeElement;
    };
    /**
     * Reloads the data with the specified page size and optional page number.
     * @param pageSize The new page size.
     * @param page The new page number (optional, defaults to 1).
     */
    KTDataTable.prototype._reloadPageSize = function (pageSize, page) {
        if (page === void 0) { page = 1; }
        // Update the page size and page number in the state
        this._config._state.pageSize = pageSize;
        this._config._state.page = page;
        // Update the data with the new page size and page number
        this._updateData();
    };
    /**
     * Creates the pagination controls for the component.
     * @param _infoElement The element to set the info text in.
     * @param _paginationElement The element to create the pagination controls in.
     * @return {HTMLElement} The element containing the pagination controls.
     */
    KTDataTable.prototype._createPaginationControls = function (_infoElement, _paginationElement) {
        if (!_infoElement || !_paginationElement || this._data.length === 0) {
            return null;
        }
        this._setPaginationInfoText(_infoElement);
        var paginationContainer = this._createPaginationContainer(_paginationElement);
        if (paginationContainer) {
            this._createPaginationButtons(paginationContainer);
        }
        return paginationContainer;
    };
    /**
     * Sets the info text for the pagination controls.
     * @param _infoElement The element to set the info text in.
     */
    KTDataTable.prototype._setPaginationInfoText = function (_infoElement) {
        _infoElement.textContent = this._config.info
            .replace('{start}', (this.getState().page - 1) * this.getState().pageSize + 1 + '')
            .replace('{end}', Math.min(this.getState().page * this.getState().pageSize, this.getState().totalItems) + '')
            .replace('{total}', this.getState().totalItems + '');
    };
    /**
     * Creates the container element for the pagination controls.
     * @param _paginationElement The element to create the pagination controls in.
     * @return {HTMLElement} The container element.
     */
    KTDataTable.prototype._createPaginationContainer = function (_paginationElement) {
        // No longer create a wrapping div. Just return the pagination element itself.
        return _paginationElement;
    };
    /**
     * Creates the pagination buttons for the component.
     * @param paginationContainer The container element for the pagination controls.
     */
    KTDataTable.prototype._createPaginationButtons = function (paginationContainer) {
        var _this = this;
        var _a = this.getState(), currentPage = _a.page, totalPages = _a.totalPages;
        var _b = this._config.pagination, previous = _b.previous, next = _b.next, number = _b.number, more = _b.more;
        // Helper function to create a button
        var createButton = function (text, className, disabled, handleClick) {
            var button = document.createElement('button');
            button.className = className;
            button.innerHTML = text;
            button.disabled = disabled;
            button.onclick = handleClick;
            return button;
        };
        // Add Previous Button
        paginationContainer.appendChild(createButton(previous.text, "".concat(previous.class).concat(currentPage === 1 ? ' disabled' : ''), currentPage === 1, function () { return _this._paginateData(currentPage - 1); }));
        // Calculate range of pages
        var pageMoreEnabled = this._config.pageMore;
        if (pageMoreEnabled) {
            var maxButtons = this._config.pageMoreLimit;
            var range_1 = this._calculatePageRange(currentPage, totalPages, maxButtons);
            // Add start ellipsis
            if (range_1.start > 1) {
                paginationContainer.appendChild(createButton(more.text, more.class, false, function () {
                    return _this._paginateData(Math.max(1, range_1.start - 1));
                }));
            }
            var _loop_1 = function (i) {
                paginationContainer.appendChild(createButton(number.text.replace('{page}', i.toString()), "".concat(number.class).concat(currentPage === i ? ' active disabled' : ''), currentPage === i, function () { return _this._paginateData(i); }));
            };
            // Add page buttons
            for (var i = range_1.start; i <= range_1.end; i++) {
                _loop_1(i);
            }
            // Add end ellipsis
            if (pageMoreEnabled && range_1.end < totalPages) {
                paginationContainer.appendChild(createButton(more.text, more.class, false, function () {
                    return _this._paginateData(Math.min(totalPages, range_1.end + 1));
                }));
            }
        }
        else {
            var _loop_2 = function (i) {
                paginationContainer.appendChild(createButton(number.text.replace('{page}', i.toString()), "".concat(number.class).concat(currentPage === i ? ' active disabled' : ''), currentPage === i, function () { return _this._paginateData(i); }));
            };
            // Add page buttons
            for (var i = 1; i <= totalPages; i++) {
                _loop_2(i);
            }
        }
        // Add Next Button
        paginationContainer.appendChild(createButton(next.text, "".concat(next.class).concat(currentPage === totalPages ? ' disabled' : ''), currentPage === totalPages, function () { return _this._paginateData(currentPage + 1); }));
    };
    // New helper method to calculate page range
    KTDataTable.prototype._calculatePageRange = function (currentPage, totalPages, maxButtons) {
        var startPage, endPage;
        var halfMaxButtons = Math.floor(maxButtons / 2);
        if (totalPages <= maxButtons) {
            startPage = 1;
            endPage = totalPages;
        }
        else {
            startPage = Math.max(currentPage - halfMaxButtons, 1);
            endPage = Math.min(startPage + maxButtons - 1, totalPages);
            if (endPage - startPage < maxButtons - 1) {
                startPage = Math.max(endPage - maxButtons + 1, 1);
            }
        }
        return { start: startPage, end: endPage };
    };
    /**
     * Method for handling pagination
     * @param page - The page number to navigate to
     */
    KTDataTable.prototype._paginateData = function (page) {
        if (page < 1 || !Number.isInteger(page)) {
            return;
        }
        this._fireEvent('pagination', { page: page });
        this._dispatchEvent('pagination', { page: page });
        if (page >= 1 && page <= this.getState().totalPages) {
            this._config._state.page = page;
            this._updateData();
        }
    };
    // Method to show the loading spinner
    KTDataTable.prototype._showSpinner = function () {
        var spinner = this._element.querySelector(this._config.attributes.spinner) || this._createSpinner();
        if (spinner) {
            spinner.style.display = 'block';
        }
        this._element.classList.add(this._config.loadingClass);
    };
    // Method to hide the loading spinner
    KTDataTable.prototype._hideSpinner = function () {
        var spinner = this._element.querySelector(this._config.attributes.spinner);
        if (spinner) {
            spinner.style.display = 'none';
        }
        this._element.classList.remove(this._config.loadingClass);
    };
    // Method to create a spinner element if it doesn't exist
    KTDataTable.prototype._createSpinner = function () {
        if (typeof this._config.loading === 'undefined') {
            return null;
        }
        var template = document.createElement('template');
        template.innerHTML = this._config.loading.template
            .trim()
            .replace('{content}', this._config.loading.content);
        var spinner = template.content.firstChild;
        spinner.setAttribute('data-kt-datatable-spinner', 'true');
        this._tableElement.appendChild(spinner);
        return spinner;
    };
    /**
     * Saves the current state of the table to local storage.
     * @returns {void}
     */
    KTDataTable.prototype._saveState = function () {
        this._fireEvent('stateSave');
        this._dispatchEvent('stateSave');
        var ns = this._tableNamespace();
        if (ns) {
            localStorage.setItem(ns, JSON.stringify(this.getState()));
        }
    };
    /**
     * Loads the saved state of the table from local storage, if it exists.
     * @returns {Object} The saved state of the table, or null if no saved state exists.
     */
    KTDataTable.prototype._loadState = function () {
        var stateString = localStorage.getItem(this._tableNamespace());
        if (!stateString)
            return null;
        try {
            var state = JSON.parse(stateString);
            if (state)
                this._config._state = state;
            return state;
        }
        catch (_a) { } // eslint-disable-line no-empty
        return null;
    };
    KTDataTable.prototype._deleteState = function () {
        var ns = this._tableNamespace();
        if (ns) {
            localStorage.removeItem(ns);
        }
    };
    /**
     * Gets the namespace for the table's state.
     * If a namespace is specified in the config, it is used.
     * Otherwise, if the table element has an ID, it is used.
     * Otherwise, if the component element has an ID, it is used.
     * Finally, the component's UID is used.
     * @returns {string} The namespace for the table's state.
     */
    KTDataTable.prototype._tableNamespace = function () {
        var _a;
        // Use the specified namespace, if one is given
        if (this._config.stateNamespace) {
            return this._config.stateNamespace;
        }
        // Fallback to the component's UID
        return (_a = this._tableId()) !== null && _a !== void 0 ? _a : this._name;
    };
    KTDataTable.prototype._tableId = function () {
        var _a, _b;
        var id = null;
        // If the table element has an ID, use that
        if ((_a = this._tableElement) === null || _a === void 0 ? void 0 : _a.getAttribute('id')) {
            id = this._tableElement.getAttribute('id');
        }
        // If the component element has an ID, use that
        if ((_b = this._element) === null || _b === void 0 ? void 0 : _b.getAttribute('id')) {
            id = this._element.getAttribute('id');
        }
        return id;
    };
    KTDataTable.prototype._dispose = function () {
        // Remove all event listeners and clean up resources
    };
    KTDataTable.prototype._debounce = function (func, wait) {
        var timeout;
        return function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            var later = function () {
                clearTimeout(timeout);
                func.apply(void 0, args);
            };
            clearTimeout(timeout);
            timeout = window.setTimeout(later, wait);
        };
    };
    /**
     * Gets the current state of the table.
     * @returns {KTDataTableStateInterface} The current state of the table.
     */
    KTDataTable.prototype.getState = function () {
        return __assign({ 
            /**
             * The current page number.
             */
            page: 1, 
            /**
             * The field that the data is sorted by.
             */
            sortField: null, 
            /**
             * The sort order (ascending or descending).
             */
            sortOrder: '', 
            /**
             * The number of rows to display per page.
             */
            pageSize: this._config.pageSize, filters: [] }, this._config._state);
    };
    /**
     * Sorts the data in the table by the specified field.
     * @param field The field to sort by.
     */
    KTDataTable.prototype.sort = function (field) {
        // Use the sort handler to update state and trigger sorting
        var state = this.getState();
        var sortOrder = this._sortHandler.toggleSortOrder(state.sortField, state.sortOrder, field);
        this._sortHandler.setSortIcon(field, sortOrder);
        this._config._state.sortField = field;
        this._config._state.sortOrder = sortOrder;
        this._fireEvent('sort', { field: field, order: sortOrder });
        this._dispatchEvent('sort', { field: field, order: sortOrder });
        this._updateData();
    };
    /**
     * Navigates to the specified page in the data table.
     * @param page The page number to navigate to.
     */
    KTDataTable.prototype.goPage = function (page) {
        if (page < 1 || !Number.isInteger(page)) {
            return;
        }
        // Navigate to the specified page
        this._paginateData(page);
    };
    /**
     * Set the page size of the data table.
     * @param pageSize The new page size.
     */
    KTDataTable.prototype.setPageSize = function (pageSize) {
        if (!Number.isInteger(pageSize)) {
            return;
        }
        /**
         * Reload the page size of the data table.
         * @param pageSize The new page size.
         */
        this._reloadPageSize(pageSize);
    };
    /**
     * Reloads the data from the server and updates the table.
     * Triggers the 'reload' event and the 'kt.datatable.reload' custom event.
     */
    KTDataTable.prototype.reload = function () {
        this._fireEvent('reload');
        this._dispatchEvent('reload');
        // Fetch the data from the server using the current sort and filter settings
        this._updateData();
    };
    KTDataTable.prototype.redraw = function (page) {
        if (page === void 0) { page = 1; }
        this._fireEvent('redraw');
        this._dispatchEvent('redraw');
        this._paginateData(page);
    };
    /**
     * Show the loading spinner of the data table.
     */
    KTDataTable.prototype.showSpinner = function () {
        /**
         * Show the loading spinner of the data table.
         */
        this._showSpinner();
    };
    /**
     * Hide the loading spinner of the data table.
     */
    KTDataTable.prototype.hideSpinner = function () {
        /**
         * Hide the loading spinner of the data table.
         */
        this._hideSpinner();
    };
    /**
     * Filter data using the specified filter object.
     * Replaces the existing filter object for the column with the new one.
     * @param filter Filter object containing the column name and its value.
     * @returns The KTDataTable instance.
     * @throws Error if the filter object is null or undefined.
     */
    KTDataTable.prototype.setFilter = function (filter) {
        this._config._state.filters = __spreadArray(__spreadArray([], (this.getState().filters || []).filter(function (f) { return f.column !== filter.column; }), true), [
            filter,
        ], false);
        return this;
    };
    KTDataTable.prototype.dispose = function () {
        this._dispose();
    };
    KTDataTable.prototype.search = function (query) {
        this._config._state.search = query;
        this.reload();
    };
    /**
     * Create KTDataTable instances for all elements with a data-kt-datatable="true" attribute.
     *
     * This function should be called after the control(s) have been
     * loaded and parsed by the browser. It will create instances of
     * KTDataTable for all elements with a data-kt-datatable="true" attribute.
     */
    KTDataTable.createInstances = function () {
        var _this = this;
        var elements = document.querySelectorAll('[data-kt-datatable="true"]');
        elements.forEach(function (element) {
            if (element.hasAttribute('data-kt-datatable') &&
                !element.classList.contains('datatable-initialized')) {
                /**
                 * Create an instance of KTDataTable for the given element
                 * @param element The element to create an instance for
                 */
                var instance = new KTDataTable(element);
                _this._instances.set(element, instance);
            }
        });
    };
    /**
     * Get the KTDataTable instance for a given element.
     *
     * @param element The element to retrieve the instance for
     * @returns The KTDataTable instance or undefined if not found
     */
    KTDataTable.getInstance = function (element) {
        return this._instances.get(element);
    };
    /**
     * Initializes all KTDataTable instances on the page.
     *
     * This function should be called after the control(s) have been
     * loaded and parsed by the browser.
     */
    KTDataTable.init = function () {
        // Create instances of KTDataTable for all elements with a
        // data-kt-datatable="true" attribute
        KTDataTable.createInstances();
    };
    /**
     * Check if all visible rows are checked (header checkbox state)
     * @returns {boolean}
     */
    KTDataTable.prototype.isChecked = function () {
        return this._checkbox.isChecked();
    };
    /**
     * Toggle all visible row checkboxes (header checkbox)
     * @returns {void}
     */
    KTDataTable.prototype.toggle = function () {
        this._checkbox.toggle();
    };
    /**
     * Check all visible row checkboxes
     * @returns {void}
     */
    KTDataTable.prototype.check = function () {
        this._checkbox.check();
        this._fireEvent('checked');
        this._dispatchEvent('checked');
    };
    /**
     * Uncheck all visible row checkboxes
     * @returns {void}
     */
    KTDataTable.prototype.uncheck = function () {
        this._checkbox.uncheck();
        this._fireEvent('unchecked');
        this._dispatchEvent('unchecked');
    };
    /**
     * Get all checked row IDs (across all pages if preserveSelection is true)
     * @returns {string[]}
     */
    KTDataTable.prototype.getChecked = function () {
        return this._checkbox.getChecked();
    };
    /**
     * Reapply checked state to visible checkboxes (after redraw/pagination)
     * @returns {void}
     */
    KTDataTable.prototype.update = function () {
        this._checkbox.updateState();
    };
    /**
     * Static variables
     */
    KTDataTable._instances = new Map();
    return KTDataTable;
}(component_1.default));
exports.KTDataTable = KTDataTable;
if (typeof window !== 'undefined') {
    window.KTDataTable = KTDataTable;
}


/***/ }),

/***/ 6990:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


/**
 * KTUI - Free & Open-Source Tailwind UI Components by Keenthemes
 * Copyright 2025 by Keenthemes Inc
 */
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.KTModal = void 0;
var data_1 = __webpack_require__(8716);
var dom_1 = __webpack_require__(9010);
var event_handler_1 = __webpack_require__(5183);
var utils_1 = __webpack_require__(2599);
var component_1 = __webpack_require__(2658);
var KTModal = /** @class */ (function (_super) {
    __extends(KTModal, _super);
    function KTModal(element, config) {
        var _this = _super.call(this) || this;
        _this._name = 'modal';
        _this._defaultConfig = {
            zindex: '90',
            backdrop: true,
            backdropClass: 'kt-modal-backdrop',
            backdropStatic: false,
            keyboard: true,
            disableScroll: true,
            persistent: false,
            focus: true,
            hiddenClass: 'hidden',
        };
        _this._config = _this._defaultConfig;
        _this._isOpen = false;
        _this._isTransitioning = false;
        _this._backdropElement = null;
        _this._targetElement = null;
        if (data_1.default.has(element, _this._name))
            return _this;
        _this._init(element);
        _this._buildConfig(config);
        _this._handlers();
        return _this;
    }
    KTModal.prototype._handlers = function () {
        var _this = this;
        this._element.addEventListener('click', function (event) {
            if (_this._element !== event.target)
                return;
            if (_this._getOption('backdropStatic') === false) {
                _this._hide();
            }
        });
    };
    KTModal.prototype._toggle = function (targetElement) {
        var payload = { cancel: false };
        this._fireEvent('toggle', payload);
        this._dispatchEvent('toggle', payload);
        if (payload.cancel === true) {
            return;
        }
        if (this._isOpen === true) {
            this._hide();
        }
        else {
            this._show(targetElement);
        }
    };
    KTModal.prototype._show = function (targetElement) {
        var _this = this;
        if (this._isOpen || this._isTransitioning) {
            return;
        }
        if (targetElement)
            this._targetElement = targetElement;
        var payload = { cancel: false };
        this._fireEvent('show', payload);
        this._dispatchEvent('show', payload);
        if (payload.cancel === true) {
            return;
        }
        KTModal.hide();
        if (!this._element)
            return;
        this._isTransitioning = true;
        this._element.setAttribute('role', 'dialog');
        this._element.setAttribute('aria-modal', 'true');
        this._element.setAttribute('tabindex', '-1');
        this._setZindex();
        if (this._getOption('backdrop') === true)
            this._createBackdrop();
        if (this._getOption('disableScroll')) {
            document.body.style.overflow = 'hidden';
        }
        this._element.style.display = 'block';
        dom_1.default.reflow(this._element);
        this._element.classList.add('open');
        this._element.classList.remove(this._getOption('hiddenClass'));
        dom_1.default.transitionEnd(this._element, function () {
            _this._isTransitioning = false;
            _this._isOpen = true;
            if (_this._getOption('focus') === true) {
                _this._autoFocus();
            }
            _this._fireEvent('shown');
            _this._dispatchEvent('shown');
        });
    };
    KTModal.prototype._hide = function () {
        var _this = this;
        if (!this._element)
            return;
        if (this._isOpen === false || this._isTransitioning) {
            return;
        }
        var payload = { cancel: false };
        this._fireEvent('hide', payload);
        this._dispatchEvent('hide', payload);
        if (payload.cancel === true) {
            return;
        }
        this._isTransitioning = true;
        this._element.removeAttribute('role');
        this._element.removeAttribute('aria-modal');
        this._element.removeAttribute('tabindex');
        if (this._getOption('disableScroll')) {
            document.body.style.overflow = '';
        }
        dom_1.default.reflow(this._element);
        this._element.classList.remove('open');
        if (this._getOption('backdrop') === true) {
            this._deleteBackdrop();
        }
        dom_1.default.transitionEnd(this._element, function () {
            if (!_this._element)
                return;
            _this._isTransitioning = false;
            _this._isOpen = false;
            _this._element.style.display = '';
            _this._element.classList.add(_this._getOption('hiddenClass'));
            _this._fireEvent('hidden');
            _this._dispatchEvent('hidden');
        });
    };
    KTModal.prototype._setZindex = function () {
        var zindex = parseInt(this._getOption('zindex'));
        if (parseInt(dom_1.default.getCssProp(this._element, 'z-index')) > zindex) {
            zindex = parseInt(dom_1.default.getCssProp(this._element, 'z-index'));
        }
        if (dom_1.default.getHighestZindex(this._element) > zindex) {
            zindex = dom_1.default.getHighestZindex(this._element) + 1;
        }
        this._element.style.zIndex = String(zindex);
    };
    KTModal.prototype._autoFocus = function () {
        if (!this._element)
            return;
        var input = this._element.querySelector('[data-kt-modal-input-focus]');
        if (!input)
            return;
        else
            input.focus();
    };
    KTModal.prototype._createBackdrop = function () {
        if (!this._element)
            return;
        var zindex = parseInt(dom_1.default.getCssProp(this._element, 'z-index'));
        this._backdropElement = document.createElement('DIV');
        this._backdropElement.setAttribute('data-kt-modal-backdrop', 'true');
        this._backdropElement.style.zIndex = (zindex - 1).toString();
        document.body.append(this._backdropElement);
        dom_1.default.reflow(this._backdropElement);
        dom_1.default.addClass(this._backdropElement, this._getOption('backdropClass'));
    };
    KTModal.prototype._deleteBackdrop = function () {
        var _this = this;
        if (!this._backdropElement)
            return;
        dom_1.default.reflow(this._backdropElement);
        this._backdropElement.style.opacity = '0';
        dom_1.default.transitionEnd(this._backdropElement, function () {
            if (!_this._backdropElement)
                return;
            dom_1.default.remove(_this._backdropElement);
        });
    };
    KTModal.prototype.toggle = function (targetElement) {
        return this._toggle(targetElement);
    };
    KTModal.prototype.show = function (targetElement) {
        return this._show(targetElement);
    };
    KTModal.prototype.hide = function () {
        return this._hide();
    };
    KTModal.prototype.getTargetElement = function () {
        return this._targetElement;
    };
    KTModal.prototype.isOpen = function () {
        return this._isOpen;
    };
    KTModal.getInstance = function (element) {
        if (!element)
            return null;
        if (data_1.default.has(element, 'modal')) {
            return data_1.default.get(element, 'modal');
        }
        if (element.getAttribute('data-kt-modal')) {
            return new KTModal(element);
        }
        return null;
    };
    KTModal.getOrCreateInstance = function (element, config) {
        return this.getInstance(element) || new KTModal(element, config);
    };
    KTModal.hide = function () {
        var elements = document.querySelectorAll('[data-kt-modal-initialized]');
        elements.forEach(function (element) {
            var modal = KTModal.getInstance(element);
            if (modal && modal.isOpen()) {
                modal.hide();
            }
        });
    };
    KTModal.handleToggle = function () {
        event_handler_1.default.on(document.body, '[data-kt-modal-toggle]', 'click', function (event, target) {
            event.stopPropagation();
            var selector = target.getAttribute('data-kt-modal-toggle');
            if (!selector)
                return;
            var modalElement = document.querySelector(selector);
            var modal = KTModal.getInstance(modalElement);
            if (modal) {
                modal.toggle(target);
            }
        });
    };
    KTModal.handleDismiss = function () {
        event_handler_1.default.on(document.body, '[data-kt-modal-dismiss]', 'click', function (event, target) {
            event.stopPropagation();
            var modalElement = target.closest('[data-kt-modal-initialized]');
            if (modalElement) {
                var modal = KTModal.getInstance(modalElement);
                if (modal) {
                    modal.hide();
                }
            }
        });
    };
    KTModal.handleClickAway = function () {
        document.addEventListener('click', function (event) {
            var modalElement = document.querySelector('.open[data-kt-modal-initialized]');
            if (!modalElement)
                return;
            var modal = KTModal.getInstance(modalElement);
            if (!modal)
                return;
            if (utils_1.default.stringToBoolean(modal.getOption('persistent')) === true)
                return;
            if (utils_1.default.stringToBoolean(modal.getOption('backdrop')) === true)
                return;
            if (modalElement !== event.target &&
                modal.getTargetElement() !== event.target &&
                modalElement.contains(event.target) === false) {
                modal.hide();
            }
        });
    };
    KTModal.handleKeyword = function () {
        document.addEventListener('keydown', function (event) {
            var modalElement = document.querySelector('.open[data-kt-modal-initialized]');
            var modal = KTModal.getInstance(modalElement);
            if (!modal) {
                return;
            }
            // if esc key was not pressed in combination with ctrl or alt or shift
            if (event.key === 'Escape' &&
                !(event.ctrlKey || event.altKey || event.shiftKey)) {
                modal.hide();
            }
            if (event.code === 'Tab' && !event.metaKey) {
                return;
            }
        });
    };
    KTModal.createInstances = function () {
        var elements = document.querySelectorAll('[data-kt-modal]');
        elements.forEach(function (element) {
            new KTModal(element);
        });
    };
    KTModal.init = function () {
        KTModal.createInstances();
        if (window.KT_MODAL_INITIALIZED !== true) {
            KTModal.handleToggle();
            KTModal.handleDismiss();
            KTModal.handleClickAway();
            KTModal.handleKeyword();
            window.KT_MODAL_INITIALIZED = true;
        }
    };
    return KTModal;
}(component_1.default));
exports.KTModal = KTModal;
if (typeof window !== 'undefined') {
    window.KTModal = KTModal;
}


/***/ }),

/***/ 7125:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


/**
 * KTUI - Free & Open-Source Tailwind UI Components by Keenthemes
 * Copyright 2025 by Keenthemes Inc
 */
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.KTSelectDropdown = void 0;
var core_1 = __webpack_require__(3915);
var dom_1 = __webpack_require__(9010);
var data_1 = __webpack_require__(8716);
var component_1 = __webpack_require__(2658);
var utils_1 = __webpack_require__(9011);
/**
 * KTSelectDropdown
 *
 * A specialized dropdown implementation for the KTSelect component.
 * This module handles the dropdown functionality for the select component,
 * including positioning and showing/hiding.
 */
var KTSelectDropdown = /** @class */ (function (_super) {
    __extends(KTSelectDropdown, _super);
    /**
     * Constructor
     * @param element The parent element (select wrapper)
     * @param toggleElement The element that triggers the dropdown
     * @param dropdownElement The dropdown content element
     * @param config The configuration options
     */
    function KTSelectDropdown(element, toggleElement, dropdownElement, config, ktSelectInstance) {
        var _this = _super.call(this) || this;
        _this._name = 'select-dropdown';
        // State
        _this._isOpen = false;
        _this._isTransitioning = false;
        _this._popperInstance = null;
        _this._element = element;
        _this._toggleElement = toggleElement;
        _this._dropdownElement = dropdownElement;
        _this._config = config;
        _this._ktSelectInstance = ktSelectInstance; // Assign instance
        var container = _this._resolveDropdownContainer();
        if (container) {
            if (container !== _this._dropdownElement.parentElement) {
                container.appendChild(_this._dropdownElement);
            }
        }
        _this._eventManager = new utils_1.EventManager();
        _this._focusManager = new utils_1.FocusManager(dropdownElement, '[data-kt-select-option]', config);
        _this._setupEventListeners();
        return _this;
    }
    /**
     * Set up event listeners for the dropdown
     */
    KTSelectDropdown.prototype._setupEventListeners = function () {
        // Toggle click
        this._eventManager.addListener(this._toggleElement, 'click', this._handleToggleClick.bind(this));
        // Close on outside click
        this._eventManager.addListener(document, 'click', this._handleOutsideClick.bind(this));
    };
    /**
     * Handle toggle element click
     */
    KTSelectDropdown.prototype._handleToggleClick = function (event) {
        event.preventDefault();
        event.stopPropagation();
        if (this._config.disabled) {
            if (this._config.debug)
                console.log('KTSelectDropdown._handleToggleClick: select is disabled');
            return;
        }
        // Call KTSelect's methods
        if (this._ktSelectInstance.isDropdownOpen()) {
            this._ktSelectInstance.closeDropdown();
        }
        else {
            this._ktSelectInstance.openDropdown();
        }
    };
    /**
     * Handle clicks outside the dropdown
     */
    KTSelectDropdown.prototype._handleOutsideClick = function (event) {
        if (!this._isOpen)
            return;
        var target = event.target;
        if (!this._element.contains(target) &&
            !this._dropdownElement.contains(target)) {
            // Call KTSelect's closeDropdown method
            this._ktSelectInstance.closeDropdown();
        }
    };
    /**
     * Set width of dropdown based on toggle element
     */
    KTSelectDropdown.prototype._setDropdownWidth = function () {
        if (!this._dropdownElement || !this._toggleElement)
            return;
        // Check if width is configured
        if (this._config.dropdownWidth) {
            // If custom width is set, use that
            this._dropdownElement.style.width = this._config.dropdownWidth;
        }
        else {
            // Otherwise, match toggle element width for a cleaner appearance
            var toggleWidth = this._toggleElement.offsetWidth;
            this._dropdownElement.style.width = "".concat(toggleWidth, "px");
        }
    };
    /**
     * Initialize the Popper instance for dropdown positioning
     */
    KTSelectDropdown.prototype._initPopper = function () {
        // Destroy existing popper instance if it exists
        this._destroyPopper();
        // Default offset
        var offsetValue = '0, 5';
        // Get configuration options
        var placement = this._config.dropdownPlacement || 'bottom-start';
        var strategy = this._config.dropdownStrategy || 'fixed';
        var preventOverflow = this._config.dropdownPreventOverflow !== false;
        var flip = this._config.dropdownFlip !== false;
        // Create new popper instance
        this._popperInstance = (0, core_1.createPopper)(this._toggleElement, this._dropdownElement, {
            placement: placement,
            strategy: strategy,
            modifiers: [
                {
                    name: 'offset',
                    options: {
                        offset: this._parseOffset(offsetValue),
                    },
                },
                {
                    name: 'preventOverflow',
                    options: {
                        boundary: 'viewport',
                        altAxis: preventOverflow,
                    },
                },
                {
                    name: 'flip',
                    options: {
                        enabled: flip,
                        fallbackPlacements: ['top-start', 'bottom-end', 'top-end'],
                    },
                },
                {
                    name: 'sameWidth',
                    enabled: !this._config.dropdownWidth,
                    phase: 'beforeWrite',
                    requires: ['computeStyles'],
                    fn: function (_a) {
                        var state = _a.state;
                        state.styles.popper.width = "".concat(state.rects.reference.width, "px");
                    },
                    effect: function (_a) {
                        var state = _a.state;
                        // Add type guard for HTMLElement
                        var reference = state.elements.reference;
                        if (reference && 'offsetWidth' in reference) {
                            state.elements.popper.style.width = "".concat(reference.offsetWidth, "px");
                        }
                    },
                },
            ],
        });
    };
    /**
     * Parse offset string into an array of numbers
     */
    KTSelectDropdown.prototype._parseOffset = function (offset) {
        return offset.split(',').map(function (value) { return parseInt(value.trim(), 10); });
    };
    /**
     * Destroy the Popper instance
     */
    KTSelectDropdown.prototype._destroyPopper = function () {
        if (this._popperInstance) {
            this._popperInstance.destroy();
            this._popperInstance = null;
        }
    };
    /**
     * Update dropdown position
     */
    KTSelectDropdown.prototype.updatePosition = function () {
        if (this._popperInstance) {
            this._popperInstance.update();
        }
    };
    /**
     * Open the dropdown
     */
    KTSelectDropdown.prototype.open = function () {
        var _this = this;
        if (this._config.disabled) {
            if (this._config.debug)
                console.log('KTSelectDropdown.open: select is disabled, not opening');
            return;
        }
        if (this._isOpen || this._isTransitioning)
            return;
        // Begin opening transition
        this._isTransitioning = true;
        // Set initial styles
        this._dropdownElement.classList.remove('hidden');
        this._dropdownElement.style.opacity = '0';
        // Set dropdown width
        this._setDropdownWidth();
        // Reflow
        dom_1.default.reflow(this._dropdownElement);
        // Apply z-index
        var zIndexToApply = null;
        if (this._config.dropdownZindex) {
            zIndexToApply = this._config.dropdownZindex;
        }
        // Consider the dropdown's current z-index if it's already set and higher
        var currentDropdownZIndexStr = dom_1.default.getCssProp(this._dropdownElement, 'z-index');
        if (currentDropdownZIndexStr && currentDropdownZIndexStr !== 'auto') {
            var currentDropdownZIndex = parseInt(currentDropdownZIndexStr);
            if (!isNaN(currentDropdownZIndex) && currentDropdownZIndex > (zIndexToApply || 0)) {
                zIndexToApply = currentDropdownZIndex;
            }
        }
        // Ensure dropdown is above elements within its original toggle's parent context
        var toggleParentContextZindex = dom_1.default.getHighestZindex(this._element); // _element is the select wrapper
        if (toggleParentContextZindex !== null && toggleParentContextZindex >= (zIndexToApply || 0)) {
            zIndexToApply = toggleParentContextZindex + 1;
        }
        if (zIndexToApply !== null) {
            this._dropdownElement.style.zIndex = zIndexToApply.toString();
        }
        // Initialize popper
        this._initPopper();
        // Add active classes for visual state
        this._dropdownElement.classList.add('open');
        this._toggleElement.classList.add('active');
        // ARIA attributes will be handled by KTSelect
        // Start transition
        this._dropdownElement.style.opacity = '1';
        // Handle transition end
        dom_1.default.transitionEnd(this._dropdownElement, function () {
            _this._isTransitioning = false;
            _this._isOpen = true;
            // Focus and events will be handled by KTSelect
        });
    };
    /**
     * Close the dropdown
     */
    KTSelectDropdown.prototype.close = function () {
        var _this = this;
        if (this._config.debug)
            console.log('KTSelectDropdown.close called - isOpen:', this._isOpen, 'isTransitioning:', this._isTransitioning);
        if (!this._isOpen || this._isTransitioning) {
            if (this._config.debug)
                console.log('KTSelectDropdown.close - early return: dropdown not open or is transitioning');
            return;
        }
        // Events and ARIA will be handled by KTSelect
        if (this._config.debug)
            console.log('KTSelectDropdown.close - starting transition');
        this._isTransitioning = true;
        this._dropdownElement.style.opacity = '0';
        var transitionComplete = false;
        var fallbackTimer = setTimeout(function () {
            if (!transitionComplete) {
                if (_this._config.debug)
                    console.log('KTSelectDropdown.close - fallback timer triggered');
                completeTransition();
            }
        }, 300);
        var completeTransition = function () {
            if (transitionComplete)
                return;
            transitionComplete = true;
            clearTimeout(fallbackTimer);
            if (_this._config.debug)
                console.log('KTSelectDropdown.close - transition ended');
            _this._dropdownElement.classList.add('hidden');
            _this._dropdownElement.classList.remove('open');
            _this._toggleElement.classList.remove('active');
            // ARIA attributes will be handled by KTSelect
            _this._destroyPopper();
            _this._isTransitioning = false;
            _this._isOpen = false;
            // Events will be handled by KTSelect
            if (_this._config.debug)
                console.log('KTSelectDropdown.close - visual part complete');
        };
        dom_1.default.transitionEnd(this._dropdownElement, completeTransition);
        if (dom_1.default.getCssProp(this._dropdownElement, 'transition-duration') === '0s') {
            completeTransition();
        }
    };
    /**
     * Check if dropdown is open
     */
    KTSelectDropdown.prototype.isOpen = function () {
        return this._isOpen;
    };
    /**
     * Clean up component
     */
    KTSelectDropdown.prototype.dispose = function () {
        // Destroy popper
        this._destroyPopper();
        // Remove event listeners
        this._eventManager.removeAllListeners(this._element);
        this._eventManager.removeAllListeners(this._toggleElement);
        this._eventManager.removeAllListeners(document);
        // Clean up focus manager
        if (this._focusManager &&
            typeof this._focusManager.dispose === 'function') {
            this._focusManager.dispose();
        }
        // Clean up state
        this._isOpen = false;
        this._isTransitioning = false;
        // Remove data reference
        data_1.default.remove(this._element, this._name);
    };
    KTSelectDropdown.prototype._resolveDropdownContainer = function () {
        var containerSelector = this._config.dropdownContainer;
        if (containerSelector && containerSelector !== 'body') {
            var containerElement = document.querySelector(containerSelector);
            if (!containerElement && this._config.debug) {
                console.warn("KTSelectDropdown: dropdownContainer selector \"".concat(containerSelector, "\" not found. Dropdown will remain in its default position."));
            }
            return containerElement;
        }
        else if (containerSelector === 'body') {
            return document.body;
        }
        return null;
    };
    return KTSelectDropdown;
}(component_1.default));
exports.KTSelectDropdown = KTSelectDropdown;


/***/ }),

/***/ 7402:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


/**
 * KTUI - Free & Open-Source Tailwind UI Components by Keenthemes
 * Copyright 2025 by Keenthemes Inc
 */
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.KTDismiss = void 0;
var data_1 = __webpack_require__(8716);
var dom_1 = __webpack_require__(9010);
var component_1 = __webpack_require__(2658);
var KTDismiss = /** @class */ (function (_super) {
    __extends(KTDismiss, _super);
    function KTDismiss(element, config) {
        var _this = _super.call(this) || this;
        _this._name = 'dismiss';
        _this._defaultConfig = {
            hiddenClass: 'hidden',
            mode: 'remove',
            interrupt: true,
            target: '',
        };
        _this._config = _this._defaultConfig;
        _this._isAnimating = false;
        _this._targetElement = null;
        if (data_1.default.has(element, _this._name))
            return _this;
        _this._init(element);
        _this._buildConfig(config);
        _this._config['mode'] = _this._config['mode'];
        if (!_this._element)
            return _this;
        _this._targetElement = _this._getTargetElement();
        if (!_this._targetElement) {
            return _this;
        }
        _this._handlers();
        return _this;
    }
    KTDismiss.prototype._getTargetElement = function () {
        return (dom_1.default.getElement(this._element.getAttribute('data-kt-dismiss')) || dom_1.default.getElement(this._getOption('target')));
    };
    KTDismiss.prototype._handlers = function () {
        var _this = this;
        if (!this._element)
            return;
        this._element.addEventListener('click', function (event) {
            event.preventDefault();
            if (_this._getOption('interrupt') === true) {
                event.stopPropagation();
            }
            _this._dismiss();
        });
    };
    KTDismiss.prototype._dismiss = function () {
        var _this = this;
        if (this._isAnimating) {
            return;
        }
        var payload = { cancel: false };
        this._fireEvent('dismiss', payload);
        this._dispatchEvent('dismiss', payload);
        if (payload.cancel === true) {
            return;
        }
        if (!this._targetElement)
            return;
        this._targetElement.style.opacity = '0';
        dom_1.default.reflow(this._targetElement);
        this._isAnimating = true;
        dom_1.default.transitionEnd(this._targetElement, function () {
            if (!_this._targetElement)
                return;
            _this._isAnimating = false;
            _this._targetElement.style.opacity = '';
            if (_this._getOption('mode').toString().toLowerCase() === 'hide') {
                _this._targetElement.classList.add(_this._getOption('hiddenClass'));
            }
            else {
                dom_1.default.remove(_this._targetElement);
            }
            _this._fireEvent('dismissed');
            _this._dispatchEvent('dismissed');
        });
    };
    KTDismiss.prototype.getTargetElement = function () {
        return this._targetElement;
    };
    KTDismiss.prototype.dismiss = function () {
        this._dismiss();
    };
    KTDismiss.getInstance = function (element) {
        if (!element)
            return null;
        if (data_1.default.has(element, 'dismiss')) {
            return data_1.default.get(element, 'dismiss');
        }
        if (element.getAttribute('data-kt-dismiss')) {
            return new KTDismiss(element);
        }
        return null;
    };
    KTDismiss.getOrCreateInstance = function (element, config) {
        return this.getInstance(element) || new KTDismiss(element, config);
    };
    KTDismiss.createInstances = function () {
        var elements = document.querySelectorAll('[data-kt-dismiss]');
        elements.forEach(function (element) {
            new KTDismiss(element);
        });
    };
    KTDismiss.init = function () {
        KTDismiss.createInstances();
    };
    return KTDismiss;
}(component_1.default));
exports.KTDismiss = KTDismiss;
if (typeof window !== 'undefined') {
    window.KTDismiss = KTDismiss;
}


/***/ }),

/***/ 7490:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


/**
 * KTUI - Free & Open-Source Tailwind UI Components by Keenthemes
 * Copyright 2025 by Keenthemes Inc
 */
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.KTTogglePassword = void 0;
var data_1 = __webpack_require__(8716);
var component_1 = __webpack_require__(2658);
var KTTogglePassword = /** @class */ (function (_super) {
    __extends(KTTogglePassword, _super);
    function KTTogglePassword(element, config) {
        if (config === void 0) { config = null; }
        var _this = _super.call(this) || this;
        _this._name = 'toggle-password';
        _this._defaultConfig = {
            permanent: false,
        };
        _this._config = _this._defaultConfig;
        if (data_1.default.has(element, _this._name))
            return _this;
        _this._init(element);
        _this._buildConfig(config);
        _this._triggerElement = _this._element.querySelector('[data-kt-toggle-password-trigger]');
        _this._inputElement = _this._element.querySelector('input');
        if (!_this._triggerElement || !_this._inputElement) {
            return _this;
        }
        _this._handlers();
        return _this;
    }
    KTTogglePassword.prototype._handlers = function () {
        var _this = this;
        if (!this._element)
            return;
        this._triggerElement.addEventListener('click', function () {
            _this._toggle();
        });
        this._inputElement.addEventListener('input', function () {
            _this._update();
        });
    };
    KTTogglePassword.prototype._toggle = function () {
        if (!this._element)
            return;
        var payload = { cancel: false };
        this._fireEvent('toggle', payload);
        this._dispatchEvent('toggle', payload);
        if (payload.cancel === true) {
            return;
        }
        if (this._isVisible()) {
            this._element.classList.remove('active');
            this._setVisible(false);
        }
        else {
            this._element.classList.add('active');
            this._setVisible(true);
        }
        this._fireEvent('toggled');
        this._dispatchEvent('toggled');
    };
    KTTogglePassword.prototype._update = function () {
        if (!this._element)
            return;
        if (this._getOption('permanent') === false) {
            if (this._isVisible()) {
                this._setVisible(false);
            }
        }
    };
    KTTogglePassword.prototype._isVisible = function () {
        return this._inputElement.getAttribute('type') === 'text';
    };
    KTTogglePassword.prototype._setVisible = function (flag) {
        if (flag) {
            this._inputElement.setAttribute('type', 'text');
        }
        else {
            this._inputElement.setAttribute('type', 'password');
        }
    };
    KTTogglePassword.prototype.toggle = function () {
        this._toggle();
    };
    KTTogglePassword.prototype.setVisible = function (flag) {
        this._setVisible(flag);
    };
    KTTogglePassword.prototype.isVisible = function () {
        return this._isVisible();
    };
    KTTogglePassword.getInstance = function (element) {
        if (!element)
            return null;
        if (data_1.default.has(element, 'toggle-password')) {
            return data_1.default.get(element, 'toggle-password');
        }
        if (element.getAttribute('data-kt-toggle-password')) {
            return new KTTogglePassword(element);
        }
        return null;
    };
    KTTogglePassword.getOrCreateInstance = function (element, config) {
        return this.getInstance(element) || new KTTogglePassword(element, config);
    };
    KTTogglePassword.createInstances = function () {
        var elements = document.querySelectorAll('[data-kt-toggle-password]');
        elements.forEach(function (element) {
            new KTTogglePassword(element);
        });
    };
    KTTogglePassword.init = function () {
        KTTogglePassword.createInstances();
    };
    return KTTogglePassword;
}(component_1.default));
exports.KTTogglePassword = KTTogglePassword;
if (typeof window !== 'undefined') {
    window.KTTogglePassword = KTTogglePassword;
}


/***/ }),

/***/ 7586:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


/**
 * KTUI - Free & Open-Source Tailwind UI Components by Keenthemes
 * Copyright 2025 by Keenthemes Inc
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.KTDismiss = void 0;
var dismiss_1 = __webpack_require__(7402);
Object.defineProperty(exports, "KTDismiss", ({ enumerable: true, get: function () { return dismiss_1.KTDismiss; } }));


/***/ }),

/***/ 7620:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


/**
 * KTUI - Free & Open-Source Tailwind UI Components by Keenthemes
 * Copyright 2025 by Keenthemes Inc
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.KTSelectSearch = void 0;
var templates_1 = __webpack_require__(9069);
var utils_1 = __webpack_require__(9011);
var KTSelectSearch = /** @class */ (function () {
    function KTSelectSearch(select) {
        this._noResultsElement = null;
        this._originalOptionContents = new Map();
        this._select = select;
        this._searchInput = select.getSearchInput();
        this._eventManager = new utils_1.EventManager();
        this._focusManager = new utils_1.FocusManager(this._select.getDropdownElement(), '[data-kt-select-option]', select.getConfig());
        this.handleSearchInput = this._handleSearchInput.bind(this);
        this._config = select.getConfig();
        this._cacheOriginalOptionContents();
    }
    KTSelectSearch.prototype.init = function () {
        var _this = this;
        if (this._select.getConfig().enableSearch) {
            this._searchInput = this._select.getSearchInput();
            if (this._searchInput) {
                if (this._config.debug)
                    console.log('Initializing search module with input:', this._searchInput);
                // First remove any existing listeners to prevent duplicates
                this._removeEventListeners();
                // Add the input event listener for filtering
                this._eventManager.addListener(this._searchInput, 'input', this.handleSearchInput);
                // Add keydown event listener for navigation, selection, and escape
                this._eventManager.addListener(this._searchInput, 'keydown', this._handleSearchKeyDown.bind(this));
                // Add blur event listener to ensure highlights are cleared when focus is lost
                this._eventManager.addListener(this._searchInput, 'blur', function () {
                    // Small delay to prevent race conditions with selection
                    setTimeout(function () {
                        if (!_this._searchInput.value) {
                            _this._resetAllOptions();
                            _this.clearSearch();
                        }
                    }, 100);
                });
                // Listen for remote search events to coordinate with remote search functionality
                if (this._select.getConfig().remote &&
                    this._select.getConfig().searchParam) {
                    this._select
                        .getElement()
                        .addEventListener('remoteSearchStart', function () {
                        // Reset focused option when remote search starts
                        _this._focusManager.resetFocus();
                    });
                    this._select.getElement().addEventListener('remoteSearchEnd', function () {
                        // After remote search completes, refresh our option cache
                        _this.refreshOptionCache();
                    });
                }
                // Listen for dropdown close to reset options - ATTACH TO WRAPPER
                this._select.getWrapperElement().addEventListener('dropdown.close', function () {
                    _this._focusManager.resetFocus();
                    // If clearSearchOnClose is false and there's a value, the search term and filtered state should persist.
                    // KTSelect's closeDropdown method already calls this._searchModule.clearSearch() (which clears highlights)
                    // and conditionally clears the input value based on KTSelect's config.clearSearchOnClose.
                    // This listener in search.ts seems to unconditionally clear everything.
                    // For now, keeping its original behavior:
                    _this.clearSearch(); // Clears highlights from current options
                    _this._searchInput.value = ''; // Clears the search input field
                    _this._resetAllOptions(); // Shows all options, restores original text, removes highlights
                    _this._clearNoResultsMessage(); // Clears any "no results" message
                });
                // Clear highlights when an option is selected - ATTACH TO ORIGINAL SELECT (standard 'change' event)
                this._select.getElement().addEventListener('change', function () {
                    _this.clearSearch();
                    // Close dropdown only for single select mode
                    // Keep dropdown open for multiple select mode to allow additional selections
                    if (!_this._select.getConfig().multiple) {
                        _this._select.closeDropdown();
                    }
                });
                // Consolidated 'dropdown.show' event listener - ATTACH TO WRAPPER
                this._select.getWrapperElement().addEventListener('dropdown.show', function () {
                    var _a;
                    _this._focusManager.resetFocus(); // Always clear previous focus state
                    if ((_a = _this._searchInput) === null || _a === void 0 ? void 0 : _a.value) {
                        // If there's an existing search term:
                        // 1. Re-filter options. This ensures the display (hidden/visible) is correct
                        //    and "no results" message is handled if query yields nothing.
                        _this._filterOptions(_this._searchInput.value);
                    }
                    else {
                        // If search input is empty:
                        // 1. Reset all options to their full, unfiltered, original state.
                        _this._resetAllOptions(); // Shows all, clears highlights from options, restores original text
                        // 2. Clear any "no results" message.
                        _this._clearNoResultsMessage();
                    }
                    // Handle autofocus for the search input (this was one of the original separate listeners)
                    if (_this._select.getConfig().searchAutofocus) {
                        setTimeout(function () {
                            var _a;
                            (_a = _this._searchInput) === null || _a === void 0 ? void 0 : _a.focus(); // Focus search input
                        }, 50); // Delay to ensure dropdown is visible
                    }
                });
            }
        }
    };
    /**
     * Remove event listeners to prevent memory leaks or duplicates
     */
    KTSelectSearch.prototype._removeEventListeners = function () {
        if (this._searchInput) {
            this._eventManager.removeAllListeners(this._searchInput);
        }
    };
    /**
     * Handles keydown events on the search input for navigation and actions.
     */
    KTSelectSearch.prototype._handleSearchKeyDown = function (event) {
        var key = event.key;
        switch (key) {
            case 'ArrowDown':
                event.preventDefault();
                this._focusManager.focusNext();
                break;
            case 'ArrowUp':
                event.preventDefault();
                this._focusManager.focusPrevious();
                break;
            case 'Enter':
                event.preventDefault();
                // Always attempt to select the first available option in the list.
                // focusFirst() finds, focuses, and returns the first visible, non-disabled option.
                var firstAvailableOption = this._focusManager.focusFirst();
                if (firstAvailableOption) {
                    var optionValue = firstAvailableOption.getAttribute('data-value');
                    if (optionValue) {
                        this._select.toggleSelection(optionValue);
                        // KTSelect.toggleSelection handles closing the dropdown based on config.closeOnSelect and config.multiple
                    }
                }
                break;
            case 'Escape':
                event.preventDefault();
                this._searchInput.value = '';
                this.clearSearch();
                this._resetAllOptions();
                this._clearNoResultsMessage();
                this._focusManager.focusFirst();
                break;
            default:
                break;
        }
    };
    /**
     * Store original HTML content of all options for later restoration
     * This prevents losing formatting when clearing search
     */
    KTSelectSearch.prototype._cacheOriginalOptionContents = function () {
        var _this = this;
        // Wait for options to be initialized
        setTimeout(function () {
            _this._originalOptionContents.clear(); // Clear before re-caching
            var options = Array.from(_this._select.getOptionsElement());
            options.forEach(function (option) {
                var value = option.getAttribute('data-value');
                if (value) {
                    // Store the full innerHTML as the original content
                    _this._originalOptionContents.set(value, option.innerHTML);
                }
            });
        }, 0);
    };
    /**
     * Restores the innerHTML of all options from the cache if they have been modified.
     * This is typically called before applying new filters/highlights.
     */
    KTSelectSearch.prototype._restoreOptionContentsBeforeFilter = function () {
        var _this = this;
        var options = Array.from(this._select.getOptionsElement());
        options.forEach(function (option) {
            var value = option.getAttribute('data-value');
            if (value && _this._originalOptionContents.has(value)) {
                var originalContent = _this._originalOptionContents.get(value);
                // Only restore if current content is different, to avoid unnecessary DOM manipulation
                if (option.innerHTML !== originalContent) {
                    option.innerHTML = originalContent;
                }
            }
        });
    };
    KTSelectSearch.prototype._handleSearchInput = function (event) {
        var query = event.target.value;
        var config = this._select.getConfig();
        // Reset focused option when search changes
        this._focusManager.resetFocus();
        // Restore original content for all options before filtering/highlighting again
        this._restoreOptionContentsBeforeFilter();
        if (query.trim() === '') {
            this._resetAllOptions();
            this._focusManager.focusFirst(); // Focus first option when search is cleared
            return;
        }
        // For remote search, KTSelect component handles it.
        // KTSelect will call refreshAfterSearch on this module when remote data is updated.
        if (config.remote && config.searchParam) {
            if (query.length < config.searchMinLength) {
                this._resetAllOptions();
                this._clearNoResultsMessage();
                this._focusManager.focusFirst(); // Focus first if query too short
            }
            return;
        }
        // For local search
        if (query.length >= config.searchMinLength) {
            this._filterOptions(query);
            this._focusManager.focusFirst(); // Focus first visible option after local filtering
        }
        else {
            this._resetAllOptions();
            this._clearNoResultsMessage();
            this._focusManager.focusFirst(); // Focus first if query too short and not remote
        }
    };
    KTSelectSearch.prototype._filterOptions = function (query) {
        var _this = this;
        var options = Array.from(this._select.getOptionsElement());
        var config = this._select.getConfig();
        var dropdownElement = this._select.getDropdownElement();
        // Cache original option HTML if not already cached
        if (this._originalOptionContents.size === 0) {
            this._cacheOriginalOptionContents();
        }
        // Restore original content before filtering, so highlighting is applied fresh.
        this._restoreOptionContentsBeforeFilter();
        var visibleCount = (0, utils_1.filterOptions)(options, query, config, dropdownElement, function (count) {
            return _this._handleNoResults(count);
        });
    };
    /**
     * Reset all options to their original state
     */
    KTSelectSearch.prototype._resetAllOptions = function () {
        var _this = this;
        // Show all options
        var options = Array.from(this._select.getOptionsElement());
        // Ensure the cache is populated if it's somehow empty here
        if (this._originalOptionContents.size === 0) {
            this._cacheOriginalOptionContents();
        }
        options.forEach(function (option) {
            option.classList.remove('hidden');
            if (option.style.display === 'none')
                option.style.display = ''; // Ensure visible
            // Restore original HTML content (remove highlights)
            var value = option.getAttribute('data-value');
            if (value && _this._originalOptionContents.has(value)) {
                var originalContent = _this._originalOptionContents.get(value);
                // Only update if different, to minimize DOM changes
                if (option.innerHTML !== originalContent) {
                    option.innerHTML = originalContent;
                }
            }
        });
        this._clearNoResultsMessage(); // Ensure no results message is cleared when resetting
    };
    KTSelectSearch.prototype._handleNoResults = function (visibleOptionsCount) {
        var _a, _b;
        if (visibleOptionsCount === 0 && ((_b = (_a = this._searchInput) === null || _a === void 0 ? void 0 : _a.value) === null || _b === void 0 ? void 0 : _b.trim()) !== '') {
            this._showNoResultsMessage();
        }
        else {
            this._clearNoResultsMessage();
        }
    };
    KTSelectSearch.prototype._showNoResultsMessage = function () {
        this._clearNoResultsMessage();
        var config = this._select.getConfig();
        this._noResultsElement = templates_1.defaultTemplates.searchEmpty(config);
        var dropdownElement = this._select.getDropdownElement();
        var optionsContainer = dropdownElement.querySelector('[data-kt-select-options]');
        if (optionsContainer) {
            optionsContainer.appendChild(this._noResultsElement);
        }
        else {
            dropdownElement.appendChild(this._noResultsElement);
        }
    };
    KTSelectSearch.prototype._clearNoResultsMessage = function () {
        if (this._noResultsElement && this._noResultsElement.parentNode) {
            this._noResultsElement.parentNode.removeChild(this._noResultsElement);
            this._noResultsElement = null;
        }
    };
    /**
     * Public method to explicitly clear all search highlights
     * This is called when search is reset or selection changes
     */
    KTSelectSearch.prototype.clearSearch = function () {
        var _this = this;
        // Restore original option content (removes highlighting)
        var optionsToClear = Array.from(this._select.getOptionsElement());
        // Ensure cache is available
        if (this._originalOptionContents.size === 0 && optionsToClear.length > 0) {
            this._cacheOriginalOptionContents();
        }
        optionsToClear.forEach(function (option) {
            var value = option.getAttribute('data-value');
            if (value && _this._originalOptionContents.has(value)) {
                var originalContent = _this._originalOptionContents.get(value);
                // Only restore if different
                if (option.innerHTML !== originalContent) {
                    option.innerHTML = originalContent;
                }
            }
        });
    };
    /**
     * This ensures that search highlighting works correctly with new options
     */
    KTSelectSearch.prototype.refreshOptionCache = function () {
        var _this = this;
        // Re-cache all option contents
        this._originalOptionContents.clear();
        var currentOptions = Array.from(this._select.getOptionsElement());
        currentOptions.forEach(function (option) {
            var value = option.getAttribute('data-value');
            if (value) {
                _this._originalOptionContents.set(value, option.innerHTML);
            }
        });
    };
    /**
     * Called after search (local or remote via KTSelect) to reset focus.
     */
    KTSelectSearch.prototype.refreshAfterSearch = function () {
        this._focusManager.resetFocus();
        this._focusManager.focusFirst();
        // Re-cache original contents as options might have changed (especially after remote search)
        this.refreshOptionCache();
    };
    /**
     * Clean up all resources used by the search module
     */
    KTSelectSearch.prototype.destroy = function () {
        // Remove all event listeners
        this._removeEventListeners();
        // Clear all references
        if (this._focusManager) {
            this._focusManager.dispose();
        }
        // Clear cached content
        this._originalOptionContents.clear();
        // Clear highlight elements
        this.clearSearch();
    };
    return KTSelectSearch;
}());
exports.KTSelectSearch = KTSelectSearch;


/***/ }),

/***/ 7727:
/***/ (function(__unused_webpack_module, exports) {


/**
 * KTUI - Free & Open-Source Tailwind UI Components by Keenthemes
 * Copyright 2025 by Keenthemes Inc
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DefaultLocales = exports.generateLocaleConfig = void 0;
/**
 * Generates a locale configuration object based on the given locale and first day of the week.
 *
 * @param {string} locale - The locale code to generate the configuration for.
 * @param {number} firstDayOfWeek - The first day of the week, where 0 represents Sunday.
 * @return {LocaleConfigInterface} The generated locale configuration object.
 */
var generateLocaleConfig = function (locale, firstDayOfWeek) { return ({
    // Names of months (e.g., January, February, ...)
    monthNames: Array.from({ length: 12 }, function (_, month) {
        return new Date(0, month).toLocaleString(locale, { month: 'long' });
    }),
    // Shortened names of months (e.g., Jan, Feb, ...)
    monthNamesShort: Array.from({ length: 12 }, function (_, month) {
        return new Date(0, month).toLocaleString(locale, { month: 'short' });
    }),
    // Names of days of the week (e.g., Sunday, Monday, ...)
    dayNames: Array.from({ length: 7 }, function (_, day) {
        return new Date(0, 0, day + 1).toLocaleString(locale, { weekday: 'long' });
    }),
    // Shortened names of days of the week (e.g., Sun, Mon, ...)
    dayNamesShort: Array.from({ length: 7 }, function (_, day) {
        return new Date(0, 0, day + 1).toLocaleString(locale, { weekday: 'short' });
    }),
    // The first day of the week is the first day of the week in the selected locale
    firstDayOfWeek: firstDayOfWeek,
    // Names of days of the week, abbreviated (e.g., S, M, ...)
    dayNamesMin: Array.from({ length: 7 }, function (_, day) {
        return new Date(0, 0, day + 1).toLocaleString(locale, { weekday: 'narrow' });
    }),
}); };
exports.generateLocaleConfig = generateLocaleConfig;
exports.DefaultLocales = {
    // English (United States)
    'en-US': (0, exports.generateLocaleConfig)('en-US', 0),
    // Chinese (China)
    'zh-CN': (0, exports.generateLocaleConfig)('zh-CN', 0),
    // Spanish (Spain)
    'es-ES': (0, exports.generateLocaleConfig)('es-ES', 1),
    // French (France)
    'fr-FR': (0, exports.generateLocaleConfig)('fr-FR', 1),
    // Russian (Russia)
    'ru-RU': (0, exports.generateLocaleConfig)('ru-RU', 1),
    // Japanese (Japan)
    'ja-JP': (0, exports.generateLocaleConfig)('ja-JP', 0),
    // Korean (South Korea)
    'ko-KR': (0, exports.generateLocaleConfig)('ko-KR', 0),
    // Indonesian (Indonesia)
    'id-ID': (0, exports.generateLocaleConfig)('id-ID', 0),
    // Malay (Malaysia)
    'ms-MY': (0, exports.generateLocaleConfig)('ms-MY', 1),
    // Italian (Italy)
    'it-IT': (0, exports.generateLocaleConfig)('it-IT', 1),
    // Portuguese (Portugal)
    'pt-PT': (0, exports.generateLocaleConfig)('pt-PT', 1),
    // German (Germany)
    'de-DE': (0, exports.generateLocaleConfig)('de-DE', 1),
    // Chinese (Hong Kong)
    'zh-HK': (0, exports.generateLocaleConfig)('zh-HK', 0),
    // Chinese (Taiwan)
    'zh-TW': (0, exports.generateLocaleConfig)('zh-TW', 0),
    // Vietnamese (Vietnam)
    'vi-VN': (0, exports.generateLocaleConfig)('vi-VN', 0),
    // Turkish (Turkey)
    'tr-TR': (0, exports.generateLocaleConfig)('tr-TR', 1),
    // Thai (Thailand)
    'th-TH': (0, exports.generateLocaleConfig)('th-TH', 0),
    // Arabic (Egypt)
    'ar-EG': (0, exports.generateLocaleConfig)('ar-EG', 0),
};


/***/ }),

/***/ 7952:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


/**
 * KTUI - Free & Open-Source Tailwind UI Components by Keenthemes
 * Copyright 2025 by Keenthemes Inc
 */
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.KTDatepicker = void 0;
var component_1 = __webpack_require__(2658);
var calendar_1 = __webpack_require__(9364);
var config_1 = __webpack_require__(6292);
var keyboard_1 = __webpack_require__(8151);
var utils_1 = __webpack_require__(2393);
var templates_1 = __webpack_require__(9619);
var events_1 = __webpack_require__(5795);
// Helper function to replace stringToElement
function createElement(html) {
    var template = document.createElement('template');
    template.innerHTML = html.trim();
    return template.content.firstChild;
}
/**
 * KTDatepicker - Main datepicker component class
 * Manages the datepicker functionality and integration with input elements
 */
var KTDatepicker = /** @class */ (function (_super) {
    __extends(KTDatepicker, _super);
    /**
     * Constructor for the KTDatepicker class.
     */
    function KTDatepicker(element, config) {
        var _this = _super.call(this) || this;
        _this._name = 'datepicker';
        _this._dateInputElement = null;
        _this._startDateInputElement = null;
        _this._endDateInputElement = null;
        _this._displayElement = null;
        _this._useSegmentedDisplay = false;
        _this._displayWrapper = null;
        _this._displayText = null;
        _this._currentDate = null;
        _this._currentRange = null;
        _this._segmentFocused = null;
        // Check if the element already has a datepicker instance attached to it
        if (element.getAttribute('data-kt-datepicker-initialized') === 'true') {
            return _this;
        }
        // Initialize the datepicker with the provided element
        _this._init(element);
        // Build the configuration object by merging the default config with the provided config
        _this._buildConfig(config);
        // Store the instance of the datepicker directly on the element
        element.instance = _this;
        // Ensure the element is focusable
        _this._element.setAttribute('tabindex', '0');
        _this._element.classList.add('kt-datepicker', 'relative', 'focus:outline-none');
        // Mark as initialized
        _this._element.setAttribute('data-kt-datepicker-initialized', 'true');
        // Find input elements
        _this._initializeInputElements();
        // Create display element if needed
        _this._createDisplayElement();
        // Create state manager first
        _this._state = new config_1.KTDatepickerStateManager(_this._element, _this._config);
        _this._config = _this._state.getConfig();
        // Initialize the calendar and keyboard after creating the state manager
        _this._calendar = new calendar_1.KTDatepickerCalendar(_this._element, _this._state);
        _this._keyboard = new keyboard_1.KTDatepickerKeyboard(_this._element, _this._state);
        // Initialize event manager
        _this._eventManager = _this._state.getEventManager();
        // Set up event listeners
        _this._setupEventListeners();
        // Initialize with any default values
        _this._initializeDefaultValues();
        return _this;
    }
    /**
     * Initialize input elements
     */
    KTDatepicker.prototype._initializeInputElements = function () {
        // Get main input element - will be hidden
        this._dateInputElement = this._element.querySelector('[data-kt-datepicker-input]');
        // Hide the input element and make it only for data storage
        if (this._dateInputElement) {
            this._dateInputElement.classList.add('hidden', 'sr-only');
            this._dateInputElement.setAttribute('aria-hidden', 'true');
            this._dateInputElement.tabIndex = -1;
        }
        // Get range input elements if applicable
        this._startDateInputElement = this._element.querySelector('[data-kt-datepicker-start]');
        this._endDateInputElement = this._element.querySelector('[data-kt-datepicker-end]');
        // Get display element if exists
        this._displayElement = this._element.querySelector('[data-kt-datepicker-display]');
        // Check if we should use segmented display
        this._useSegmentedDisplay =
            this._element.hasAttribute('data-kt-datepicker-segmented') ||
                this._element.hasAttribute('data-kt-datepicker-segmented-input');
    };
    /**
     * Create display element for datepicker
     */
    KTDatepicker.prototype._createDisplayElement = function () {
        var _this = this;
        var _a;
        // Skip if already created
        if (this._displayElement) {
            return;
        }
        // Get format from config or use default
        var format = this._config.format || 'mm/dd/yyyy';
        var placeholder = ((_a = this._dateInputElement) === null || _a === void 0 ? void 0 : _a.getAttribute('placeholder')) || format;
        // Create wrapper for display element
        this._displayWrapper = document.createElement('div');
        this._displayWrapper.className =
            'kt-datepicker-display-wrapper kt-datepicker-display-segment';
        this._displayWrapper.setAttribute('role', 'combobox');
        this._displayWrapper.setAttribute('aria-haspopup', 'dialog');
        this._displayWrapper.setAttribute('aria-expanded', 'false');
        this._element.appendChild(this._displayWrapper);
        if (this._useSegmentedDisplay) {
            // Create segmented display for better date part selection
            var displayContainer = document.createElement('div');
            displayContainer.className = 'kt-datepicker-display-element';
            displayContainer.setAttribute('tabindex', '0');
            displayContainer.setAttribute('role', 'textbox');
            displayContainer.setAttribute('aria-label', placeholder);
            displayContainer.setAttribute('data-kt-datepicker-display', '');
            // Add segmented template based on range mode
            if (this._config.range) {
                displayContainer.innerHTML = (0, templates_1.segmentedDateRangeInputTemplate)(this._config.format || 'mm/dd/yyyy');
            }
            else {
                displayContainer.innerHTML = (0, templates_1.segmentedDateInputTemplate)(this._config.format || 'mm/dd/yyyy');
            }
            this._displayElement = displayContainer;
            this._displayWrapper.appendChild(this._displayElement);
            // Add click handlers for segments
            var segments = this._displayElement.querySelectorAll('[data-segment]');
            segments.forEach(function (segment) {
                segment.addEventListener('click', function (e) {
                    e.stopPropagation();
                    var segmentType = segment.getAttribute('data-segment');
                    _this._handleSegmentClick(segmentType);
                });
            });
        }
        else {
            // Create simple display element
            this._displayElement = document.createElement('div');
            this._displayElement.className = 'kt-datepicker-display-element';
            this._displayElement.setAttribute('tabindex', '0');
            this._displayElement.setAttribute('role', 'textbox');
            this._displayElement.setAttribute('aria-label', placeholder);
            this._displayElement.setAttribute('data-placeholder', placeholder);
            this._displayElement.setAttribute('data-kt-datepicker-display', '');
            // Create display text element
            this._displayText = document.createElement('span');
            this._displayText.className = 'kt-datepicker-display-text';
            this._displayText.textContent = placeholder;
            this._displayText.classList.add('text-gray-400');
            this._displayElement.appendChild(this._displayText);
            this._displayWrapper.appendChild(this._displayElement);
        }
        // Add click event to display element
        this._displayElement.addEventListener('click', function (e) {
            e.preventDefault();
            if (!_this._state.getState().isOpen) {
                _this._state.setOpen(true);
            }
        });
        // Enhanced keyboard event handling for display element
        this._displayElement.addEventListener('keydown', function (e) {
            if (e.key === 'Enter' || e.key === ' ' || e.key === 'ArrowDown') {
                e.preventDefault();
                e.stopPropagation();
                // If not already open, open the dropdown
                if (!_this._state.getState().isOpen) {
                    _this._state.setOpen(true);
                    // Dispatch a custom event to notify about the keyboard open
                    _this._eventManager.dispatchKeyboardOpenEvent();
                }
            }
        });
    };
    /**
     * Handle segment click to focus and open appropriate view
     *
     * @param segmentType - Type of segment clicked
     */
    KTDatepicker.prototype._handleSegmentClick = function (segmentType) {
        if (!segmentType)
            return;
        // Store the focused segment
        this._segmentFocused = segmentType;
        // Remove highlight from all segments
        this._removeSegmentHighlights();
        // Add highlight to clicked segment
        if (this._displayElement) {
            var segment = this._displayElement.querySelector("[data-segment=\"".concat(segmentType, "\"]"));
            if (segment) {
                segment.classList.add('kt-datepicker-segment-focused');
            }
        }
        // Set the appropriate view mode based on segment type
        if (segmentType.includes('day')) {
            // Day segment - open in days view (default)
            this._state.setViewMode('days');
            this._state.setOpen(true);
        }
        else if (segmentType.includes('month')) {
            // Month segment - open in months view
            this._state.setViewMode('months');
            this._state.setOpen(true);
        }
        else if (segmentType.includes('year')) {
            // Year segment - open in years view
            this._state.setViewMode('years');
            this._state.setOpen(true);
        }
    };
    /**
     * Set up event listeners
     */
    KTDatepicker.prototype._setupEventListeners = function () {
        var _this = this;
        // Listen for state changes
        this._eventManager.addEventListener(events_1.KTDatepickerEventName.STATE_CHANGE, function (e) {
            var state = e.detail.state;
            // Update ARIA attributes based on open state
            if (_this._displayWrapper) {
                _this._displayWrapper.setAttribute('aria-expanded', state.isOpen.toString());
            }
            // Update display when closing
            if (!state.isOpen && state.prevIsOpen) {
                _this._syncDisplayWithSelectedDate();
            }
        });
        // Set up change event listener to update input values
        this._eventManager.addEventListener(events_1.KTDatepickerEventName.DATE_CHANGE, this._handleDateChange.bind(this));
        // Add keyboard events to the root element
        this._element.addEventListener('keydown', function (e) {
            if (e.key === 'Enter' || e.key === ' ' || e.key === 'ArrowDown') {
                var state = _this._state.getState();
                if (!state.isOpen) {
                    e.preventDefault();
                    _this._state.setOpen(true);
                }
            }
        });
        // Add keyboard navigation for segments
        if (this._displayElement && this._useSegmentedDisplay) {
            this._displayElement.addEventListener('keydown', this._handleSegmentKeydown.bind(this));
        }
    };
    /**
     * Handle keyboard navigation between segments
     *
     * @param e - Keyboard event
     */
    KTDatepicker.prototype._handleSegmentKeydown = function (e) {
        // Only handle if we have a focused segment
        if (!this._segmentFocused)
            return;
        var target = e.target;
        var segmentType = target.getAttribute('data-segment');
        if (!segmentType)
            return;
        // Handle keyboard navigation
        switch (e.key) {
            case 'ArrowLeft':
                e.preventDefault();
                this._navigateSegments('prev', segmentType);
                break;
            case 'ArrowRight':
                e.preventDefault();
                this._navigateSegments('next', segmentType);
                break;
            case 'Tab':
                // Let default tab behavior work, but update focus segment when tabbing
                this._segmentFocused = segmentType;
                // Remove highlight from all segments
                this._removeSegmentHighlights();
                // Add highlight to current segment
                target.classList.add('segment-focused');
                break;
            case 'Enter':
            case ' ':
                e.preventDefault();
                this._handleSegmentClick(segmentType);
                break;
        }
    };
    /**
     * Navigate between segments with keyboard
     *
     * @param direction - 'prev' or 'next'
     * @param currentSegment - Current segment identifier
     */
    KTDatepicker.prototype._navigateSegments = function (direction, currentSegment) {
        if (!this._displayElement)
            return;
        // Define segment order
        var segments;
        if (this._config.range) {
            segments = [
                'start-month',
                'start-day',
                'start-year',
                'end-month',
                'end-day',
                'end-year',
            ];
        }
        else {
            segments = ['month', 'day', 'year'];
        }
        // Find current index
        var currentIndex = segments.indexOf(currentSegment);
        if (currentIndex === -1)
            return;
        // Calculate new index
        var newIndex;
        if (direction === 'prev') {
            newIndex = currentIndex === 0 ? segments.length - 1 : currentIndex - 1;
        }
        else {
            newIndex = currentIndex === segments.length - 1 ? 0 : currentIndex + 1;
        }
        // Find new segment element
        var newSegment = this._displayElement.querySelector("[data-segment=\"".concat(segments[newIndex], "\"]"));
        if (!newSegment)
            return;
        // Update focus
        newSegment.focus();
        this._segmentFocused = segments[newIndex];
        // Remove highlight from all segments
        this._removeSegmentHighlights();
        // Add highlight to new segment
        newSegment.classList.add('segment-focused');
    };
    /**
     * Remove highlight from all segments
     */
    KTDatepicker.prototype._removeSegmentHighlights = function () {
        if (!this._displayElement)
            return;
        var segments = this._displayElement.querySelectorAll('.segment-part');
        segments.forEach(function (segment) {
            segment.classList.remove('segment-focused');
        });
    };
    /**
     * Sync display element with the selected date
     */
    KTDatepicker.prototype._syncDisplayWithSelectedDate = function () {
        var _a;
        if (!this._displayElement)
            return;
        var state = this._state.getState();
        var selectedDate = state.selectedDate;
        var selectedDateRange = state.selectedDateRange;
        if (this._useSegmentedDisplay) {
            // Update segmented display elements
            if (selectedDate) {
                // Single date
                var daySegment = this._displayElement.querySelector('[data-segment="day"]');
                var monthSegment = this._displayElement.querySelector('[data-segment="month"]');
                var yearSegment = this._displayElement.querySelector('[data-segment="year"]');
                if (daySegment) {
                    daySegment.textContent = selectedDate
                        .getDate()
                        .toString()
                        .padStart(2, '0');
                }
                if (monthSegment) {
                    monthSegment.textContent = (selectedDate.getMonth() + 1)
                        .toString()
                        .padStart(2, '0');
                }
                if (yearSegment) {
                    yearSegment.textContent = selectedDate.getFullYear().toString();
                }
            }
            else if (selectedDateRange && selectedDateRange.startDate) {
                // Range selection
                var startDay = this._displayElement.querySelector('[data-segment="start-day"]');
                var startMonth = this._displayElement.querySelector('[data-segment="start-month"]');
                var startYear = this._displayElement.querySelector('[data-segment="start-year"]');
                if (startDay) {
                    startDay.textContent = selectedDateRange.startDate
                        .getDate()
                        .toString()
                        .padStart(2, '0');
                }
                if (startMonth) {
                    startMonth.textContent = (selectedDateRange.startDate.getMonth() + 1)
                        .toString()
                        .padStart(2, '0');
                }
                if (startYear) {
                    startYear.textContent = selectedDateRange.startDate
                        .getFullYear()
                        .toString();
                }
                if (selectedDateRange.endDate) {
                    var endDay = this._displayElement.querySelector('[data-segment="end-day"]');
                    var endMonth = this._displayElement.querySelector('[data-segment="end-month"]');
                    var endYear = this._displayElement.querySelector('[data-segment="end-year"]');
                    if (endDay) {
                        endDay.textContent = selectedDateRange.endDate
                            .getDate()
                            .toString()
                            .padStart(2, '0');
                    }
                    if (endMonth) {
                        endMonth.textContent = (selectedDateRange.endDate.getMonth() + 1)
                            .toString()
                            .padStart(2, '0');
                    }
                    if (endYear) {
                        endYear.textContent = selectedDateRange.endDate
                            .getFullYear()
                            .toString();
                    }
                }
            }
        }
        else if (this._displayText) {
            // Simple display
            if (selectedDate) {
                // Clear placeholder styling
                this._displayText.classList.remove('placeholder');
                // Format date(s) based on config
                if (this._config.range &&
                    selectedDateRange &&
                    selectedDateRange.startDate &&
                    selectedDateRange.endDate) {
                    this._displayText.textContent = "".concat((0, utils_1.formatDate)(selectedDateRange.startDate, this._config.format, this._config), " - ").concat((0, utils_1.formatDate)(selectedDateRange.endDate, this._config.format, this._config));
                }
                else {
                    this._displayText.textContent = (0, utils_1.formatDate)(selectedDate, this._config.format, this._config);
                }
            }
            else {
                // No date selected, show format as placeholder
                var placeholder = ((_a = this._displayElement) === null || _a === void 0 ? void 0 : _a.getAttribute('data-placeholder')) ||
                    this._config.format;
                this._displayText.textContent = placeholder;
                this._displayText.classList.add('placeholder');
            }
        }
    };
    /**
     * Handle date change events
     *
     * @param e - Custom event with date change details
     */
    KTDatepicker.prototype._handleDateChange = function (e) {
        var _a;
        var detail = (_a = e.detail) === null || _a === void 0 ? void 0 : _a.payload;
        if (!detail)
            return;
        // Handle single date selection
        if (detail.selectedDate) {
            var formattedDate = (0, utils_1.formatDate)(detail.selectedDate, this._config.format, this._config);
            // Update hidden input value
            if (this._dateInputElement) {
                this._dateInputElement.value = formattedDate;
                // Dispatch change event on input to trigger form validation
                this._dateInputElement.dispatchEvent(new Event('change', { bubbles: true }));
            }
            // Update display element
            this._updateDisplayElement(detail.selectedDate);
        }
        // Handle date range selection
        if (detail.selectedDateRange && this._config.range) {
            var _b = detail.selectedDateRange, startDate = _b.startDate, endDate = _b.endDate;
            // Format the range for the hidden input
            if (this._dateInputElement) {
                var displayValue = '';
                if (startDate) {
                    displayValue = (0, utils_1.formatDate)(startDate, this._config.format, this._config);
                    if (endDate) {
                        var endFormatted = (0, utils_1.formatDate)(endDate, this._config.format, this._config);
                        displayValue += "".concat(this._config.rangeSeparator).concat(endFormatted);
                    }
                }
                this._dateInputElement.value = displayValue;
                // Dispatch change event on input
                this._dateInputElement.dispatchEvent(new Event('change', { bubbles: true }));
            }
            // Update individual start/end inputs if they exist
            if (this._startDateInputElement && startDate) {
                this._startDateInputElement.value = (0, utils_1.formatDate)(startDate, this._config.format, this._config);
                this._startDateInputElement.dispatchEvent(new Event('change', { bubbles: true }));
            }
            if (this._endDateInputElement && endDate) {
                this._endDateInputElement.value = (0, utils_1.formatDate)(endDate, this._config.format, this._config);
                this._endDateInputElement.dispatchEvent(new Event('change', { bubbles: true }));
            }
            // Update display element for range
            this._updateRangeDisplayElement(startDate, endDate);
        }
    };
    /**
     * Update the display element for a single date
     *
     * @param date - The date to display
     */
    KTDatepicker.prototype._updateDisplayElement = function (date) {
        var _a;
        if (!this._displayElement)
            return;
        if (!date) {
            // If no date, show placeholder
            var placeholder = ((_a = this._dateInputElement) === null || _a === void 0 ? void 0 : _a.getAttribute('placeholder')) || 'Select date';
            this._displayElement.innerHTML = (0, templates_1.placeholderTemplate)(placeholder);
            return;
        }
        if (this._useSegmentedDisplay) {
            // Update segmented display
            var day = date.getDate();
            var month = date.getMonth() + 1;
            var year = date.getFullYear();
            var daySegment = this._displayElement.querySelector('[data-segment="day"]');
            var monthSegment = this._displayElement.querySelector('[data-segment="month"]');
            var yearSegment = this._displayElement.querySelector('[data-segment="year"]');
            if (daySegment)
                daySegment.textContent = day < 10 ? "0".concat(day) : "".concat(day);
            if (monthSegment)
                monthSegment.textContent = month < 10 ? "0".concat(month) : "".concat(month);
            if (yearSegment)
                yearSegment.textContent = "".concat(year);
        }
        else {
            // Simple display
            this._displayElement.textContent = (0, utils_1.formatDate)(date, this._config.format, this._config);
        }
    };
    /**
     * Update the display element for a date range
     *
     * @param startDate - The start date of the range
     * @param endDate - The end date of the range
     */
    KTDatepicker.prototype._updateRangeDisplayElement = function (startDate, endDate) {
        var _a;
        if (!this._displayElement)
            return;
        if (!startDate) {
            // If no date, show placeholder
            var placeholder = ((_a = this._dateInputElement) === null || _a === void 0 ? void 0 : _a.getAttribute('placeholder')) ||
                'Select date range';
            this._displayElement.innerHTML = (0, templates_1.placeholderTemplate)(placeholder);
            return;
        }
        if (this._useSegmentedDisplay) {
            // Update segmented range display
            // Start date segments
            var startDay = this._displayElement.querySelector('[data-segment="start-day"]');
            var startMonth = this._displayElement.querySelector('[data-segment="start-month"]');
            var startYear = this._displayElement.querySelector('[data-segment="start-year"]');
            if (startDay)
                startDay.textContent =
                    startDate.getDate() < 10
                        ? "0".concat(startDate.getDate())
                        : "".concat(startDate.getDate());
            if (startMonth)
                startMonth.textContent =
                    startDate.getMonth() + 1 < 10
                        ? "0".concat(startDate.getMonth() + 1)
                        : "".concat(startDate.getMonth() + 1);
            if (startYear)
                startYear.textContent = "".concat(startDate.getFullYear());
            // End date segments
            if (endDate) {
                var endDay = this._displayElement.querySelector('[data-segment="end-day"]');
                var endMonth = this._displayElement.querySelector('[data-segment="end-month"]');
                var endYear = this._displayElement.querySelector('[data-segment="end-year"]');
                if (endDay)
                    endDay.textContent =
                        endDate.getDate() < 10
                            ? "0".concat(endDate.getDate())
                            : "".concat(endDate.getDate());
                if (endMonth)
                    endMonth.textContent =
                        endDate.getMonth() + 1 < 10
                            ? "0".concat(endDate.getMonth() + 1)
                            : "".concat(endDate.getMonth() + 1);
                if (endYear)
                    endYear.textContent = "".concat(endDate.getFullYear());
            }
        }
        else {
            // Simple display
            var displayText = (0, utils_1.formatDate)(startDate, this._config.format, this._config);
            if (endDate) {
                var endFormatted = (0, utils_1.formatDate)(endDate, this._config.format, this._config);
                displayText += "".concat(this._config.rangeSeparator).concat(endFormatted);
            }
            this._displayElement.textContent = displayText;
        }
    };
    /**
     * Handle input change events
     *
     * @param e - Input change event
     */
    KTDatepicker.prototype._handleInputChange = function (e) {
        var input = e.target;
        var inputValue = input.value.trim();
        if (!inputValue) {
            // Clear selection if input is empty
            this._state.setSelectedDate(null);
            return;
        }
        if (this._config.range) {
            // Handle range input
            var rangeParts = inputValue.split(this._config.rangeSeparator);
            if (rangeParts.length === 2) {
                var startDate = (0, utils_1.parseDate)(rangeParts[0].trim(), this._config.format, this._config);
                var endDate = (0, utils_1.parseDate)(rangeParts[1].trim(), this._config.format, this._config);
                // Validate dates are within min/max constraints
                if (startDate && (0, utils_1.isDateDisabled)(startDate, this._config)) {
                    console.log('Start date from input is outside allowed range:', startDate.toISOString());
                    return;
                }
                if (endDate && (0, utils_1.isDateDisabled)(endDate, this._config)) {
                    console.log('End date from input is outside allowed range:', endDate.toISOString());
                    return;
                }
                if (startDate && endDate) {
                    this.setDateRange(startDate, endDate);
                }
            }
            else if (rangeParts.length === 1) {
                var singleDate = (0, utils_1.parseDate)(rangeParts[0].trim(), this._config.format, this._config);
                // Validate date is within min/max constraints
                if (singleDate && (0, utils_1.isDateDisabled)(singleDate, this._config)) {
                    console.log('Date from input is outside allowed range:', singleDate.toISOString());
                    return;
                }
                if (singleDate) {
                    this.setDateRange(singleDate, null);
                }
            }
        }
        else {
            // Handle single date input
            var parsedDate = (0, utils_1.parseDate)(inputValue, this._config.format, this._config);
            // Validate date is within min/max constraints
            if (parsedDate && (0, utils_1.isDateDisabled)(parsedDate, this._config)) {
                console.log('Date from input is outside allowed range:', parsedDate.toISOString());
                return;
            }
            if (parsedDate) {
                this.setDate(parsedDate);
            }
        }
    };
    /**
     * Initialize with default values from input
     */
    KTDatepicker.prototype._initializeDefaultValues = function () {
        // Set min and max dates from attributes if they exist
        var minDateAttr = this._element.getAttribute('data-kt-datepicker-min-date');
        var maxDateAttr = this._element.getAttribute('data-kt-datepicker-max-date');
        if (minDateAttr) {
            var minDate = (0, utils_1.parseDate)(minDateAttr, this._config.format, this._config);
            if (minDate) {
                this.setMinDate(minDate);
            }
        }
        if (maxDateAttr) {
            var maxDate = (0, utils_1.parseDate)(maxDateAttr, this._config.format, this._config);
            if (maxDate) {
                this.setMaxDate(maxDate);
            }
        }
        // Check for default value in main input
        if (this._dateInputElement && this._dateInputElement.value) {
            this._handleInputChange({
                target: this._dateInputElement,
            });
        }
        // Check for default values in range inputs
        else if (this._config.range &&
            this._startDateInputElement &&
            this._startDateInputElement.value) {
            var startDate = (0, utils_1.parseDate)(this._startDateInputElement.value, this._config.format, this._config);
            var endDate = null;
            if (this._endDateInputElement && this._endDateInputElement.value) {
                endDate = (0, utils_1.parseDate)(this._endDateInputElement.value, this._config.format, this._config);
            }
            if (startDate) {
                this.setDateRange(startDate, endDate);
            }
        }
    };
    /**
     * ========================================================================
     * Public API
     * ========================================================================
     */
    /**
     * Get the currently selected date
     *
     * @returns Selected date, null if no selection, or date range object
     */
    KTDatepicker.prototype.getDate = function () {
        var state = this._state.getState();
        var config = this._state.getConfig();
        if (config.range) {
            return state.selectedDateRange || { startDate: null, endDate: null };
        }
        else {
            return state.selectedDate;
        }
    };
    /**
     * Set the selected date
     *
     * @param date - Date to select or null to clear selection
     */
    KTDatepicker.prototype.setDate = function (date) {
        // Skip if the date is disabled (outside min/max range)
        if (date && (0, utils_1.isDateDisabled)(date, this._config)) {
            console.log('Date is disabled in setDate, ignoring selection:', date.toISOString());
            return;
        }
        this._state.setSelectedDate(date);
        if (date) {
            this._state.setCurrentDate(date);
        }
        // Update the display
        this._updateDisplayElement(date);
        // Update hidden input
        if (this._dateInputElement && date) {
            this._dateInputElement.value = (0, utils_1.formatDate)(date, this._config.format, this._config);
            this._dateInputElement.dispatchEvent(new Event('change', { bubbles: true }));
        }
        else if (this._dateInputElement) {
            this._dateInputElement.value = '';
            this._dateInputElement.dispatchEvent(new Event('change', { bubbles: true }));
        }
    };
    /**
     * Get the currently selected date range
     *
     * @returns Selected date range or null if no selection
     */
    KTDatepicker.prototype.getDateRange = function () {
        var state = this._state.getState();
        return state.selectedDateRange;
    };
    /**
     * Set the selected date range
     *
     * @param start - Start date of the range
     * @param end - End date of the range
     */
    KTDatepicker.prototype.setDateRange = function (start, end) {
        var _a;
        var state = this._state.getState();
        // Ensure we're in range mode
        if (!this._config.range) {
            console.warn('Cannot set date range when range mode is disabled');
            return;
        }
        // Validate start and end dates are within min/max range
        if (start && (0, utils_1.isDateDisabled)(start, this._config)) {
            console.log('Start date is disabled in setDateRange, ignoring selection:', start.toISOString());
            return;
        }
        if (end && (0, utils_1.isDateDisabled)(end, this._config)) {
            console.log('End date is disabled in setDateRange, ignoring selection:', end.toISOString());
            return;
        }
        // Reset range selection state
        this._state.getState().isRangeSelectionStart = true;
        // Set start date
        if (start) {
            if (!state.selectedDateRange) {
                state.selectedDateRange = { startDate: null, endDate: null };
            }
            state.selectedDateRange.startDate = start;
            this._state.setCurrentDate(start);
            // Set end date if provided
            if (end) {
                state.selectedDateRange.endDate = end;
            }
            else {
                state.selectedDateRange.endDate = null;
            }
            // Update display element
            this._updateRangeDisplayElement(start, end);
            // Update hidden inputs
            if (this._dateInputElement) {
                var inputValue = (0, utils_1.formatDate)(start, this._config.format, this._config);
                if (end) {
                    inputValue += "".concat(this._config.rangeSeparator).concat((0, utils_1.formatDate)(end, this._config.format, this._config));
                }
                this._dateInputElement.value = inputValue;
                this._dateInputElement.dispatchEvent(new Event('change', { bubbles: true }));
            }
            if (this._startDateInputElement) {
                this._startDateInputElement.value = (0, utils_1.formatDate)(start, this._config.format, this._config);
                this._startDateInputElement.dispatchEvent(new Event('change', { bubbles: true }));
            }
            if (this._endDateInputElement && end) {
                this._endDateInputElement.value = (0, utils_1.formatDate)(end, this._config.format, this._config);
                this._endDateInputElement.dispatchEvent(new Event('change', { bubbles: true }));
            }
            else if (this._endDateInputElement) {
                this._endDateInputElement.value = '';
            }
            // Dispatch change event
            this._eventManager.dispatchEvent(events_1.KTDatepickerEventName.DATE_CHANGE, {
                selectedDateRange: state.selectedDateRange,
            });
        }
        else {
            // Clear selection
            this._state.getState().selectedDateRange = null;
            // Clear display
            if (this._displayElement) {
                var placeholder = ((_a = this._dateInputElement) === null || _a === void 0 ? void 0 : _a.getAttribute('placeholder')) ||
                    'Select date range';
                this._displayElement.innerHTML = (0, templates_1.placeholderTemplate)(placeholder);
            }
            // Clear inputs
            if (this._dateInputElement) {
                this._dateInputElement.value = '';
                this._dateInputElement.dispatchEvent(new Event('change', { bubbles: true }));
            }
            if (this._startDateInputElement) {
                this._startDateInputElement.value = '';
                this._startDateInputElement.dispatchEvent(new Event('change', { bubbles: true }));
            }
            if (this._endDateInputElement) {
                this._endDateInputElement.value = '';
                this._endDateInputElement.dispatchEvent(new Event('change', { bubbles: true }));
            }
            this._eventManager.dispatchEvent(events_1.KTDatepickerEventName.DATE_CHANGE, {
                selectedDateRange: null,
            });
        }
    };
    /**
     * Set the minimum selectable date
     *
     * @param minDate - Minimum date or null to remove constraint
     */
    KTDatepicker.prototype.setMinDate = function (minDate) {
        this._config.minDate = minDate;
        // Refresh calendar view to apply new constraints
        this._eventManager.dispatchEvent(events_1.KTDatepickerEventName.UPDATE);
    };
    /**
     * Set the maximum selectable date
     *
     * @param maxDate - Maximum date or null to remove constraint
     */
    KTDatepicker.prototype.setMaxDate = function (maxDate) {
        this._config.maxDate = maxDate;
        // Refresh calendar view to apply new constraints
        this._eventManager.dispatchEvent(events_1.KTDatepickerEventName.UPDATE);
    };
    /**
     * Update the datepicker (refresh view)
     */
    KTDatepicker.prototype.update = function () {
        // Trigger calendar update through events
        this._eventManager.dispatchEvent(events_1.KTDatepickerEventName.UPDATE);
    };
    /**
     * Destroy the datepicker instance and clean up
     */
    KTDatepicker.prototype.destroy = function () {
        // Remove event listeners
        this._eventManager.removeEventListener(events_1.KTDatepickerEventName.DATE_CHANGE, this._handleDateChange.bind(this));
        if (this._dateInputElement) {
            this._dateInputElement.removeEventListener('change', this._handleInputChange.bind(this));
        }
        if (this._displayElement) {
            this._displayElement.remove();
        }
        // Remove instance from element
        this._element.removeAttribute('data-kt-datepicker-initialized');
        delete this._element.instance;
        // Remove initialized class
        this._element.classList.remove('relative');
        // Remove from instances map
        KTDatepicker._instances.delete(this._element);
    };
    /**
     * Dispatch a custom event
     *
     * @param eventName - Name of the event
     * @param payload - Optional event payload
     */
    KTDatepicker.prototype._dispatchEvent = function (eventName, payload) {
        this._eventManager.dispatchEvent(eventName, payload);
    };
    /**
     * Create instances for all datepicker elements on the page
     */
    KTDatepicker.createInstances = function () {
        var _this = this;
        var elements = document.querySelectorAll('[data-kt-datepicker]');
        elements.forEach(function (element) {
            if (element.hasAttribute('data-kt-datepicker') &&
                !element.getAttribute('data-kt-datepicker-initialized')) {
                // Create instance
                var instance = new KTDatepicker(element);
                _this._instances.set(element, instance);
            }
        });
    };
    /**
     * Initialize all datepickers on the page
     */
    KTDatepicker.init = function () {
        KTDatepicker.createInstances();
    };
    /**
     * ========================================================================
     * Static instances
     * ========================================================================
     */
    KTDatepicker._instances = new Map();
    return KTDatepicker;
}(component_1.default));
exports.KTDatepicker = KTDatepicker;


/***/ }),

/***/ 8016:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


/**
 * KTUI - Free & Open-Source Tailwind UI Components by Keenthemes
 * Copyright 2025 by Keenthemes Inc
 */
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.KTSelect = void 0;
var data_1 = __webpack_require__(8716);
var component_1 = __webpack_require__(2658);
var config_1 = __webpack_require__(9386);
var option_1 = __webpack_require__(4241);
var remote_1 = __webpack_require__(3710);
var search_1 = __webpack_require__(7620);
var templates_1 = __webpack_require__(9069);
var combobox_1 = __webpack_require__(5539);
var dropdown_1 = __webpack_require__(7125);
var utils_1 = __webpack_require__(9011);
var tags_1 = __webpack_require__(8797);
var KTSelect = /** @class */ (function (_super) {
    __extends(KTSelect, _super);
    /**
     * Constructor: Initializes the select component
     */
    function KTSelect(element, config) {
        var _this = _super.call(this) || this;
        // Core properties
        _this._name = 'select';
        _this._dataOptionPrefix = 'kt-'; // Use 'kt-' prefix to support data-kt-select-option attributes
        // State
        _this._dropdownIsOpen = false;
        _this._comboboxModule = null;
        _this._tagsModule = null;
        _this._dropdownModule = null;
        _this._loadMoreIndicator = null;
        _this._typeToSearchBuffer = new utils_1.TypeToSearchBuffer();
        _this._mutationObserver = null;
        // Search debounce timeout
        _this._searchDebounceTimeout = null;
        // Store original options HTML for restoring after search
        _this._originalOptionsHtml = null;
        if (data_1.default.has(element, _this._name)) {
            return _this;
        }
        _this._init(element);
        _this._buildConfig(config);
        _this._state = new config_1.KTSelectState(_this._config);
        _this._config = _this._state.getConfig();
        element.instance = _this;
        // Initialize event manager
        _this._eventManager = new utils_1.EventManager();
        // Initialize remote module if remote data is enabled
        if (_this._config.remote) {
            _this._remoteModule = new remote_1.KTSelectRemote(_this._config, _this._element);
            _this._initializeRemoteData();
        }
        else {
            _this._state
                .setItems()
                .then(function () {
                if (_this._config.debug)
                    console.log('Setting up component after remote data is loaded');
                _this._setupComponent();
            })
                .catch(function (error) {
                console.error('Error setting items:', error);
                // Handle the error, e.g., display an error message to the user
            });
        }
        return _this;
    }
    /**
     * Initialize remote data fetching
     */
    KTSelect.prototype._initializeRemoteData = function () {
        var _this = this;
        if (!this._remoteModule || !this._config.remote)
            return;
        if (this._config.debug)
            console.log('Initializing remote data with URL:', this._config.dataUrl);
        // Show loading state
        this._renderLoadingState();
        // Fetch remote data
        this._remoteModule
            .fetchData()
            .then(function (items) {
            if (_this._config.debug)
                console.log('Remote data fetched:', items);
            // Remove placeholder/loading options before setting new items
            _this._clearExistingOptions();
            // Update state with fetched items
            _this._state
                .setItems(items)
                .then(function () {
                // Generate options from the fetched data
                _this._generateOptionsHtml(_this._element);
                if (_this._config.debug)
                    console.log('Generating options HTML from remote data');
                _this._setupComponent();
                // Add pagination "Load More" button if needed
                if (_this._config.pagination && _this._remoteModule.hasMorePages()) {
                    _this._addLoadMoreButton();
                }
            })
                .catch(function (error) {
                console.error('Error setting items:', error);
                _this._renderErrorState(error.message || 'Failed to load data');
            });
        })
            .catch(function (error) {
            console.error('Error fetching remote data:', error);
            _this._renderErrorState(_this._remoteModule.getErrorMessage() || 'Failed to load data');
        });
    };
    /**
     * Clear existing options from the select element
     */
    KTSelect.prototype._clearExistingOptions = function () {
        // Keep only the empty/placeholder option and remove the rest
        var options = Array.from(this._element.querySelectorAll('option:not([value=""])'));
        options.forEach(function (option) { return option.remove(); });
    };
    /**
     * Helper to show a dropdown message (error, loading, noResults)
     */
    KTSelect.prototype._showDropdownMessage = function (type, message) {
        if (!this._dropdownContentElement)
            return;
        var optionsContainer = this._dropdownContentElement.querySelector('[data-kt-select-options]');
        if (!optionsContainer)
            return;
        // Clear previous messages
        optionsContainer.innerHTML = '';
        switch (type) {
            case 'error':
                optionsContainer.appendChild(templates_1.defaultTemplates.error(__assign(__assign({}, this._config), { errorMessage: message })));
                break;
            case 'loading':
                optionsContainer.appendChild(templates_1.defaultTemplates.loading(this._config, message || 'Loading...'));
                break;
            case 'empty':
                optionsContainer.appendChild(templates_1.defaultTemplates.searchEmpty(this._config));
                break;
        }
    };
    /**
     * Render loading state in dropdown
     */
    KTSelect.prototype._renderLoadingState = function () {
        if (this._element.querySelectorAll('option').length <= 1) {
            var existingLoadingOptions = this._element.querySelectorAll('option[disabled][selected][value=""]');
            existingLoadingOptions.forEach(function (option) { return option.remove(); });
            this._showDropdownMessage('loading', 'Loading options...');
        }
    };
    /**
     * Render error state
     * @param message Error message
     */
    KTSelect.prototype._renderErrorState = function (message) {
        // If dropdown is already created, show error message there
        this._showDropdownMessage('error', message);
        if (!this._wrapperElement) {
            if (this._config.debug)
                console.log('Setting up component after error');
            this._setupComponent();
        }
    };
    /**
     * Add "Load More" button for pagination
     */
    KTSelect.prototype._addLoadMoreButton = function () {
        if (!this._dropdownContentElement || !this._config.pagination)
            return;
        // Remove existing button if any
        if (this._loadMoreIndicator) {
            this._loadMoreIndicator.remove();
            this._loadMoreIndicator = null;
        }
        // Create load more button using template
        this._loadMoreIndicator = templates_1.defaultTemplates.loadMore(this._config);
        // Add to dropdown
        var optionsContainer = this._dropdownContentElement.querySelector('[data-kt-select-options]');
        if (optionsContainer) {
            optionsContainer.appendChild(this._loadMoreIndicator);
        }
        else {
            this._dropdownContentElement.appendChild(this._loadMoreIndicator);
        }
        // Add event listener
        this._loadMoreIndicator.addEventListener('click', this._handleLoadMore.bind(this));
    };
    /**
     * Handle load more button click
     */
    KTSelect.prototype._handleLoadMore = function () {
        var _this = this;
        if (!this._remoteModule || !this._config.pagination)
            return;
        // Show loading state
        if (this._loadMoreIndicator) {
            this._loadMoreIndicator.textContent = 'Loading...';
        }
        // Fetch next page
        this._remoteModule
            .loadNextPage()
            .then(function (newItems) {
            // Get existing items
            var existingItems = _this._state.getItems();
            // Combine new items with existing items
            _this._state
                .setItems(__spreadArray(__spreadArray([], existingItems, true), newItems, true))
                .then(function () {
                // Update options in the dropdown
                _this._updateOptionsInDropdown(newItems);
                // Check if there are more pages
                if (_this._remoteModule.hasMorePages()) {
                    // Reset load more button
                    if (_this._loadMoreIndicator) {
                        _this._loadMoreIndicator.textContent =
                            _this._config.loadMoreText || 'Load more...';
                    }
                }
                else {
                    // Remove load more button if no more pages
                    if (_this._loadMoreIndicator) {
                        _this._loadMoreIndicator.remove();
                        _this._loadMoreIndicator = null;
                    }
                }
            })
                .catch(function (error) {
                console.error('Error updating items:', error);
                // Reset load more button
                if (_this._loadMoreIndicator) {
                    _this._loadMoreIndicator.textContent = 'Error loading more items';
                }
            });
        })
            .catch(function (error) {
            console.error('Error loading more items:', error);
            // Reset load more button
            if (_this._loadMoreIndicator) {
                _this._loadMoreIndicator.textContent = 'Error loading more items';
            }
        });
    };
    /**
     * Update options in the dropdown
     * @param newItems New items to add to the dropdown
     */
    KTSelect.prototype._updateOptionsInDropdown = function (newItems) {
        if (!this._dropdownContentElement || !newItems.length)
            return;
        var optionsContainer = this._dropdownContentElement.querySelector("[data-kt-select-options]");
        if (!optionsContainer)
            return;
        // Get the load more button
        var loadMoreButton = optionsContainer.querySelector("[data-kt-select-load-more]");
        // Process each new item
        newItems.forEach(function (item) {
            // Create option for the original select
            var selectOption = document.createElement('option');
            selectOption.value = item.id || '';
            // Add to dropdown container
            if (loadMoreButton) {
                // Insert before the load more button
                optionsContainer.insertBefore(selectOption, loadMoreButton);
            }
            else {
                // Append to the end
                optionsContainer.appendChild(selectOption);
            }
        });
        // Update options NodeList to include the new options
        this._options = this._wrapperElement.querySelectorAll("[data-kt-select-option]");
        if (this._config.debug)
            console.log("Added ".concat(newItems.length, " more options to dropdown"));
    };
    /**
     * ========================================================================
     * INITIALIZATION METHODS
     * ========================================================================
     */
    /**
     * Set up the component after everything is initialized
     */
    KTSelect.prototype._setupComponent = function () {
        // Setup HTML structure
        this._createHtmlStructure();
        this._setupElementReferences();
        // Initialize options
        this._preSelectOptions(this._element);
        // Apply disabled state if needed
        this._applyInitialDisabledState();
        // Initialize search if enabled
        if (this._config.enableSearch) {
            this._initializeSearchModule();
        }
        // Initialize combobox if enabled
        if (this._config.combobox) {
            this._comboboxModule = new combobox_1.KTSelectCombobox(this);
        }
        // Initialize tags if enabled
        if (this._config.tags) {
            this._tagsModule = new tags_1.KTSelectTags(this);
        }
        // Initialize focus manager after dropdown element is created
        this._focusManager = new utils_1.FocusManager(this._dropdownContentElement, '[data-kt-select-option]', this._config);
        // Initialize dropdown module after all elements are created
        this._dropdownModule = new dropdown_1.KTSelectDropdown(this._wrapperElement, this._displayElement, this._dropdownContentElement, this._config, this);
        // Update display and set ARIA attributes
        this._updateDisplayAndAriaAttributes();
        this.updateSelectedOptionDisplay();
        this._setAriaAttributes();
        // Attach event listeners after all modules are initialized
        this._attachEventListeners();
        this._observeNativeSelect();
    };
    /**
     * Creates the HTML structure for the select component
     */
    KTSelect.prototype._createHtmlStructure = function () {
        var _a, _b;
        var _this = this;
        var options = Array.from(this._element.querySelectorAll('option'));
        // Create wrapper and display elements
        var wrapperElement = templates_1.defaultTemplates.wrapper(this._config);
        var displayElement = templates_1.defaultTemplates.display(this._config);
        // Add the display element to the wrapper
        wrapperElement.appendChild(displayElement);
        // Move classes from original select to wrapper and display elements
        if (this._element.classList.length > 0) {
            var originalClasses = Array.from(this._element.classList);
            var displaySpecificClasses_1 = ['kt-select', 'kt-select-sm', 'kt-select-lg'];
            var classesForWrapper = originalClasses.filter(function (className) { return !displaySpecificClasses_1.includes(className); });
            if (classesForWrapper.length > 0) {
                (_a = wrapperElement.classList).add.apply(_a, classesForWrapper);
            }
            // Move display-specific classes to display element
            var classesForDisplay = originalClasses.filter(function (className) { return displaySpecificClasses_1.includes(className); });
            if (classesForDisplay.length > 0) {
                (_b = displayElement.classList).add.apply(_b, classesForDisplay);
            }
            this._element.className = ''; // Clear classes from original select element
        }
        // Create an empty dropdown first (without options) using template
        var dropdownElement = templates_1.defaultTemplates.dropdown(__assign(__assign({}, this._config), { zindex: this._config.dropdownZindex }));
        // Add search input if needed
        if (this._config.enableSearch) {
            var searchElement = templates_1.defaultTemplates.search(this._config);
            dropdownElement.appendChild(searchElement);
        }
        // Create options container using template
        var optionsContainer = templates_1.defaultTemplates.options(this._config);
        // Add each option directly to the container
        options.forEach(function (optionElement) {
            // Skip empty placeholder options (only if BOTH value AND text are empty)
            // This allows options with empty value but visible text to display in dropdown
            if (optionElement.value === '' &&
                optionElement.textContent.trim() === '') {
                return;
            }
            // Create new KTSelectOption instance for each option
            var selectOption = new option_1.KTSelectOption(optionElement, _this._config);
            var renderedOption = selectOption.render();
            // Append directly to options container
            optionsContainer.appendChild(renderedOption);
        });
        // Add options container to dropdown
        dropdownElement.appendChild(optionsContainer);
        // Add dropdown to wrapper
        wrapperElement.appendChild(dropdownElement);
        // Insert after the original element
        this._element.after(wrapperElement);
        this._element.classList.add('hidden');
    };
    /**
     * Setup all element references after DOM is created
     */
    KTSelect.prototype._setupElementReferences = function () {
        this._wrapperElement = this._element.nextElementSibling;
        // Get display element
        this._displayElement = this._wrapperElement.querySelector("[data-kt-select-display]");
        // Get dropdown content element - this is critical for dropdown functionality
        this._dropdownContentElement = this._wrapperElement.querySelector("[data-kt-select-dropdown]");
        if (!this._dropdownContentElement) {
            console.log(this._element);
            console.error('Dropdown content element not found', this._wrapperElement);
        }
        // Get search input element - this is used for the search functionality
        this._searchInputElement = this._dropdownContentElement.querySelector("[data-kt-select-search]");
        // If not found in dropdown, check if it's the display element itself
        if (!this._searchInputElement) {
            this._searchInputElement = this._displayElement;
        }
        this._options = this._wrapperElement.querySelectorAll("[data-kt-select-option]");
    };
    /**
     * Attach all event listeners to elements
     */
    KTSelect.prototype._attachEventListeners = function () {
        // Document level event listeners
        document.addEventListener('click', this._handleDocumentClick.bind(this));
        // Dropdown option click events
        this._eventManager.addListener(this._dropdownContentElement, 'click', this._handleDropdownOptionClick.bind(this));
        // Attach centralized keyboard handler to the wrapper element.
        // Events from focusable children like _displayElement or _searchInputElement (if present) will bubble up.
        if (this._wrapperElement) {
            this._wrapperElement.addEventListener('keydown', this._handleKeyboardEvent.bind(this));
        }
    };
    /**
     * Initialize search module if search is enabled
     */
    KTSelect.prototype._initializeSearchModule = function () {
        if (this._config.enableSearch) {
            this._searchModule = new search_1.KTSelectSearch(this);
            this._searchModule.init();
            // If remote search is enabled, add event listener for search input
            if (this._config.remote &&
                this._config.searchParam &&
                this._searchInputElement) {
                this._searchInputElement.addEventListener('input', this._handleRemoteSearch.bind(this));
            }
        }
    };
    /**
     * Apply ARIA attributes and update display
     */
    KTSelect.prototype._updateDisplayAndAriaAttributes = function () {
        this.updateSelectedOptionDisplay();
        this._setAriaAttributes();
    };
    /**
     * Apply initial disabled state if configured
     */
    KTSelect.prototype._applyInitialDisabledState = function () {
        if (this._config.disabled) {
            this.getElement().classList.add('disabled');
            this.getElement().setAttribute('disabled', 'disabled');
            this._wrapperElement.classList.add('disabled');
        }
    };
    /**
     * Generate options HTML from data items
     */
    KTSelect.prototype._generateOptionsHtml = function (element) {
        var _this = this;
        var items = this._state.getItems() || [];
        if (this._config.debug)
            console.log("Generating options HTML from ".concat(items.length, " items"));
        // Only modify options if we have items to replace them with
        if (items && items.length > 0) {
            // Clear existing options except the first empty one
            var options = element.querySelectorAll('option:not(:first-child)');
            options.forEach(function (option) { return option.remove(); });
            // Generate options from data
            items.forEach(function (item) {
                var optionElement = document.createElement('option');
                // Get value - use item.id directly if available, otherwise try dataValueField
                var value = '';
                if (item.id !== undefined) {
                    value = String(item.id);
                }
                else if (_this._config.dataValueField) {
                    var extractedValue = _this._getValueByKey(item, _this._config.dataValueField);
                    value = extractedValue !== null ? String(extractedValue) : '';
                }
                // Get label - use item.title directly if available, otherwise try dataFieldText
                var label = '';
                if (item.title !== undefined) {
                    label = String(item.title);
                }
                else if (_this._config.dataFieldText) {
                    var extractedLabel = _this._getValueByKey(item, _this._config.dataFieldText);
                    label =
                        extractedLabel !== null ? String(extractedLabel) : 'Unnamed option';
                }
                // Log the extracted values for debugging
                if (_this._config.debug)
                    console.log("Option: value=".concat(value, ", label=").concat(label));
                // Set option attributes
                optionElement.value = value;
                optionElement.textContent = label || 'Unnamed option';
                if (item.selected) {
                    optionElement.setAttribute('selected', 'selected');
                }
                element.appendChild(optionElement);
            });
            if (this._config.debug)
                console.log("Added ".concat(items.length, " options to select element"));
        }
        else {
            if (this._config.debug)
                console.log('No items to generate options from');
        }
    };
    /**
     * Extract nested property value from object using dot notation
     */
    KTSelect.prototype._getValueByKey = function (obj, key) {
        if (!key || !obj)
            return null;
        // Use reduce to walk through the object by splitting the key on dots
        var result = key
            .split('.')
            .reduce(function (o, k) { return (o && o[k] !== undefined ? o[k] : null); }, obj);
        if (this._config.debug)
            console.log("Extracting [".concat(key, "] from object => ").concat(result !== null ? JSON.stringify(result) : 'null'));
        return result;
    };
    /**
     * Pre-select options that have the selected attribute
     */
    KTSelect.prototype._preSelectOptions = function (element) {
        var _this = this;
        // Handle options with selected attribute
        Array.from(element.querySelectorAll('option[selected]')).forEach(function (option) {
            var value = option.value;
            _this._selectOption(value);
        });
        // Handle data-kt-select-pre-selected attribute for React compatibility
        var preSelectedValues = element.getAttribute('data-kt-select-pre-selected');
        if (preSelectedValues) {
            var values = preSelectedValues.split(',').map(function (v) { return v.trim(); });
            values.forEach(function (value) {
                if (value) {
                    _this._selectOption(value);
                }
            });
        }
    };
    /**
     * ========================================================================
     * DROPDOWN MANAGEMENT
     * ========================================================================
     */
    /**
     * Open the dropdown
     */
    KTSelect.prototype.openDropdown = function () {
        if (this._config.disabled) {
            if (this._config.debug)
                console.log('openDropdown: select is disabled, not opening');
            return;
        }
        if (this._config.debug)
            console.log('openDropdown called, dropdownModule exists:', !!this._dropdownModule);
        if (!this._dropdownModule) {
            if (this._config.debug)
                console.log('Early return from openDropdown - module missing');
            return;
        }
        // Don't open dropdown if the select is disabled
        if (this._config.disabled) {
            if (this._config.debug)
                console.log('Early return from openDropdown - select is disabled');
            return;
        }
        if (this._config.debug)
            console.log('Opening dropdown via dropdownModule...');
        // Set our internal flag to match what we're doing
        this._dropdownIsOpen = true;
        // Open the dropdown via the module
        this._dropdownModule.open();
        // Dispatch custom event
        this._dispatchEvent('show');
        this._fireEvent('show');
        // Update ARIA states
        this._setAriaAttributes();
        // Focus the first selected option or first option if nothing selected
        this._focusSelectedOption();
    };
    /**
     * Close the dropdown
     */
    KTSelect.prototype.closeDropdown = function () {
        if (this._config.debug)
            console.log('closeDropdown called, dropdownModule exists:', !!this._dropdownModule);
        // Only check if dropdown module exists, not dropdownIsOpen flag
        if (!this._dropdownModule) {
            if (this._config.debug)
                console.log('Early return from closeDropdown - module missing');
            return;
        }
        // Always close by delegating to the dropdown module, which is the source of truth
        if (this._config.debug)
            console.log('Closing dropdown via dropdownModule...');
        // Clear search input if the dropdown is closing
        if (this._searchModule && this._searchInputElement) {
            // Clear search input if configured to do so
            if (this._config.clearSearchOnClose) {
                this._searchInputElement.value = '';
            }
            // Clear search input when dropdown closes
            this._searchModule.clearSearch();
        }
        // Set our internal flag to match what we're doing
        this._dropdownIsOpen = false;
        // Call the dropdown module's close method
        this._dropdownModule.close();
        // Reset all focus states
        if (this._focusManager) {
            this._focusManager.resetFocus();
        }
        // Dispatch custom events
        this._dispatchEvent('close');
        this._fireEvent('close');
        // Update ARIA states
        this._setAriaAttributes();
        if (this._config.debug)
            console.log('closeDropdown complete');
    };
    /**
     * Update dropdown position
     */
    KTSelect.prototype.updateDropdownPosition = function () {
        if (this._dropdownModule) {
            this._dropdownModule.updatePosition();
        }
    };
    /**
     * Focus on the first selected option if any exists in the dropdown
     */
    KTSelect.prototype._focusSelectedOption = function () {
        // Get selected options
        var selectedOptions = this.getSelectedOptions();
        if (selectedOptions.length === 0)
            return;
        // Iterate through selected options and focus the first one that is visible
        for (var _i = 0, selectedOptions_1 = selectedOptions; _i < selectedOptions_1.length; _i++) {
            var value = selectedOptions_1[_i];
            if (this._focusManager && this._focusManager.focusOptionByValue(value)) {
                break; // Stop after focusing the first found selected and visible option
            }
        }
    };
    /**
     * ========================================================================
     * SELECTION MANAGEMENT
     * ========================================================================
     */
    /**
     * Select an option by value
     */
    KTSelect.prototype._selectOption = function (value) {
        // Prevent selection if the option is disabled (in dropdown or original select)
        if (this._isOptionDisabled(value)) {
            if (this._config.debug)
                console.log('_selectOption: Option is disabled, ignoring selection');
            return;
        }
        // Get current selection state
        var isSelected = this._state.isSelected(value);
        // Toggle selection in state
        if (this._config.multiple) {
            // Toggle in multiple mode
            this._state.toggleSelectedOptions(value);
        }
        else {
            // Set as only selection in single mode
            this._state.setSelectedOptions(value);
        }
        // Update the original select element's option selected state
        var optionEl = Array.from(this._element.querySelectorAll('option')).find(function (opt) { return opt.value === value; });
        if (optionEl) {
            if (this._config.multiple) {
                // Toggle the selection for multiple select
                optionEl.selected = !isSelected;
            }
            else {
                // Set as only selection for single select
                Array.from(this._element.querySelectorAll('option')).forEach(function (opt) {
                    opt.selected = opt.value === value;
                });
            }
        }
        // Update the visual display of selected options
        this.updateSelectedOptionDisplay();
        // Update option classes without re-rendering the dropdown content
        this._updateSelectedOptionClass();
        // Dispatch standard and custom change events
        this._dispatchEvent('change', {
            value: value,
            selected: !isSelected,
            selectedOptions: this.getSelectedOptions(),
        });
        this._fireEvent('change', {
            value: value,
            selected: !isSelected,
            selectedOptions: this.getSelectedOptions(),
        });
    };
    /**
     * Update selected option display value
     */
    KTSelect.prototype.updateSelectedOptionDisplay = function () {
        var selectedOptions = this.getSelectedOptions();
        var tagsEnabled = this._config.tags && this._tagsModule;
        var valueDisplayEl = this.getValueDisplayElement();
        if (tagsEnabled) {
            // Tags module will render tags if selectedOptions > 0, or clear them if selectedOptions === 0.
            this._tagsModule.updateTagsDisplay(selectedOptions);
        }
        // Guard against valueDisplayEl being null due to template modifications
        if (!valueDisplayEl) {
            if (this._config.debug) {
                console.warn('KTSelect: Value display element is null. Cannot update display or placeholder. Check template for [data-kt-select-value].');
            }
            return; // Nothing to display on if the element is missing
        }
        if (typeof this._config.renderSelected === 'function') {
            valueDisplayEl.innerHTML = this._config.renderSelected(selectedOptions);
        }
        else {
            if (selectedOptions.length === 0) {
                // No options selected: display placeholder.
                // This runs if tags are off, OR if tags are on but no items are selected (tags module would have cleared tags).
                var placeholderEl = templates_1.defaultTemplates.placeholder(this._config);
                valueDisplayEl.replaceChildren(placeholderEl);
            }
            else {
                // Options are selected.
                if (tagsEnabled) {
                    // Tags are enabled AND options are selected: tags module has rendered them.
                    // Clear valueDisplayEl as tags are the primary display.
                    valueDisplayEl.innerHTML = '';
                }
                else {
                    // Tags are not enabled AND options are selected: render normal text display.
                    var content = '';
                    if (this._config.displayTemplate) {
                        content = this.renderDisplayTemplateForSelected(this.getSelectedOptions());
                    }
                    else {
                        content = this.getSelectedOptionsText();
                    }
                    valueDisplayEl.innerHTML = content;
                }
            }
        }
    };
    /**
     * Check if an option was originally disabled in the HTML
     */
    KTSelect.prototype._isOptionOriginallyDisabled = function (value) {
        var originalOption = Array.from(this._element.querySelectorAll('option')).find(function (opt) { return opt.value === value; });
        return originalOption ? originalOption.disabled : false;
    };
    /**
     * Update CSS classes for selected options
     */
    KTSelect.prototype._updateSelectedOptionClass = function () {
        var _this = this;
        var allOptions = this._wrapperElement.querySelectorAll("[data-kt-select-option]");
        var selectedValues = this._state.getSelectedOptions();
        var maxReached = typeof this._config.maxSelections === 'number' &&
            selectedValues.length >= this._config.maxSelections;
        if (this._config.debug)
            console.log('Updating selected classes for options, selected values:', selectedValues);
        allOptions.forEach(function (option) {
            var optionValue = option.getAttribute('data-value');
            if (!optionValue)
                return;
            var isSelected = selectedValues.includes(optionValue);
            var isOriginallyDisabled = _this._isOptionOriginallyDisabled(optionValue);
            if (isSelected) {
                option.classList.add('selected');
                option.setAttribute('aria-selected', 'true');
                // Selected options should not be visually hidden or disabled by maxSelections logic
                option.classList.remove('hidden');
                option.classList.remove('disabled');
                option.removeAttribute('aria-disabled');
            }
            else {
                option.classList.remove('selected');
                option.setAttribute('aria-selected', 'false');
                // An option should be disabled if it was originally disabled OR if maxSelections is reached
                if (isOriginallyDisabled || maxReached) {
                    option.classList.add('disabled');
                    option.setAttribute('aria-disabled', 'true');
                }
                else {
                    option.classList.remove('disabled');
                    option.removeAttribute('aria-disabled');
                }
            }
        });
    };
    /**
     * Clear all selected options
     */
    KTSelect.prototype.clearSelection = function () {
        // Clear the current selection
        this._state.setSelectedOptions([]);
        this.updateSelectedOptionDisplay();
        this._updateSelectedOptionClass();
        // Dispatch change event
        this._dispatchEvent('change');
        this._fireEvent('change');
    };
    /**
     * Set selected options programmatically
     */
    KTSelect.prototype.setSelectedOptions = function (options) {
        var values = Array.from(options).map(function (option) { return option.value; });
        this._state.setSelectedOptions(values);
    };
    /**
     * Select the currently focused option
     */
    KTSelect.prototype.selectFocusedOption = function () {
        var _a, _b;
        var focusedOption = this._focusManager.getFocusedOption();
        if (focusedOption) {
            var selectedValue = focusedOption.dataset.value;
            // Extract just the title text, not including description
            var selectedText = '';
            var titleElement = focusedOption.querySelector('[data-kt-option-title]');
            if (titleElement) {
                // If it has a structured content with title element
                selectedText = ((_a = titleElement.textContent) === null || _a === void 0 ? void 0 : _a.trim()) || '';
            }
            else {
                // Fallback to the whole text content
                selectedText = ((_b = focusedOption.textContent) === null || _b === void 0 ? void 0 : _b.trim()) || '';
            }
            // First trigger the selection to ensure state is updated properly
            if (selectedValue) {
                this._selectOption(selectedValue);
            }
        }
    };
    /**
     * ========================================================================
     * EVENT HANDLERS
     * ========================================================================
     */
    /**
     * Handle click within the dropdown
     */
    KTSelect.prototype._handleDropdownOptionClick = function (event) {
        var optionElement = event.target.closest("[data-kt-select-option]");
        // If an option is clicked, handle the option click
        if (optionElement) {
            this._handleOptionClick(event);
        }
    };
    /**
     * Handle clicking on an option in the dropdown
     */
    KTSelect.prototype._handleOptionClick = function (event) {
        if (this._config.debug)
            console.log('_handleOptionClick called', event.target);
        event.preventDefault();
        event.stopPropagation();
        // Find the clicked option element
        var clickedOption = event.target.closest("[data-kt-select-option]");
        if (!clickedOption) {
            if (this._config.debug)
                console.log('No clicked option found');
            return;
        }
        // Check if the option is disabled
        if (clickedOption.getAttribute('aria-disabled') === 'true') {
            if (this._config.debug)
                console.log('Option is disabled, ignoring click');
            return;
        }
        // Use dataset.value to get the option value
        var optionValue = clickedOption.dataset.value;
        if (optionValue === undefined) {
            if (this._config.debug)
                console.log('Option value is undefined');
            return;
        }
        if (this._config.debug)
            console.log('Option clicked:', optionValue);
        // If in single-select mode and the clicked option is already selected, just close the dropdown.
        if (!this._config.multiple && this._state.isSelected(optionValue)) {
            if (this._config.debug)
                console.log('Single select mode: clicked already selected option. Closing dropdown.');
            this.closeDropdown();
            return;
        }
        // Use toggleSelection instead of _selectOption to prevent re-rendering
        this.toggleSelection(optionValue);
    };
    /**
     * Handle document click for closing dropdown
     */
    KTSelect.prototype._handleDocumentClick = function (event) {
        var targetElement = event.target;
        // Check if the click is outside the dropdown and the display element
        if (!this._wrapperElement.contains(targetElement)) {
            this.closeDropdown();
        }
    };
    /**
     * ========================================================================
     * ACCESSIBILITY METHODS
     * ========================================================================
     */
    /**
     * Set ARIA attributes for accessibility
     */
    KTSelect.prototype._setAriaAttributes = function () {
        this._displayElement.setAttribute('aria-expanded', this._dropdownIsOpen.toString());
    };
    /**
     * ========================================================================
     * PUBLIC API
     * ========================================================================
     */
    /**
     * Get the search input element
     */
    KTSelect.prototype.getSearchInput = function () {
        return this._searchInputElement;
    };
    /**
     * Get selected options
     */
    KTSelect.prototype.getSelectedOptions = function () {
        return this._state.getSelectedOptions();
    };
    /**
     * Get configuration
     */
    KTSelect.prototype.getConfig = function () {
        return this._config;
    };
    /**
     * Get option elements
     */
    KTSelect.prototype.getOptionsElement = function () {
        return this._options;
    };
    /**
     * Get dropdown element
     */
    KTSelect.prototype.getDropdownElement = function () {
        return this._dropdownContentElement;
    };
    /**
     * Get value display element
     */
    KTSelect.prototype.getValueDisplayElement = function () {
        return this._displayElement;
    };
    /**
     * Get wrapper element
     */
    KTSelect.prototype.getWrapperElement = function () {
        return this._wrapperElement;
    };
    /**
     * Show all options in the dropdown
     */
    KTSelect.prototype.showAllOptions = function () {
        // Get all options in the dropdown
        var options = Array.from(this._wrapperElement.querySelectorAll("[data-kt-select-option]"));
        // Show all options by removing the hidden class and any inline styles
        options.forEach(function (option) {
            var _a;
            // Remove hidden class
            option.classList.remove('hidden');
            // Clean up any existing inline styles for backward compatibility
            if (option.hasAttribute('style')) {
                var styleAttr = option.getAttribute('style');
                if (styleAttr.includes('display:')) {
                    // If style only contains display property, remove the entire attribute
                    if (styleAttr.trim() === 'display: none;' ||
                        styleAttr.trim() === 'display: block;') {
                        option.removeAttribute('style');
                    }
                    else {
                        // Otherwise, remove just the display property
                        option.setAttribute('style', (_a = styleAttr === null || styleAttr === void 0 ? void 0 : styleAttr.replace(/display:\s*[^;]+;?/gi, '')) === null || _a === void 0 ? void 0 : _a.trim());
                    }
                }
            }
        });
        // If search input exists, clear it
        if (this._searchInputElement) {
            this._searchInputElement.value = '';
            // If we have a search module, clear any search filtering
            if (this._searchModule) {
                this._searchModule.clearSearch();
            }
        }
    };
    /**
     * Toggle multi-select functionality
     */
    KTSelect.prototype.enableMultiSelect = function () {
        this._state.modifyConfig({ multiple: true });
    };
    /**
     * Disable multi-select functionality
     */
    KTSelect.prototype.disableMultiSelect = function () {
        this._state.modifyConfig({ multiple: false });
    };
    /**
     * Toggle the selection of an option
     */
    KTSelect.prototype.toggleSelection = function (value) {
        // Prevent selection if the option is disabled (in dropdown or original select)
        if (this._isOptionDisabled(value)) {
            if (this._config.debug)
                console.log('toggleSelection: Option is disabled, ignoring selection');
            return;
        }
        // Get current selection state
        var isSelected = this._state.isSelected(value);
        if (this._config.debug)
            console.log("toggleSelection called for value: ".concat(value, ", isSelected: ").concat(isSelected, ", multiple: ").concat(this._config.multiple));
        // If already selected in single select mode, do nothing (can't deselect in single select)
        if (isSelected && !this._config.multiple) {
            if (this._config.debug)
                console.log('Early return from toggleSelection - already selected in single select mode');
            return;
        }
        if (this._config.debug)
            console.log("Toggling selection for option: ".concat(value, ", currently selected: ").concat(isSelected));
        // Ensure any search input is cleared when selection changes
        if (this._searchModule) {
            this._searchModule.clearSearch();
        }
        // Toggle the selection in the state
        this._state.toggleSelectedOptions(value);
        // Update the original select element's option selected state
        var optionEl = Array.from(this._element.querySelectorAll('option')).find(function (opt) { return opt.value === value; });
        if (optionEl) {
            // For multiple select, toggle the 'selected' attribute
            if (this._config.multiple) {
                optionEl.selected = !isSelected;
            }
            else {
                // For single select, deselect all other options and select this one
                Array.from(this._element.querySelectorAll('option')).forEach(function (opt) {
                    opt.selected = opt.value === value;
                });
            }
        }
        // Update the display element value
        this.updateSelectedOptionDisplay();
        // Update option classes without re-rendering the dropdown content
        this._updateSelectedOptionClass();
        // For single select mode, always close the dropdown after selection
        // For multiple select mode, keep the dropdown open to allow multiple selections
        if (!this._config.multiple) {
            if (this._config.debug)
                console.log('About to call closeDropdown() for single select mode - always close after selection');
            this.closeDropdown();
        }
        else {
            if (this._config.debug)
                console.log('Multiple select mode - keeping dropdown open for additional selections');
            // Don't close dropdown in multiple select mode to allow multiple selections
        }
        // Dispatch custom change event with additional data
        this._dispatchEvent('change', {
            value: value,
            selected: !isSelected,
            selectedOptions: this.getSelectedOptions(),
        });
        this._fireEvent('change', {
            value: value,
            selected: !isSelected,
            selectedOptions: this.getSelectedOptions(),
        });
    };
    /**
     * Clean up all resources when the component is destroyed
     * This overrides the parent dispose method
     */
    KTSelect.prototype.dispose = function () {
        // Clean up event listeners
        this._eventManager.removeAllListeners(null);
        // Dispose modules
        if (this._dropdownModule) {
            this._dropdownModule.dispose();
        }
        if (this._comboboxModule) {
            if (typeof this._comboboxModule.destroy === 'function') {
                this._comboboxModule.destroy();
            }
        }
        if (this._tagsModule) {
            if (typeof this._tagsModule.destroy === 'function') {
                this._tagsModule.destroy();
            }
        }
        if (this._searchModule) {
            if (typeof this._searchModule.destroy === 'function') {
                this._searchModule.destroy();
            }
        }
        // Remove DOM elements
        if (this._wrapperElement && this._wrapperElement.parentNode) {
            this._wrapperElement.parentNode.removeChild(this._wrapperElement);
        }
        // Call parent dispose to clean up data
        _super.prototype.dispose.call(this);
    };
    /**
     * Create instances of KTSelect for all matching elements
     */
    KTSelect.createInstances = function () {
        var _this = this;
        var elements = document.querySelectorAll('[data-kt-select]');
        elements.forEach(function (element) {
            if (element.hasAttribute('data-kt-select') &&
                !element.classList.contains('data-kt-select-initialized')) {
                var instance = new KTSelect(element);
                _this._instances.set(element, instance);
            }
        });
    };
    /**
     * Initialize all KTSelect instances
     */
    KTSelect.init = function () {
        KTSelect.createInstances();
    };
    /**
     * Handle remote search
     * @param event Input event
     */
    KTSelect.prototype._handleRemoteSearch = function (event) {
        var _this = this;
        if (!this._remoteModule ||
            !this._config.remote ||
            !this._config.searchParam)
            return;
        var query = event.target.value;
        // Check if the query is long enough
        if (query.length < (this._config.searchMinLength || 0)) {
            return;
        }
        // Debounce the search
        if (this._searchDebounceTimeout) {
            clearTimeout(this._searchDebounceTimeout);
        }
        this._searchDebounceTimeout = window.setTimeout(function () {
            // Show loading state
            _this._renderSearchLoadingState();
            // Fetch remote data with search query
            _this._remoteModule
                .fetchData(query)
                .then(function (items) {
                // Update state with fetched items
                _this._state
                    .setItems(items)
                    .then(function () {
                    // Update options in the dropdown
                    _this._updateSearchResults(items);
                    // Refresh the search module to update focus and cache
                    if (_this._searchModule) {
                        _this._searchModule.refreshAfterSearch();
                    }
                })
                    .catch(function (error) {
                    console.error('Error updating search results:', error);
                    _this._renderSearchErrorState(error.message || 'Failed to load search results');
                });
            })
                .catch(function (error) {
                console.error('Error fetching search results:', error);
                _this._renderSearchErrorState(_this._remoteModule.getErrorMessage() ||
                    'Failed to load search results');
            });
        }, this._config.searchDebounce || 300);
    };
    /**
     * Render loading state for search
     */
    KTSelect.prototype._renderSearchLoadingState = function () {
        if (!this._originalOptionsHtml && this._dropdownContentElement) {
            var optionsContainer = this._dropdownContentElement.querySelector('[data-kt-select-options]');
            if (optionsContainer) {
                this._originalOptionsHtml = optionsContainer.innerHTML;
            }
        }
        this._showDropdownMessage('loading', 'Searching...');
    };
    /**
     * Render error state for search
     * @param message Error message
     */
    KTSelect.prototype._renderSearchErrorState = function (message) {
        this._showDropdownMessage('error', message);
    };
    /**
     * Update search results in the dropdown
     * @param items Search result items
     */
    KTSelect.prototype._updateSearchResults = function (items) {
        if (!this._dropdownContentElement)
            return;
        var optionsContainer = this._dropdownContentElement.querySelector('[data-kt-select-options]');
        if (!optionsContainer)
            return;
        // Clear current options
        optionsContainer.innerHTML = '';
        if (items.length === 0) {
            // Show no results message using template for consistency and customization
            var noResultsElement = templates_1.defaultTemplates.searchEmpty(this._config);
            optionsContainer.appendChild(noResultsElement);
            return;
        }
        // Process each item individually to create options
        items.forEach(function (item) {
            // Create option for the original select
            var selectOption = document.createElement('option');
            selectOption.value = item.id;
            // Add to dropdown container
            optionsContainer.appendChild(selectOption);
        });
        // Add pagination "Load More" button if needed
        if (this._config.pagination && this._remoteModule.hasMorePages()) {
            this._addLoadMoreButton();
        }
        // Update options NodeList
        this._options = this._wrapperElement.querySelectorAll("[data-kt-select-option]");
    };
    /**
     * Check if dropdown is open
     */
    KTSelect.prototype.isDropdownOpen = function () {
        return this._dropdownIsOpen;
    };
    KTSelect.prototype.getSelectedOptionsText = function () {
        var _this = this;
        var selectedValues = this.getSelectedOptions();
        var displaySeparator = this._config.displaySeparator || ', ';
        var texts = selectedValues.map(function (value) {
            var option = Array.from(_this._options).find(function (opt) { return opt.getAttribute('data-value') === value; });
            return (option === null || option === void 0 ? void 0 : option.getAttribute('data-text')) || '';
        }).filter(Boolean);
        return texts.join(displaySeparator);
    };
    /**
     * Check if an option is disabled (either in dropdown or original select)
     */
    KTSelect.prototype._isOptionDisabled = function (value) {
        var dropdownOption = Array.from(this._options).find(function (opt) { return opt.getAttribute('data-value') === value; });
        var isDropdownDisabled = dropdownOption && (dropdownOption.classList.contains('disabled') || dropdownOption.getAttribute('aria-disabled') === 'true');
        var selectOption = Array.from(this._element.querySelectorAll('option')).find(function (opt) { return opt.value === value; });
        var isNativeDisabled = selectOption && selectOption.disabled;
        return Boolean(isDropdownDisabled || isNativeDisabled);
    };
    /**
     * Centralized keyboard event handler for all select modes
     */
    KTSelect.prototype._handleKeyboardEvent = function (event) {
        // If the event target is the search input and the event was already handled (defaultPrevented),
        // then return early to avoid duplicate processing by this broader handler.
        if (event.target === this._searchInputElement && event.defaultPrevented) {
            return;
        }
        var isOpen = this._dropdownIsOpen;
        var config = this._config;
        var focusManager = this._focusManager;
        var buffer = this._typeToSearchBuffer;
        // If the event target is the search input, let it handle most typing keys naturally.
        if (event.target === this._searchInputElement) {
            // Allow navigation keys like ArrowDown, ArrowUp, Escape, Enter (for search/selection) to be handled by the logic below.
            // For other keys (characters, space, backspace, delete), let the input field process them.
            if (event.key !== 'ArrowDown' && event.key !== 'ArrowUp' &&
                event.key !== 'Escape' && event.key !== 'Enter' && event.key !== 'Tab' &&
                event.key !== 'Home' && event.key !== 'End') {
                // If it's a character key and we are NOT type-to-searching (because search has focus)
                // then let the input field handle it for its own value.
                // The search module's 'input' event will handle filtering based on the input's value.
                buffer.clear(); // Clear type-to-search buffer when typing in search field
                return;
            }
            // For Enter specifically in search input, we might want to select the focused option or submit search.
            // This is handled later in the switch.
        }
        // Ignore modifier keys (except for specific combinations if added later)
        if (event.altKey || event.ctrlKey || event.metaKey)
            return;
        // Type-to-search: only for single char keys, when search input does not have focus
        if (event.key.length === 1 && !event.repeat && !event.key.match(/\s/) && document.activeElement !== this._searchInputElement) {
            buffer.push(event.key);
            var str = buffer.getBuffer();
            if (isOpen) {
                focusManager.focusByString(str);
            }
            else {
                // If closed, type-to-search could potentially open and select.
                // For now, let's assume it only works when open or opens it first.
                // Or, we could find the matching option and set it directly without opening.
            }
            return; // Type-to-search handles the event
        }
        switch (event.key) {
            case 'ArrowDown':
                event.preventDefault();
                if (!isOpen) {
                    this.openDropdown();
                }
                else {
                    focusManager.focusNext();
                }
                break;
            case 'ArrowUp':
                event.preventDefault();
                if (!isOpen) {
                    this.openDropdown();
                }
                else {
                    focusManager.focusPrevious();
                }
                break;
            case 'Home':
                event.preventDefault();
                if (isOpen)
                    focusManager.focusFirst();
                break;
            case 'End':
                event.preventDefault();
                if (isOpen)
                    focusManager.focusLast();
                break;
            case 'Enter':
            case ' ': // Space
                if (isOpen) {
                    var focusedOptionEl = this._focusManager.getFocusedOption();
                    if (focusedOptionEl) {
                        var val = focusedOptionEl.dataset.value;
                        // If single select, and the item is already selected, just close.
                        if (val !== undefined && !this._config.multiple && this._state.isSelected(val)) {
                            if (this._config.debug)
                                console.log('Enter on already selected item in single-select mode. Closing.');
                            this.closeDropdown();
                            event.preventDefault();
                            break;
                        }
                    }
                    // Proceed with selection if not handled above
                    this.selectFocusedOption();
                    // Close dropdown only for single select mode (for new selections)
                    // Keep dropdown open for multiple select mode to allow additional selections
                    if (!this._config.multiple) {
                        // This will also be true for the case handled above, but closeDropdown is idempotent.
                        // However, the break above prevents this from being reached for that specific case.
                        this.closeDropdown();
                    }
                    event.preventDefault(); // Prevent form submission or other default actions
                    break;
                }
                else {
                    this.openDropdown();
                }
                break;
            case 'Escape':
                if (isOpen) {
                    this.closeDropdown();
                    event.target.blur();
                }
                break;
            case 'Tab':
                // Let Tab propagate for normal focus movement
                break;
            default:
                break;
        }
    };
    KTSelect.prototype.renderDisplayTemplateForSelected = function (selectedValues) {
        var _this = this;
        var optionsConfig = this._config.optionsConfig || {};
        var displaySeparator = this._config.displaySeparator || ', ';
        var contentArray = Array.from(new Set(selectedValues.map(function (value) {
            var option = Array.from(_this._options).find(function (opt) { return opt.getAttribute('data-value') === value; });
            if (!option)
                return '';
            var displayTemplate = _this._config.displayTemplate;
            var text = option.getAttribute('data-text') || '';
            // Replace all {{varname}} in option.innerHTML with values from _config
            Object.entries(optionsConfig[value] || {}).forEach(function (_a) {
                var key = _a[0], val = _a[1];
                if (["string", "number", "boolean"].includes(typeof val)) {
                    displayTemplate = displayTemplate.replace(new RegExp("{{".concat(key, "}}"), 'g'), String(val));
                }
            });
            return (0, utils_1.renderTemplateString)(displayTemplate, {
                selectedCount: selectedValues.length || 0,
                selectedTexts: _this.getSelectedOptionsText() || '',
                text: text,
            });
        }).filter(Boolean)));
        return contentArray.join(displaySeparator);
    };
    KTSelect.prototype.getDisplayElement = function () {
        return this._displayElement;
    };
    KTSelect.prototype._observeNativeSelect = function () {
        var _this = this;
        if (this._mutationObserver)
            return; // Prevent double observers
        this._mutationObserver = new MutationObserver(function (mutations) {
            var needsRebuild = false;
            var needsSelectionSync = false;
            for (var _i = 0, mutations_1 = mutations; _i < mutations_1.length; _i++) {
                var mutation = mutations_1[_i];
                if (mutation.type === 'childList') {
                    // Option(s) added or removed
                    needsRebuild = true;
                }
                else if (mutation.type === 'attributes' && mutation.target instanceof HTMLOptionElement) {
                    if (mutation.attributeName === 'selected') {
                        needsSelectionSync = true;
                    }
                }
            }
            if (needsRebuild) {
                // Rebuild the custom dropdown options
                _this._rebuildOptionsFromNative();
            }
            if (needsSelectionSync) {
                _this._syncSelectionFromNative();
            }
        });
        this._mutationObserver.observe(this._element, {
            childList: true,
            attributes: true,
            subtree: true,
            attributeFilter: ['selected'],
        });
    };
    KTSelect.prototype._rebuildOptionsFromNative = function () {
        var _this = this;
        // Remove and rebuild the custom dropdown options from the native select
        if (this._dropdownContentElement) {
            var optionsContainer_1 = this._dropdownContentElement.querySelector('[data-kt-select-options]');
            if (optionsContainer_1) {
                optionsContainer_1.innerHTML = '';
                var options = Array.from(this._element.querySelectorAll('option'));
                options.forEach(function (optionElement) {
                    if (optionElement.value === '' &&
                        optionElement.textContent.trim() === '') {
                        return;
                    }
                    var selectOption = new option_1.KTSelectOption(optionElement, _this._config);
                    var renderedOption = selectOption.render();
                    optionsContainer_1.appendChild(renderedOption);
                });
                // Update internal references
                this._options = this._wrapperElement.querySelectorAll('[data-kt-select-option]');
            }
        }
        // Sync selection after rebuilding
        this._syncSelectionFromNative();
        this.updateSelectedOptionDisplay();
        this._updateSelectedOptionClass();
    };
    KTSelect.prototype._syncSelectionFromNative = function () {
        // Sync internal state from the native select's selected options
        var selected = Array.from(this._element.querySelectorAll('option:checked')).map(function (opt) { return opt.value; });
        this._state.setSelectedOptions(this._config.multiple ? selected : selected[0] || '');
        this.updateSelectedOptionDisplay();
        this._updateSelectedOptionClass();
    };
    /**
     * ========================================================================
     * STATIC METHODS
     * ========================================================================
     */
    KTSelect._instances = new Map();
    return KTSelect;
}(component_1.default));
exports.KTSelect = KTSelect;


/***/ }),

/***/ 8069:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


/**
 * KTUI - Free & Open-Source Tailwind UI Components by Keenthemes
 * Copyright 2025 by Keenthemes Inc
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.KTTooltip = void 0;
var tooltip_1 = __webpack_require__(1850);
Object.defineProperty(exports, "KTTooltip", ({ enumerable: true, get: function () { return tooltip_1.KTTooltip; } }));


/***/ }),

/***/ 8151:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


/**
 * KTUI - Free & Open-Source Tailwind UI Components by Keenthemes
 * Copyright 2025 by Keenthemes Inc
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.KTDatepickerKeyboard = void 0;
var events_1 = __webpack_require__(5795);
/**
 * Keyboard navigation handler for KTDatepicker
 */
var KTDatepickerKeyboard = /** @class */ (function () {
    /**
     * Constructor for the KTDatepickerKeyboard class
     *
     * @param element - The datepicker element
     * @param stateManager - State manager for the datepicker
     */
    function KTDatepickerKeyboard(element, stateManager) {
        var _this = this;
        this._focusedDay = null;
        this._isListening = false;
        /**
         * Handle keydown events
         */
        this._handleKeyDown = function (e) {
            var state = _this._stateManager.getState();
            var viewMode = state.viewMode;
            // ESC key closes the dropdown
            if (e.key === 'Escape') {
                e.preventDefault();
                _this._stateManager.setOpen(false);
                return;
            }
            // Handle different view modes differently
            switch (viewMode) {
                case 'days':
                    _this._handleDaysViewKeyNavigation(e);
                    break;
                case 'months':
                    _this._handleMonthsViewKeyNavigation(e);
                    break;
                case 'years':
                    _this._handleYearsViewKeyNavigation(e);
                    break;
            }
        };
        this._element = element;
        this._stateManager = stateManager;
        this._eventManager = stateManager.getEventManager();
        // Set up listeners
        this._setupEventListeners();
    }
    /**
     * Set up event listeners for keyboard navigation
     */
    KTDatepickerKeyboard.prototype._setupEventListeners = function () {
        var _this = this;
        // Listen for open/close events to activate/deactivate keyboard navigation
        this._eventManager.addEventListener(events_1.KTDatepickerEventName.OPEN, function () {
            return _this._activateKeyboardNavigation();
        });
        this._eventManager.addEventListener(events_1.KTDatepickerEventName.CLOSE, function () {
            return _this._deactivateKeyboardNavigation();
        });
        // Listen for custom keyboard-open event
        this._eventManager.addEventListener(events_1.KTDatepickerEventName.KEYBOARD_OPEN, function () {
            // Ensure we activate keyboard navigation
            _this._activateKeyboardNavigation();
            // Set initial focus day with a slight delay to allow the dropdown to render
            setTimeout(function () {
                // Initialize focused day if needed
                if (_this._focusedDay === null) {
                    var state = _this._stateManager.getState();
                    if (state.selectedDate) {
                        _this._focusedDay = state.selectedDate.getDate();
                    }
                    else {
                        _this._focusedDay = new Date().getDate();
                    }
                }
                // Focus the day
                _this._focusDay();
            }, 150);
        });
        // Handle focus events
        this._element.addEventListener('focusin', function (e) {
            if (_this._stateManager.getState().isOpen && !_this._isListening) {
                _this._activateKeyboardNavigation();
            }
        });
        // Add keydown event to the element itself to open dropdown with Enter key
        this._element.addEventListener('keydown', function (e) {
            var state = _this._stateManager.getState();
            // If not open yet, handle keys that should open the dropdown
            if (!state.isOpen) {
                if (e.key === 'Enter' ||
                    e.key === ' ' ||
                    e.key === 'ArrowDown' ||
                    e.key === 'ArrowUp') {
                    e.preventDefault();
                    e.stopPropagation(); // Prevent other handlers from capturing this event
                    _this._stateManager.setOpen(true);
                    // Set initial focus day if none
                    if (_this._focusedDay === null) {
                        if (state.selectedDate) {
                            _this._focusedDay = state.selectedDate.getDate();
                        }
                        else {
                            _this._focusedDay = new Date().getDate();
                        }
                        // Focus the day after dropdown opens
                        setTimeout(function () { return _this._focusDay(); }, 150);
                    }
                }
            }
        });
        // Add an additional event listener to the input field specifically
        var inputs = this._element.querySelectorAll('input');
        inputs.forEach(function (input) {
            input.addEventListener('keydown', function (e) {
                var state = _this._stateManager.getState();
                if (!state.isOpen) {
                    if (e.key === 'Enter' ||
                        e.key === ' ' ||
                        e.key === 'ArrowDown' ||
                        e.key === 'ArrowUp') {
                        e.preventDefault();
                        e.stopPropagation();
                        _this._stateManager.setOpen(true);
                        // Set initial focus day
                        if (_this._focusedDay === null) {
                            if (state.selectedDate) {
                                _this._focusedDay = state.selectedDate.getDate();
                            }
                            else {
                                _this._focusedDay = new Date().getDate();
                            }
                            // Focus the day after dropdown opens
                            setTimeout(function () { return _this._focusDay(); }, 150);
                        }
                    }
                }
            });
        });
        // Add an even more specific listener for Enter key on the display element
        var displayElement = this._element.querySelector('[data-kt-datepicker-display]');
        if (displayElement) {
            displayElement.addEventListener('keydown', function (e) {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    e.stopPropagation();
                    var state_1 = _this._stateManager.getState();
                    if (!state_1.isOpen) {
                        _this._stateManager.setOpen(true);
                        // Focus the current day with a slightly longer delay
                        setTimeout(function () {
                            if (_this._focusedDay === null) {
                                if (state_1.selectedDate) {
                                    _this._focusedDay = state_1.selectedDate.getDate();
                                }
                                else {
                                    _this._focusedDay = new Date().getDate();
                                }
                            }
                            _this._focusDay();
                        }, 200);
                    }
                }
            }, true); // Use capture phase to ensure this runs first
        }
    };
    /**
     * Activate keyboard navigation
     */
    KTDatepickerKeyboard.prototype._activateKeyboardNavigation = function () {
        var _this = this;
        if (this._isListening)
            return;
        // Add global keydown listener
        document.addEventListener('keydown', this._handleKeyDown);
        this._isListening = true;
        // Set initial focus day if none
        if (this._focusedDay === null) {
            var state = this._stateManager.getState();
            if (state.selectedDate) {
                this._focusedDay = state.selectedDate.getDate();
            }
            else {
                this._focusedDay = new Date().getDate();
            }
            // Focus the day
            setTimeout(function () { return _this._focusDay(); }, 100);
        }
    };
    /**
     * Deactivate keyboard navigation
     */
    KTDatepickerKeyboard.prototype._deactivateKeyboardNavigation = function () {
        if (!this._isListening)
            return;
        // Remove global keydown listener
        document.removeEventListener('keydown', this._handleKeyDown);
        this._isListening = false;
    };
    /**
     * Handle key navigation in days view
     */
    KTDatepickerKeyboard.prototype._handleDaysViewKeyNavigation = function (e) {
        var state = this._stateManager.getState();
        var config = this._stateManager.getConfig();
        var currentDate = new Date(state.currentDate);
        var daysInMonth = new Date(currentDate.getFullYear(), currentDate.getMonth() + 1, 0).getDate();
        // Get the day of week for the first day of the month to calculate grid positions
        var firstDayOfMonth = new Date(currentDate.getFullYear(), currentDate.getMonth(), 1).getDay();
        // Adjust for first day of week setting
        var firstDayOffset = (firstDayOfMonth - config.locales[config.locale].firstDayOfWeek + 7) % 7;
        // Ensure we have a focused day
        if (this._focusedDay === null) {
            if (state.selectedDate) {
                this._focusedDay = state.selectedDate.getDate();
            }
            else {
                this._focusedDay = new Date().getDate();
            }
        }
        switch (e.key) {
            case 'ArrowLeft':
                e.preventDefault();
                e.stopPropagation(); // Stop event propagation
                if (this._focusedDay === 1) {
                    // Move to previous month
                    var newDate = new Date(currentDate);
                    newDate.setMonth(newDate.getMonth() - 1);
                    this._stateManager.setCurrentDate(newDate);
                    // Set focus to last day of previous month
                    var lastDayPrevMonth = new Date(currentDate.getFullYear(), currentDate.getMonth(), 0).getDate();
                    this._focusedDay = lastDayPrevMonth;
                }
                else {
                    this._focusedDay = Math.max(1, (this._focusedDay || 1) - 1);
                }
                this._focusDay();
                break;
            case 'ArrowRight':
                e.preventDefault();
                e.stopPropagation(); // Stop event propagation
                if (this._focusedDay === daysInMonth) {
                    // Move to next month
                    var newDate = new Date(currentDate);
                    newDate.setMonth(newDate.getMonth() + 1);
                    this._stateManager.setCurrentDate(newDate);
                    // Set focus to first day of next month
                    this._focusedDay = 1;
                }
                else {
                    this._focusedDay = Math.min(daysInMonth, (this._focusedDay || 1) + 1);
                }
                this._focusDay();
                break;
            case 'ArrowUp':
                e.preventDefault();
                e.stopPropagation(); // Stop event propagation
                if (this._focusedDay && this._focusedDay <= 7) {
                    // We're in the first row of the current month
                    // Calculate the row position in the grid
                    var dayPosition = (this._focusedDay - 1 + firstDayOffset) % 7;
                    // Move to previous month
                    var newDate = new Date(currentDate);
                    newDate.setMonth(newDate.getMonth() - 1);
                    this._stateManager.setCurrentDate(newDate);
                    // Get days in previous month
                    var lastDayPrevMonth = new Date(currentDate.getFullYear(), currentDate.getMonth(), 0).getDate();
                    // Calculate the corresponding day in the previous month's last row
                    // Start with the last day of previous month
                    this._focusedDay = lastDayPrevMonth - (6 - dayPosition);
                }
                else {
                    // Move up one week (7 days)
                    this._focusedDay = (this._focusedDay || 1) - 7;
                }
                this._focusDay();
                break;
            case 'ArrowDown':
                e.preventDefault();
                e.stopPropagation(); // Stop event propagation
                var lastRowStart = daysInMonth - ((daysInMonth + firstDayOffset) % 7);
                if (this._focusedDay && this._focusedDay > lastRowStart) {
                    // We're in the last row of the current month
                    // Calculate position in last row (0-6)
                    var dayPosition = (this._focusedDay - 1 + firstDayOffset) % 7;
                    // Move to next month
                    var newDate = new Date(currentDate);
                    newDate.setMonth(newDate.getMonth() + 1);
                    this._stateManager.setCurrentDate(newDate);
                    // Calculate the corresponding day in next month's first row
                    this._focusedDay =
                        dayPosition + 1 - ((dayPosition + firstDayOffset) % 7);
                    // Ensure we're in bounds for next month
                    var nextMonthDays_1 = new Date(newDate.getFullYear(), newDate.getMonth() + 1, 0).getDate();
                    this._focusedDay = Math.min(this._focusedDay, nextMonthDays_1);
                }
                else {
                    // Move down one week (7 days)
                    this._focusedDay = Math.min(daysInMonth, (this._focusedDay || 1) + 7);
                }
                this._focusDay();
                break;
            case 'Home':
                e.preventDefault();
                // Move to first day of the month
                this._focusedDay = 1;
                this._focusDay();
                break;
            case 'End':
                e.preventDefault();
                // Move to last day of the month
                this._focusedDay = daysInMonth;
                this._focusDay();
                break;
            case 'PageUp':
                e.preventDefault();
                // Move to previous month
                var prevMonthDate = new Date(currentDate);
                prevMonthDate.setMonth(prevMonthDate.getMonth() - 1);
                this._stateManager.setCurrentDate(prevMonthDate);
                // Adjust focused day if needed
                var prevMonthDays = new Date(prevMonthDate.getFullYear(), prevMonthDate.getMonth() + 1, 0).getDate();
                if (this._focusedDay > prevMonthDays) {
                    this._focusedDay = prevMonthDays;
                }
                this._focusDay();
                break;
            case 'PageDown':
                e.preventDefault();
                // Move to next month
                var nextMonthDate = new Date(currentDate);
                nextMonthDate.setMonth(nextMonthDate.getMonth() + 1);
                this._stateManager.setCurrentDate(nextMonthDate);
                // Adjust focused day if needed
                var nextMonthDays = new Date(nextMonthDate.getFullYear(), nextMonthDate.getMonth() + 1, 0).getDate();
                if (this._focusedDay > nextMonthDays) {
                    this._focusedDay = nextMonthDays;
                }
                this._focusDay();
                break;
            case 'Enter':
            case ' ':
                e.preventDefault();
                if (this._focusedDay) {
                    // Select the focused day
                    var selectedDate = new Date(currentDate);
                    selectedDate.setDate(this._focusedDay);
                    if (config.enableTime && state.selectedTime) {
                        selectedDate.setHours(state.selectedTime.hours, state.selectedTime.minutes, state.selectedTime.seconds);
                    }
                    else {
                        selectedDate.setHours(0, 0, 0, 0);
                    }
                    this._stateManager.setSelectedDate(selectedDate);
                    // Close the dropdown if not range selection or if range is complete
                    if (!config.range ||
                        (state.selectedDateRange &&
                            state.selectedDateRange.startDate &&
                            state.selectedDateRange.endDate)) {
                        this._stateManager.setOpen(false);
                    }
                }
                break;
        }
    };
    /**
     * Handle key navigation in months view
     */
    KTDatepickerKeyboard.prototype._handleMonthsViewKeyNavigation = function (e) {
        var state = this._stateManager.getState();
        var currentDate = new Date(state.currentDate);
        var currentMonth = currentDate.getMonth();
        switch (e.key) {
            case 'ArrowLeft':
                e.preventDefault();
                currentDate.setMonth((currentMonth - 1 + 12) % 12);
                this._stateManager.setCurrentDate(currentDate);
                break;
            case 'ArrowRight':
                e.preventDefault();
                currentDate.setMonth((currentMonth + 1) % 12);
                this._stateManager.setCurrentDate(currentDate);
                break;
            case 'ArrowUp':
                e.preventDefault();
                currentDate.setMonth((currentMonth - 3 + 12) % 12);
                this._stateManager.setCurrentDate(currentDate);
                break;
            case 'ArrowDown':
                e.preventDefault();
                currentDate.setMonth((currentMonth + 3) % 12);
                this._stateManager.setCurrentDate(currentDate);
                break;
            case 'Home':
                e.preventDefault();
                currentDate.setMonth(0);
                this._stateManager.setCurrentDate(currentDate);
                break;
            case 'End':
                e.preventDefault();
                currentDate.setMonth(11);
                this._stateManager.setCurrentDate(currentDate);
                break;
            case 'Enter':
            case ' ':
                e.preventDefault();
                this._stateManager.setViewMode('days');
                break;
        }
    };
    /**
     * Handle key navigation in years view
     */
    KTDatepickerKeyboard.prototype._handleYearsViewKeyNavigation = function (e) {
        var state = this._stateManager.getState();
        var currentDate = new Date(state.currentDate);
        var currentYear = currentDate.getFullYear();
        switch (e.key) {
            case 'ArrowLeft':
                e.preventDefault();
                currentDate.setFullYear(currentYear - 1);
                this._stateManager.setCurrentDate(currentDate);
                break;
            case 'ArrowRight':
                e.preventDefault();
                currentDate.setFullYear(currentYear + 1);
                this._stateManager.setCurrentDate(currentDate);
                break;
            case 'ArrowUp':
                e.preventDefault();
                currentDate.setFullYear(currentYear - 4);
                this._stateManager.setCurrentDate(currentDate);
                break;
            case 'ArrowDown':
                e.preventDefault();
                currentDate.setFullYear(currentYear + 4);
                this._stateManager.setCurrentDate(currentDate);
                break;
            case 'Home':
                e.preventDefault();
                var yearsPerView = this._stateManager.getConfig().visibleYears;
                var startYear = currentYear - (currentYear % yearsPerView);
                currentDate.setFullYear(startYear);
                this._stateManager.setCurrentDate(currentDate);
                break;
            case 'End':
                e.preventDefault();
                var yearsPerPage = this._stateManager.getConfig().visibleYears;
                var startYearEnd = currentYear - (currentYear % yearsPerPage);
                var endYear = startYearEnd + yearsPerPage - 1;
                currentDate.setFullYear(endYear);
                this._stateManager.setCurrentDate(currentDate);
                break;
            case 'PageUp':
                e.preventDefault();
                var yearsPerPageUp = this._stateManager.getConfig().visibleYears;
                currentDate.setFullYear(currentYear - yearsPerPageUp);
                this._stateManager.setCurrentDate(currentDate);
                break;
            case 'PageDown':
                e.preventDefault();
                var yearsPerPageDown = this._stateManager.getConfig().visibleYears;
                currentDate.setFullYear(currentYear + yearsPerPageDown);
                this._stateManager.setCurrentDate(currentDate);
                break;
            case 'Enter':
            case ' ':
                e.preventDefault();
                this._stateManager.setViewMode('months');
                break;
        }
    };
    /**
     * Focus the currently focused day in the calendar
     */
    KTDatepickerKeyboard.prototype._focusDay = function () {
        if (!this._focusedDay)
            return;
        var state = this._stateManager.getState();
        // Try different selectors for the dropdown
        var selectors = [
            '.absolute.bg-white.shadow-lg.rounded-lg',
            '.kt-datepicker-dropdown',
            '.calendar-container',
        ];
        var dropdown = null;
        for (var _i = 0, selectors_1 = selectors; _i < selectors_1.length; _i++) {
            var selector = selectors_1[_i];
            dropdown = this._element.querySelector(selector);
            if (dropdown)
                break;
        }
        if (!dropdown) {
            // If no dropdown found, try getting any element with calendar buttons
            dropdown =
                this._element.querySelector('.multiple-months') ||
                    this._element.querySelector('[data-kt-datepicker-container]') ||
                    this._element;
        }
        var currentDay = this._focusedDay;
        var currentMonth = state.currentDate.getMonth();
        var currentYear = state.currentDate.getFullYear();
        // First try to find the day in the current month
        var dayButton = dropdown.querySelector("button[data-date=\"".concat(currentDay, "\"]:not(.text-gray-400)"));
        // If not found, try to find any button with the day number
        if (!dayButton) {
            dayButton = dropdown.querySelector("button[data-date=\"".concat(currentDay, "\"]"));
        }
        // If still not found, try to find by date-id
        if (!dayButton) {
            var dateId = "".concat(currentYear, "-").concat(String(currentMonth + 1).padStart(2, '0'), "-").concat(String(currentDay).padStart(2, '0'));
            dayButton = dropdown.querySelector("button[data-date-id=\"".concat(dateId, "\"]"));
        }
        // As a last resort, find any day button
        if (!dayButton) {
            dayButton = dropdown.querySelector('button[data-date]');
        }
        // Focus the day button if found
        if (dayButton) {
            dayButton.focus();
            // Scroll into view if needed
            if (dayButton.scrollIntoView) {
                dayButton.scrollIntoView({ block: 'nearest', behavior: 'smooth' });
            }
        }
    };
    return KTDatepickerKeyboard;
}());
exports.KTDatepickerKeyboard = KTDatepickerKeyboard;


/***/ }),

/***/ 8156:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


/**
 * KTUI - Free & Open-Source Tailwind UI Components by Keenthemes
 * Copyright 2025 by Keenthemes Inc
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.KTToast = exports.KTSelect = exports.KTDatepicker = exports.KTDataTable = exports.KTTogglePassword = exports.KTImageInput = exports.KTThemeSwitch = exports.KTStepper = exports.KTTooltip = exports.KTToggle = exports.KTReparent = exports.KTSticky = exports.KTScrollto = exports.KTScrollable = exports.KTScrollspy = exports.KTAccordion = exports.KTTabs = exports.KTDismiss = exports.KTCollapse = exports.KTDrawer = exports.KTModal = exports.KTDropdown = void 0;
var dom_1 = __webpack_require__(9010);
var dropdown_1 = __webpack_require__(5071);
var modal_1 = __webpack_require__(3395);
var drawer_1 = __webpack_require__(8559);
var collapse_1 = __webpack_require__(8465);
var dismiss_1 = __webpack_require__(7586);
var tabs_1 = __webpack_require__(5634);
var accordion_1 = __webpack_require__(2800);
var scrollspy_1 = __webpack_require__(5251);
var scrollable_1 = __webpack_require__(1851);
var scrollto_1 = __webpack_require__(3998);
var sticky_1 = __webpack_require__(733);
var reparent_1 = __webpack_require__(4139);
var toggle_1 = __webpack_require__(5650);
var tooltip_1 = __webpack_require__(8069);
var stepper_1 = __webpack_require__(5907);
var theme_switch_1 = __webpack_require__(9250);
var image_input_1 = __webpack_require__(9018);
var toggle_password_1 = __webpack_require__(2232);
var datatable_1 = __webpack_require__(2626);
var datepicker_1 = __webpack_require__(5116);
var select_1 = __webpack_require__(494);
var toast_1 = __webpack_require__(6265);
var dropdown_2 = __webpack_require__(5071);
Object.defineProperty(exports, "KTDropdown", ({ enumerable: true, get: function () { return dropdown_2.KTDropdown; } }));
var modal_2 = __webpack_require__(3395);
Object.defineProperty(exports, "KTModal", ({ enumerable: true, get: function () { return modal_2.KTModal; } }));
var drawer_2 = __webpack_require__(8559);
Object.defineProperty(exports, "KTDrawer", ({ enumerable: true, get: function () { return drawer_2.KTDrawer; } }));
var collapse_2 = __webpack_require__(8465);
Object.defineProperty(exports, "KTCollapse", ({ enumerable: true, get: function () { return collapse_2.KTCollapse; } }));
var dismiss_2 = __webpack_require__(7586);
Object.defineProperty(exports, "KTDismiss", ({ enumerable: true, get: function () { return dismiss_2.KTDismiss; } }));
var tabs_2 = __webpack_require__(5634);
Object.defineProperty(exports, "KTTabs", ({ enumerable: true, get: function () { return tabs_2.KTTabs; } }));
var accordion_2 = __webpack_require__(2800);
Object.defineProperty(exports, "KTAccordion", ({ enumerable: true, get: function () { return accordion_2.KTAccordion; } }));
var scrollspy_2 = __webpack_require__(5251);
Object.defineProperty(exports, "KTScrollspy", ({ enumerable: true, get: function () { return scrollspy_2.KTScrollspy; } }));
var scrollable_2 = __webpack_require__(1851);
Object.defineProperty(exports, "KTScrollable", ({ enumerable: true, get: function () { return scrollable_2.KTScrollable; } }));
var scrollto_2 = __webpack_require__(3998);
Object.defineProperty(exports, "KTScrollto", ({ enumerable: true, get: function () { return scrollto_2.KTScrollto; } }));
var sticky_2 = __webpack_require__(733);
Object.defineProperty(exports, "KTSticky", ({ enumerable: true, get: function () { return sticky_2.KTSticky; } }));
var reparent_2 = __webpack_require__(4139);
Object.defineProperty(exports, "KTReparent", ({ enumerable: true, get: function () { return reparent_2.KTReparent; } }));
var toggle_2 = __webpack_require__(5650);
Object.defineProperty(exports, "KTToggle", ({ enumerable: true, get: function () { return toggle_2.KTToggle; } }));
var tooltip_2 = __webpack_require__(8069);
Object.defineProperty(exports, "KTTooltip", ({ enumerable: true, get: function () { return tooltip_2.KTTooltip; } }));
var stepper_2 = __webpack_require__(5907);
Object.defineProperty(exports, "KTStepper", ({ enumerable: true, get: function () { return stepper_2.KTStepper; } }));
var theme_switch_2 = __webpack_require__(9250);
Object.defineProperty(exports, "KTThemeSwitch", ({ enumerable: true, get: function () { return theme_switch_2.KTThemeSwitch; } }));
var image_input_2 = __webpack_require__(9018);
Object.defineProperty(exports, "KTImageInput", ({ enumerable: true, get: function () { return image_input_2.KTImageInput; } }));
var toggle_password_2 = __webpack_require__(2232);
Object.defineProperty(exports, "KTTogglePassword", ({ enumerable: true, get: function () { return toggle_password_2.KTTogglePassword; } }));
var datatable_2 = __webpack_require__(2626);
Object.defineProperty(exports, "KTDataTable", ({ enumerable: true, get: function () { return datatable_2.KTDataTable; } }));
var datepicker_2 = __webpack_require__(5116);
Object.defineProperty(exports, "KTDatepicker", ({ enumerable: true, get: function () { return datepicker_2.KTDatepicker; } }));
var select_2 = __webpack_require__(494);
Object.defineProperty(exports, "KTSelect", ({ enumerable: true, get: function () { return select_2.KTSelect; } }));
var toast_2 = __webpack_require__(6265);
Object.defineProperty(exports, "KTToast", ({ enumerable: true, get: function () { return toast_2.KTToast; } }));
var KTComponents = {
    init: function () {
        dropdown_1.KTDropdown.init();
        modal_1.KTModal.init();
        drawer_1.KTDrawer.init();
        collapse_1.KTCollapse.init();
        dismiss_1.KTDismiss.init();
        tabs_1.KTTabs.init();
        accordion_1.KTAccordion.init();
        scrollspy_1.KTScrollspy.init();
        scrollable_1.KTScrollable.init();
        scrollto_1.KTScrollto.init();
        sticky_1.KTSticky.init();
        reparent_1.KTReparent.init();
        toggle_1.KTToggle.init();
        tooltip_1.KTTooltip.init();
        stepper_1.KTStepper.init();
        theme_switch_1.KTThemeSwitch.init();
        image_input_1.KTImageInput.init();
        toggle_password_1.KTTogglePassword.init();
        datatable_1.KTDataTable.init();
        datepicker_1.KTDatepicker.init();
        select_1.KTSelect.init();
        toast_1.KTToast.init();
    },
};
exports["default"] = KTComponents;
dom_1.default.ready(function () {
    KTComponents.init();
});


/***/ }),

/***/ 8465:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


/**
 * KTUI - Free & Open-Source Tailwind UI Components by Keenthemes
 * Copyright 2025 by Keenthemes Inc
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.KTCollapse = void 0;
var collapse_1 = __webpack_require__(1794);
Object.defineProperty(exports, "KTCollapse", ({ enumerable: true, get: function () { return collapse_1.KTCollapse; } }));


/***/ }),

/***/ 8474:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


/**
 * KTUI - Free & Open-Source Tailwind UI Components by Keenthemes
 * Copyright 2025 by Keenthemes Inc
 */
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.KTDropdown = void 0;
var core_1 = __webpack_require__(3915);
var dom_1 = __webpack_require__(9010);
var data_1 = __webpack_require__(8716);
var event_handler_1 = __webpack_require__(5183);
var component_1 = __webpack_require__(2658);
var KTDropdown = /** @class */ (function (_super) {
    __extends(KTDropdown, _super);
    function KTDropdown(element, config) {
        var _this = _super.call(this) || this;
        _this._name = 'dropdown';
        _this._defaultConfig = {
            zindex: 105,
            hoverTimeout: 200,
            placement: 'bottom-start',
            placementRtl: 'bottom-end',
            permanent: false,
            dismiss: false,
            keyboard: true,
            trigger: 'click',
            attach: '',
            offset: '0px, 5px',
            offsetRtl: '0px, 5px',
            hiddenClass: 'hidden',
            container: '',
        };
        _this._config = _this._defaultConfig;
        _this._disabled = false;
        _this._isTransitioning = false;
        _this._isOpen = false;
        if (data_1.default.has(element, _this._name))
            return _this;
        _this._init(element);
        _this._buildConfig(config);
        _this._toggleElement = _this._element.querySelector('[data-kt-dropdown-toggle]');
        if (!_this._toggleElement)
            return _this;
        _this._menuElement = _this._element.querySelector('[data-kt-dropdown-menu]');
        if (!_this._menuElement)
            return _this;
        data_1.default.set(_this._menuElement, 'dropdownElement', _this._element);
        _this._setupNestedDropdowns();
        _this._handleContainer();
        return _this;
    }
    KTDropdown.prototype._handleContainer = function () {
        var _a;
        if (this._getOption('container')) {
            if (this._getOption('container') === 'body') {
                document.body.appendChild(this._menuElement);
            }
            else {
                (_a = document
                    .querySelector(this._getOption('container'))) === null || _a === void 0 ? void 0 : _a.appendChild(this._menuElement);
            }
        }
    };
    KTDropdown.prototype._setupNestedDropdowns = function () {
        var subDropdowns = this._menuElement.querySelectorAll('[data-kt-dropdown-toggle]');
        subDropdowns.forEach(function (subToggle) {
            var _a;
            var subItem = subToggle.closest('[data-kt-dropdown-item]');
            var subMenu = (_a = subToggle
                .closest('.kt-menu-item')) === null || _a === void 0 ? void 0 : _a.querySelector('[data-kt-dropdown-menu]');
            if (subItem && subMenu) {
                new KTDropdown(subItem);
            }
        });
    };
    KTDropdown.prototype._click = function (event) {
        event.preventDefault();
        event.stopPropagation();
        if (this._disabled)
            return;
        if (this._getOption('trigger') !== 'click')
            return;
        this._toggle();
    };
    KTDropdown.prototype._mouseover = function (event) {
        if (this._disabled)
            return;
        if (this._getOption('trigger') !== 'hover')
            return;
        if (data_1.default.get(this._element, 'hover') === '1') {
            clearTimeout(data_1.default.get(this._element, 'timeout'));
            data_1.default.remove(this._element, 'hover');
            data_1.default.remove(this._element, 'timeout');
        }
        this._show();
    };
    KTDropdown.prototype._mouseout = function (event) {
        var _this = this;
        if (this._disabled)
            return;
        if (this._getOption('trigger') !== 'hover')
            return;
        var relatedTarget = event.relatedTarget;
        var isWithinDropdown = this._element.contains(relatedTarget);
        if (isWithinDropdown)
            return;
        var timeout = setTimeout(function () {
            if (data_1.default.get(_this._element, 'hover') === '1') {
                _this._hide();
            }
        }, parseInt(this._getOption('hoverTimeout')));
        data_1.default.set(this._element, 'hover', '1');
        data_1.default.set(this._element, 'timeout', timeout);
    };
    KTDropdown.prototype._toggle = function () {
        if (this._isOpen) {
            this._hide();
        }
        else {
            this._show();
        }
    };
    KTDropdown.prototype._show = function () {
        var _this = this;
        if (this._isOpen || this._isTransitioning)
            return;
        var payload = { cancel: false };
        this._fireEvent('show', payload);
        this._dispatchEvent('show', payload);
        if (payload.cancel)
            return;
        KTDropdown.hide(this._element);
        var zIndex = parseInt(this._getOption('zindex'));
        var parentZindex = dom_1.default.getHighestZindex(this._element);
        if (parentZindex !== null && parentZindex >= zIndex) {
            zIndex = parentZindex + 1;
        }
        if (zIndex > 0) {
            this._menuElement.style.zIndex = zIndex.toString();
        }
        this._menuElement.style.display = 'block';
        this._menuElement.style.opacity = '0';
        dom_1.default.reflow(this._menuElement);
        this._menuElement.style.opacity = '1';
        this._menuElement.classList.remove(this._getOption('hiddenClass'));
        this._toggleElement.classList.add('active');
        this._menuElement.classList.add('open');
        this._element.classList.add('open');
        this._initPopper();
        dom_1.default.transitionEnd(this._menuElement, function () {
            _this._isTransitioning = false;
            _this._isOpen = true;
            _this._fireEvent('shown');
            _this._dispatchEvent('shown');
        });
    };
    KTDropdown.prototype._hide = function () {
        var _this = this;
        if (!this._isOpen || this._isTransitioning)
            return;
        var payload = { cancel: false };
        this._fireEvent('hide', payload);
        this._dispatchEvent('hide', payload);
        if (payload.cancel)
            return;
        this._menuElement.style.opacity = '1';
        dom_1.default.reflow(this._menuElement);
        this._menuElement.style.opacity = '0';
        this._menuElement.classList.remove('open');
        this._toggleElement.classList.remove('active');
        this._element.classList.remove('open');
        dom_1.default.transitionEnd(this._menuElement, function () {
            _this._isTransitioning = false;
            _this._isOpen = false;
            _this._menuElement.classList.add(_this._getOption('hiddenClass'));
            _this._menuElement.style.display = '';
            _this._menuElement.style.zIndex = '';
            _this._destroyPopper();
            _this._fireEvent('hidden');
            _this._dispatchEvent('hidden');
        });
    };
    KTDropdown.prototype._initPopper = function () {
        var isRtl = dom_1.default.isRTL();
        var reference;
        var attach = this._getOption('attach');
        if (attach) {
            reference =
                attach === 'parent'
                    ? this._toggleElement.parentNode
                    : document.querySelector(attach);
        }
        else {
            reference = this._toggleElement;
        }
        if (reference) {
            var popper = (0, core_1.createPopper)(reference, this._menuElement, this._getPopperConfig());
            data_1.default.set(this._element, 'popper', popper);
        }
    };
    KTDropdown.prototype._destroyPopper = function () {
        if (data_1.default.has(this._element, 'popper')) {
            data_1.default.get(this._element, 'popper').destroy();
            data_1.default.remove(this._element, 'popper');
        }
    };
    KTDropdown.prototype._isDropdownOpen = function () {
        return (this._element.classList.contains('open') &&
            this._menuElement.classList.contains('open'));
    };
    KTDropdown.prototype._getPopperConfig = function () {
        var isRtl = dom_1.default.isRTL();
        var placement = this._getOption('placement');
        if (isRtl && this._getOption('placementRtl')) {
            placement = this._getOption('placementRtl');
        }
        var offsetValue = this._getOption('offset');
        if (isRtl && this._getOption('offsetRtl')) {
            offsetValue = this._getOption('offsetRtl');
        }
        var offset = offsetValue
            ? offsetValue
                .toString()
                .split(',')
                .map(function (value) { return parseInt(value.trim(), 10); })
            : [0, 0];
        var strategy = this._getOption('overflow') === true ? 'absolute' : 'fixed';
        var altAxis = this._getOption('flip') !== false;
        return {
            placement: placement,
            strategy: strategy,
            modifiers: [
                {
                    name: 'offset',
                    options: { offset: offset },
                },
                {
                    name: 'preventOverflow',
                    options: { altAxis: altAxis },
                },
                {
                    name: 'flip',
                    options: { flipVariations: false },
                },
            ],
        };
    };
    KTDropdown.prototype._getToggleElement = function () {
        return this._toggleElement;
    };
    KTDropdown.prototype._getContentElement = function () {
        return this._menuElement;
    };
    // General Methods
    KTDropdown.prototype.click = function (event) {
        this._click(event);
    };
    KTDropdown.prototype.mouseover = function (event) {
        this._mouseover(event);
    };
    KTDropdown.prototype.mouseout = function (event) {
        this._mouseout(event);
    };
    KTDropdown.prototype.show = function () {
        this._show();
    };
    KTDropdown.prototype.hide = function () {
        this._hide();
    };
    KTDropdown.prototype.toggle = function () {
        this._toggle();
    };
    KTDropdown.prototype.getToggleElement = function () {
        return this._toggleElement;
    };
    KTDropdown.prototype.getContentElement = function () {
        return this._menuElement;
    };
    KTDropdown.prototype.isPermanent = function () {
        return this._getOption('permanent');
    };
    KTDropdown.prototype.disable = function () {
        this._disabled = true;
    };
    KTDropdown.prototype.enable = function () {
        this._disabled = false;
    };
    KTDropdown.prototype.isOpen = function () {
        return this._isDropdownOpen();
    };
    // Static Methods
    KTDropdown.getElement = function (reference) {
        if (reference && reference.hasAttribute('data-kt-dropdown-initialized'))
            return reference;
        var findElement = reference &&
            reference.closest('[data-kt-dropdown-initialized]');
        if (findElement)
            return findElement;
        if (reference &&
            reference.hasAttribute('data-kt-dropdown-menu') &&
            data_1.default.has(reference, 'dropdownElement')) {
            return data_1.default.get(reference, 'dropdownElement');
        }
        return null;
    };
    KTDropdown.getInstance = function (element) {
        element = this.getElement(element);
        if (!element)
            return null;
        if (data_1.default.has(element, 'dropdown')) {
            return data_1.default.get(element, 'dropdown');
        }
        if (element.getAttribute('data-kt-dropdown-initialized') === 'true') {
            return new KTDropdown(element);
        }
        return null;
    };
    KTDropdown.getOrCreateInstance = function (element, config) {
        return this.getInstance(element) || new KTDropdown(element, config);
    };
    KTDropdown.update = function () {
        document
            .querySelectorAll('.open[data-kt-dropdown-initialized]')
            .forEach(function (item) {
            if (data_1.default.has(item, 'popper')) {
                data_1.default.get(item, 'popper').forceUpdate();
            }
        });
    };
    KTDropdown.hide = function (skipElement) {
        document
            .querySelectorAll('.open[data-kt-dropdown-initialized]:not([data-kt-dropdown-permanent="true"])')
            .forEach(function (item) {
            if (skipElement && (skipElement === item || item.contains(skipElement)))
                return;
            var dropdown = KTDropdown.getInstance(item);
            if (dropdown)
                dropdown.hide();
        });
    };
    KTDropdown.handleClickAway = function () {
        document.addEventListener('click', function (event) {
            document
                .querySelectorAll('.open[data-kt-dropdown-initialized]:not([data-kt-dropdown-permanent="true"])')
                .forEach(function (element) {
                var dropdown = KTDropdown.getInstance(element);
                if (!dropdown)
                    return;
                var contentElement = dropdown.getContentElement();
                var toggleElement = dropdown.getToggleElement();
                if (toggleElement === event.target ||
                    toggleElement.contains(event.target) ||
                    contentElement === event.target ||
                    contentElement.contains(event.target)) {
                    return;
                }
                dropdown.hide();
            });
        });
    };
    KTDropdown.handleKeyboard = function () {
        document.addEventListener('keydown', function (event) {
            var dropdownEl = document.querySelector('.open[data-kt-dropdown-initialized]');
            var dropdown = KTDropdown.getInstance(dropdownEl);
            if (!dropdown || !dropdown._getOption('keyboard'))
                return;
            if (event.key === 'Escape' &&
                !(event.ctrlKey || event.altKey || event.shiftKey)) {
                dropdown.hide();
            }
        });
    };
    KTDropdown.handleMouseover = function () {
        event_handler_1.default.on(document.body, '[data-kt-dropdown-toggle], [data-kt-dropdown-menu]', 'mouseover', function (event, target) {
            var dropdown = KTDropdown.getInstance(target);
            if (dropdown && dropdown._getOption('trigger') === 'hover') {
                dropdown.mouseover(event);
            }
        });
    };
    KTDropdown.handleMouseout = function () {
        event_handler_1.default.on(document.body, '[data-kt-dropdown-toggle], [data-kt-dropdown-menu]', 'mouseout', function (event, target) {
            var dropdown = KTDropdown.getInstance(target);
            if (dropdown && dropdown._getOption('trigger') === 'hover') {
                dropdown.mouseout(event);
            }
        });
    };
    KTDropdown.handleClick = function () {
        event_handler_1.default.on(document.body, '[data-kt-dropdown-toggle]', 'click', function (event, target) {
            var dropdown = KTDropdown.getInstance(target);
            if (dropdown) {
                dropdown.click(event);
            }
        });
    };
    KTDropdown.handleDismiss = function () {
        event_handler_1.default.on(document.body, '[data-kt-dropdown-dismiss]', 'click', function (event, target) {
            var dropdown = KTDropdown.getInstance(target);
            if (dropdown) {
                dropdown.hide();
            }
        });
    };
    KTDropdown.initHandlers = function () {
        this.handleClickAway();
        this.handleKeyboard();
        this.handleMouseover();
        this.handleMouseout();
        this.handleClick();
        this.handleDismiss();
    };
    KTDropdown.createInstances = function () {
        var elements = document.querySelectorAll('[data-kt-dropdown]');
        elements.forEach(function (element) {
            new KTDropdown(element);
        });
    };
    KTDropdown.init = function () {
        KTDropdown.createInstances();
        if (window.KT_DROPDOWN_INITIALIZED !== true) {
            KTDropdown.initHandlers();
            window.KT_DROPDOWN_INITIALIZED = true;
        }
    };
    return KTDropdown;
}(component_1.default));
exports.KTDropdown = KTDropdown;
if (typeof window !== 'undefined') {
    window.KTDropdown = KTDropdown;
}


/***/ }),

/***/ 8559:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


/**
 * KTUI - Free & Open-Source Tailwind UI Components by Keenthemes
 * Copyright 2025 by Keenthemes Inc
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.KTDrawer = void 0;
var drawer_1 = __webpack_require__(706);
Object.defineProperty(exports, "KTDrawer", ({ enumerable: true, get: function () { return drawer_1.KTDrawer; } }));


/***/ }),

/***/ 8599:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


/**
 * KTUI - Free & Open-Source Tailwind UI Components by Keenthemes
 * Copyright 2025 by Keenthemes Inc
 */
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.KTDatepickerDropdown = void 0;
var core_1 = __webpack_require__(3915);
var dom_1 = __webpack_require__(9010);
var data_1 = __webpack_require__(8716);
var component_1 = __webpack_require__(2658);
/**
 * Class to manage focus within the dropdown
 */
var FocusManager = /** @class */ (function () {
    function FocusManager(element) {
        this._focusableSelector = 'button:not([disabled]), [tabindex]:not([tabindex="-1"])';
        this._element = element;
    }
    /**
     * Get all visible focusable options
     */
    FocusManager.prototype.getVisibleOptions = function () {
        return Array.from(this._element.querySelectorAll(this._focusableSelector)).filter(function (el) {
            var element = el;
            return element.offsetParent !== null; // Only visible elements
        });
    };
    /**
     * Apply focus to an element
     */
    FocusManager.prototype.applyFocus = function (element) {
        if (element && typeof element.focus === 'function') {
            element.focus();
        }
    };
    /**
     * Focus next element
     */
    FocusManager.prototype.focusNext = function () {
        var options = this.getVisibleOptions();
        var currentFocused = document.activeElement;
        var nextIndex = 0;
        if (currentFocused) {
            var currentIndex = options.indexOf(currentFocused);
            nextIndex = currentIndex >= 0 ? (currentIndex + 1) % options.length : 0;
        }
        if (options.length > 0) {
            this.applyFocus(options[nextIndex]);
        }
    };
    /**
     * Focus previous element
     */
    FocusManager.prototype.focusPrevious = function () {
        var options = this.getVisibleOptions();
        var currentFocused = document.activeElement;
        var prevIndex = options.length - 1;
        if (currentFocused) {
            var currentIndex = options.indexOf(currentFocused);
            prevIndex =
                currentIndex >= 0
                    ? (currentIndex - 1 + options.length) % options.length
                    : prevIndex;
        }
        if (options.length > 0) {
            this.applyFocus(options[prevIndex]);
        }
    };
    /**
     * Scroll element into view
     */
    FocusManager.prototype.scrollIntoView = function (element) {
        if (element && typeof element.scrollIntoView === 'function') {
            element.scrollIntoView({ block: 'nearest', behavior: 'smooth' });
        }
    };
    /**
     * Clean up resources
     */
    FocusManager.prototype.dispose = function () {
        // Nothing to clean up yet
    };
    return FocusManager;
}());
/**
 * Class to manage event listeners
 */
var EventManager = /** @class */ (function () {
    function EventManager() {
        this._listeners = new Map();
    }
    /**
     * Add event listener and track it
     */
    EventManager.prototype.addListener = function (element, eventType, handler) {
        if (!this._listeners.has(element)) {
            this._listeners.set(element, new Map());
        }
        var elementListeners = this._listeners.get(element);
        if (!elementListeners.has(eventType)) {
            elementListeners.set(eventType, []);
        }
        var handlers = elementListeners.get(eventType);
        element.addEventListener(eventType, handler);
        handlers.push(handler);
    };
    /**
     * Remove all listeners for an element
     */
    EventManager.prototype.removeAllListeners = function (element) {
        if (this._listeners.has(element)) {
            var elementListeners = this._listeners.get(element);
            elementListeners.forEach(function (handlers, eventType) {
                handlers.forEach(function (handler) {
                    element.removeEventListener(eventType, handler);
                });
            });
            this._listeners.delete(element);
        }
    };
    return EventManager;
}());
/**
 * Focus trap class to manage keyboard focus within the dropdown
 */
var FocusTrap = /** @class */ (function () {
    /**
     * Constructor
     *
     * @param element - Element to trap focus within
     */
    function FocusTrap(element) {
        this._focusableElements = [];
        this._firstFocusableElement = null;
        this._lastFocusableElement = null;
        this._element = element;
        this._update();
    }
    /**
     * Update the focusable elements
     */
    FocusTrap.prototype.update = function () {
        this._update();
    };
    /**
     * Update the list of focusable elements
     */
    FocusTrap.prototype._update = function () {
        // Get all focusable elements
        var focusableElements = this._element.querySelectorAll('button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])');
        // Convert to array and filter out disabled elements
        this._focusableElements = Array.from(focusableElements).filter(function (el) { return !el.hasAttribute('disabled'); });
        // Get first and last focusable elements
        this._firstFocusableElement = this._focusableElements[0] || null;
        this._lastFocusableElement =
            this._focusableElements[this._focusableElements.length - 1] || null;
    };
    /**
     * Handle tab key press to trap focus
     *
     * @param event - Keyboard event
     */
    FocusTrap.prototype.handleTab = function (event) {
        // If no focusable elements, do nothing
        if (!this._firstFocusableElement || !this._lastFocusableElement) {
            event.preventDefault();
            return;
        }
        var isTabPressed = event.key === 'Tab' || event.keyCode === 9;
        if (!isTabPressed)
            return;
        // Handle Shift+Tab to focus last element when on first
        if (event.shiftKey) {
            if (document.activeElement === this._firstFocusableElement) {
                this._lastFocusableElement.focus();
                event.preventDefault();
            }
        }
        else {
            // Handle Tab to focus first element when on last
            if (document.activeElement === this._lastFocusableElement) {
                this._firstFocusableElement.focus();
                event.preventDefault();
            }
        }
    };
    /**
     * Focus the first interactive element
     */
    FocusTrap.prototype.focusFirstElement = function () {
        if (this._firstFocusableElement) {
            this._firstFocusableElement.focus();
        }
    };
    return FocusTrap;
}());
/**
 * KTDatepickerDropdown
 *
 * A specialized dropdown implementation for the KTDatepicker component.
 * This module handles the dropdown functionality for the datepicker component,
 * including positioning, showing/hiding, and keyboard navigation.
 */
var KTDatepickerDropdown = /** @class */ (function (_super) {
    __extends(KTDatepickerDropdown, _super);
    /**
     * Constructor
     * @param element The parent element (datepicker wrapper)
     * @param toggleElement The element that triggers the dropdown
     * @param dropdownElement The dropdown content element
     * @param config The configuration options
     */
    function KTDatepickerDropdown(element, toggleElement, dropdownElement, config) {
        var _this = _super.call(this) || this;
        _this._name = 'datepicker-dropdown';
        // State
        _this._isOpen = false;
        _this._isTransitioning = false;
        _this._popperInstance = null;
        _this._focusTrap = null;
        _this._activeElement = null;
        _this._element = element;
        _this._toggleElement = toggleElement;
        _this._dropdownElement = dropdownElement;
        _this._config = config;
        _this._eventManager = new EventManager();
        _this._focusManager = new FocusManager(dropdownElement);
        _this._setupEventListeners();
        return _this;
    }
    /**
     * Set up event listeners for the dropdown
     */
    KTDatepickerDropdown.prototype._setupEventListeners = function () {
        // Toggle click
        this._eventManager.addListener(this._toggleElement, 'click', this._handleToggleClick.bind(this));
        // Keyboard navigation
        this._eventManager.addListener(this._element, 'keydown', this._handleKeyDown.bind(this));
        // Close on outside click
        this._eventManager.addListener(document, 'click', this._handleOutsideClick.bind(this));
    };
    /**
     * Handle toggle element click
     */
    KTDatepickerDropdown.prototype._handleToggleClick = function (event) {
        event.preventDefault();
        event.stopPropagation();
        this.toggle();
    };
    /**
     * Handle keyboard events
     */
    KTDatepickerDropdown.prototype._handleKeyDown = function (event) {
        if (!this._isOpen)
            return;
        switch (event.key) {
            case 'Escape':
                event.preventDefault();
                this.close();
                this._toggleElement.focus();
                break;
            case 'ArrowDown':
                event.preventDefault();
                this._focusManager.focusNext();
                break;
            case 'ArrowUp':
                event.preventDefault();
                this._focusManager.focusPrevious();
                break;
            case 'Home':
                event.preventDefault();
                // Focus first visible option
                var firstOption = this._focusManager.getVisibleOptions()[0];
                if (firstOption) {
                    this._focusManager.applyFocus(firstOption);
                    this._focusManager.scrollIntoView(firstOption);
                }
                break;
            case 'End':
                event.preventDefault();
                // Focus last visible option
                var visibleOptions = this._focusManager.getVisibleOptions();
                var lastOption = visibleOptions[visibleOptions.length - 1];
                if (lastOption) {
                    this._focusManager.applyFocus(lastOption);
                    this._focusManager.scrollIntoView(lastOption);
                }
                break;
        }
    };
    /**
     * Handle clicks outside the dropdown
     */
    KTDatepickerDropdown.prototype._handleOutsideClick = function (event) {
        var _a;
        if (!this._isOpen)
            return;
        var target = event.target;
        if (!this._element.contains(target) &&
            !this._dropdownElement.contains(target)) {
            // Before closing, check if a range selection is in progress
            var datepickerElement = this._element.closest('[data-kt-datepicker]');
            if (datepickerElement) {
                // Get the state manager through the calendar instance or directly
                var stateManager = (_a = datepickerElement.instance) === null || _a === void 0 ? void 0 : _a._state;
                if (stateManager) {
                    var state = stateManager.getState();
                    var config = stateManager.getConfig();
                    // If we're in range mode and range selection is in progress, don't close
                    if (config.range && state.isRangeSelectionInProgress) {
                        console.log('Outside click detected but range selection in progress - keeping dropdown open');
                        return;
                    }
                }
            }
            this.close();
        }
    };
    /**
     * Set width of dropdown based on toggle element
     */
    KTDatepickerDropdown.prototype._setDropdownWidth = function () {
        if (!this._dropdownElement || !this._toggleElement)
            return;
        // Get the datepicker configuration
        var datepickerElement = this._element.closest('[data-kt-datepicker]');
        var visibleMonths = 1;
        if (datepickerElement) {
            // Get visible months from config
            var instance = datepickerElement.instance;
            if (instance && instance._config) {
                visibleMonths = instance._config.visibleMonths || 1;
            }
        }
        // Calculate appropriate width based on number of visible months
        if (visibleMonths > 1) {
            // For multiple months, calculate a fixed width per month plus padding and gaps
            var monthWidth = 280; // Fixed width for each month
            var padding = 24; // Left/right padding (p-3 = 0.75rem  2  16px = 24px)
            var spacing = 16 * (visibleMonths - 1); // Gap between months (gap-4 = 1rem  16px)
            // Limit to showing max 3 months at once for UX (user can scroll to see more)
            var visibleWidth = Math.min(visibleMonths, 3);
            var totalWidth = monthWidth * visibleWidth + spacing + padding;
            // Set fixed width for the dropdown
            this._dropdownElement.style.width = "".concat(totalWidth, "px");
            this._dropdownElement.style.minWidth = "".concat(totalWidth, "px");
        }
        else {
            // For single month, use a fixed width that works well for most calendars
            this._dropdownElement.style.width = '332px'; // 280px calendar width + 24px padding + border
            this._dropdownElement.style.minWidth = '332px';
        }
    };
    /**
     * Initialize the Popper instance for dropdown positioning
     */
    KTDatepickerDropdown.prototype._initPopper = function () {
        // Destroy existing popper instance if it exists
        this._destroyPopper();
        // Default offset
        var offsetValue = '0, 5';
        // Get configuration options
        var placement = 'bottom-start';
        var strategy = 'absolute';
        var preventOverflow = true;
        var flip = true;
        // Create new popper instance
        this._popperInstance = (0, core_1.createPopper)(this._toggleElement, this._dropdownElement, {
            placement: placement,
            strategy: strategy,
            modifiers: [
                {
                    name: 'offset',
                    options: {
                        offset: this._parseOffset(offsetValue),
                    },
                },
                {
                    name: 'preventOverflow',
                    options: {
                        boundary: 'viewport',
                        altAxis: preventOverflow,
                    },
                },
                {
                    name: 'flip',
                    options: {
                        enabled: flip,
                        fallbackPlacements: ['top-start', 'bottom-end', 'top-end'],
                    },
                },
            ],
        });
    };
    /**
     * Parse offset string into an array of numbers
     */
    KTDatepickerDropdown.prototype._parseOffset = function (offset) {
        return offset.split(',').map(function (value) { return parseInt(value.trim(), 10); });
    };
    /**
     * Destroy the Popper instance
     */
    KTDatepickerDropdown.prototype._destroyPopper = function () {
        if (this._popperInstance) {
            this._popperInstance.destroy();
            this._popperInstance = null;
        }
    };
    /**
     * Update dropdown position
     */
    KTDatepickerDropdown.prototype.updatePosition = function () {
        // Look for the display element rather than using the input directly
        var displayElement = this._element.querySelector('[data-kt-datepicker-display]');
        var triggerElement = displayElement || this._toggleElement;
        if (!triggerElement || !this._dropdownElement)
            return;
        // Reset position styles
        this._dropdownElement.style.top = '';
        this._dropdownElement.style.bottom = '';
        this._dropdownElement.style.left = '';
        this._dropdownElement.style.right = '';
        // Set width before positioning
        this._setDropdownWidth();
        // Get position information
        var triggerRect = triggerElement.getBoundingClientRect();
        var containerRect = this._element.getBoundingClientRect();
        var dropdownRect = this._dropdownElement.getBoundingClientRect();
        var viewportHeight = window.innerHeight;
        var viewportWidth = window.innerWidth;
        // Calculate available space below and above the trigger
        var spaceBelow = viewportHeight - triggerRect.bottom;
        var spaceAbove = triggerRect.top;
        // Calculate if dropdown would overflow horizontally
        var overflowRight = triggerRect.left + dropdownRect.width > viewportWidth;
        // Position dropdown
        this._dropdownElement.style.position = 'absolute';
        // Determine vertical position
        if (spaceBelow >= dropdownRect.height || spaceBelow >= spaceAbove) {
            // Position below the trigger
            this._dropdownElement.style.top = "".concat(triggerRect.height + 5, "px");
        }
        else {
            // Position above the trigger
            this._dropdownElement.style.bottom = "".concat(triggerRect.height + 5, "px");
        }
        // Determine horizontal position - handle potential overflow
        if (overflowRight) {
            // Align with right edge of trigger to prevent overflow
            var rightOffset = Math.max(0, dropdownRect.width - triggerRect.width);
            this._dropdownElement.style.right = "0px";
        }
        else {
            // Align with left edge of trigger
            this._dropdownElement.style.left = "0px";
        }
    };
    /**
     * Toggle the dropdown
     */
    KTDatepickerDropdown.prototype.toggle = function () {
        if (this._isOpen) {
            this.close();
        }
        else {
            this.open();
        }
    };
    /**
     * Open the dropdown
     */
    KTDatepickerDropdown.prototype.open = function () {
        var _this = this;
        if (this._isOpen || this._isTransitioning)
            return;
        // Fire before show event
        var beforeShowEvent = new CustomEvent('kt.datepicker.dropdown.show', {
            bubbles: true,
            cancelable: true,
        });
        this._element.dispatchEvent(beforeShowEvent);
        if (beforeShowEvent.defaultPrevented)
            return;
        // Begin opening transition
        this._isTransitioning = true;
        // Set dropdown visibility
        this._dropdownElement.classList.remove('hidden');
        this._dropdownElement.setAttribute('aria-hidden', 'false');
        // Set dropdown width
        this._setDropdownWidth();
        // Make sure the element is visible for transitioning
        dom_1.default.reflow(this._dropdownElement);
        // Apply z-index
        this._dropdownElement.style.zIndex = '1000';
        // Initialize popper for positioning
        this._initPopper();
        // Add active classes
        this._toggleElement.classList.add('ring', 'ring-blue-300');
        this._toggleElement.setAttribute('aria-expanded', 'true');
        // Start transition
        this._dropdownElement.classList.remove('opacity-0', 'translate-y-2');
        this._dropdownElement.classList.add('opacity-100', 'translate-y-0');
        // Handle transition end
        dom_1.default.transitionEnd(this._dropdownElement, function () {
            _this._isTransitioning = false;
            _this._isOpen = true;
            // Focus the first interactive element
            _this._focusFirstInteractiveElement();
            // Fire after show event
            var afterShowEvent = new CustomEvent('kt.datepicker.dropdown.shown', {
                bubbles: true,
            });
            _this._element.dispatchEvent(afterShowEvent);
        });
    };
    /**
     * Focus the first interactive element in the dropdown
     */
    KTDatepickerDropdown.prototype._focusFirstInteractiveElement = function () {
        // Priority of elements to focus:
        // 1. A "Today" button if available
        // 2. The first day in the current month
        // 3. Any other focusable element
        // Find the Today button using standard DOM selectors
        var todayBtn = null;
        var buttons = this._dropdownElement.querySelectorAll('button');
        for (var i = 0; i < buttons.length; i++) {
            if (buttons[i].textContent && buttons[i].textContent.trim() === 'Today') {
                todayBtn = buttons[i];
                break;
            }
        }
        if (todayBtn) {
            todayBtn.focus();
            return;
        }
        var currentMonthDay = this._dropdownElement.querySelector('button[data-date]:not(.text-gray-400)');
        if (currentMonthDay) {
            currentMonthDay.focus();
            return;
        }
        var firstOption = this._focusManager.getVisibleOptions()[0];
        if (firstOption) {
            this._focusManager.applyFocus(firstOption);
        }
    };
    /**
     * Close the dropdown
     */
    KTDatepickerDropdown.prototype.close = function () {
        var _this = this;
        if (!this._isOpen || this._isTransitioning)
            return;
        // Fire before hide event
        var beforeHideEvent = new CustomEvent('kt.datepicker.dropdown.hide', {
            bubbles: true,
            cancelable: true,
        });
        this._element.dispatchEvent(beforeHideEvent);
        if (beforeHideEvent.defaultPrevented)
            return;
        // Begin closing transition
        this._isTransitioning = true;
        // Start transition
        this._dropdownElement.classList.add('opacity-0', 'translate-y-2');
        this._dropdownElement.classList.remove('opacity-100', 'translate-y-0');
        // Handle transition end
        dom_1.default.transitionEnd(this._dropdownElement, function () {
            // Remove active classes
            _this._dropdownElement.classList.add('hidden');
            _this._dropdownElement.setAttribute('aria-hidden', 'true');
            // Reset styles
            _this._dropdownElement.style.opacity = '';
            _this._dropdownElement.style.transform = '';
            _this._dropdownElement.style.zIndex = '';
            // Destroy popper
            _this._destroyPopper();
            // Update state
            _this._isTransitioning = false;
            _this._isOpen = false;
            // Fire after hide event
            var afterHideEvent = new CustomEvent('kt.datepicker.dropdown.hidden', {
                bubbles: true,
            });
            _this._element.dispatchEvent(afterHideEvent);
        });
    };
    /**
     * Check if dropdown is open
     */
    KTDatepickerDropdown.prototype.isOpen = function () {
        return this._isOpen;
    };
    /**
     * Clean up component
     */
    KTDatepickerDropdown.prototype.dispose = function () {
        // Destroy popper
        this._destroyPopper();
        // Remove event listeners
        this._eventManager.removeAllListeners(this._element);
        this._eventManager.removeAllListeners(this._toggleElement);
        this._eventManager.removeAllListeners(document);
        // Clean up focus manager
        if (this._focusManager &&
            typeof this._focusManager.dispose === 'function') {
            this._focusManager.dispose();
        }
        // Clean up state
        this._isOpen = false;
        this._isTransitioning = false;
        // Remove data reference
        data_1.default.remove(this._element, this._name);
    };
    return KTDatepickerDropdown;
}(component_1.default));
exports.KTDatepickerDropdown = KTDatepickerDropdown;


/***/ }),

/***/ 8716:
/***/ (function(__unused_webpack_module, exports) {


/**
 * KTUI - Free & Open-Source Tailwind UI Components by Keenthemes
 * Copyright 2025 by Keenthemes Inc
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
var KTElementMap = new Map();
var KTData = {
    set: function (element, key, value) {
        if (!KTElementMap.has(element)) {
            KTElementMap.set(element, new Map());
        }
        var valueMap = KTElementMap.get(element);
        valueMap.set(key, value);
    },
    get: function (element, key) {
        if (KTElementMap.has(element)) {
            return KTElementMap.get(element).get(key) || null;
        }
        return null;
    },
    has: function (element, key) {
        return KTElementMap.has(element) && KTElementMap.get(element).has(key);
    },
    remove: function (element, key) {
        if (!KTElementMap.has(element) || !KTElementMap.get(element).has(key)) {
            return;
        }
        var valueMap = KTElementMap.get(element);
        valueMap.delete(key);
        if (valueMap.size === 0) {
            KTElementMap.delete(element);
        }
    },
};
exports["default"] = KTData;


/***/ }),

/***/ 8797:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


/**
 * KTUI - Free & Open-Source Tailwind UI Components by Keenthemes
 * Copyright 2025 by Keenthemes Inc
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.KTSelectTags = void 0;
var templates_1 = __webpack_require__(9069);
var utils_1 = __webpack_require__(9011);
/**
 * KTSelectTags - Handles tags-specific functionality for KTSelect
 */
var KTSelectTags = /** @class */ (function () {
    /**
     * Constructor: Initializes the tags component
     */
    function KTSelectTags(select) {
        this._select = select;
        this._config = select.getConfig();
        this._valueDisplayElement = select.getValueDisplayElement();
        this._eventManager = new utils_1.EventManager();
        if (this._config.debug)
            console.log('KTSelectTags initialized');
    }
    /**
     * Update selected tags display
     * Renders selected options as tags in the display element
     */
    KTSelectTags.prototype.updateTagsDisplay = function (selectedOptions) {
        var _this = this;
        // Remove any existing tag elements
        var wrapper = this._valueDisplayElement.parentElement;
        if (!wrapper)
            return;
        // Remove all previous tags
        Array.from(wrapper.querySelectorAll('[data-kt-select-tag]')).forEach(function (tag) { return tag.remove(); });
        // If no options selected, do nothing (let display show placeholder)
        if (selectedOptions.length === 0) {
            return;
        }
        // Insert each tag before the display element
        selectedOptions.forEach(function (optionValue) {
            // Find the original option element (in dropdown or select)
            var optionElement = null;
            var optionElements = _this._select.getOptionsElement();
            for (var _i = 0, _a = Array.from(optionElements); _i < _a.length; _i++) {
                var opt = _a[_i];
                if (opt.dataset.value === optionValue) {
                    optionElement = opt;
                    break;
                }
            }
            if (!optionElement) {
                var originalOptions = _this._select.getElement().querySelectorAll('option');
                for (var _b = 0, _c = Array.from(originalOptions); _b < _c.length; _b++) {
                    var opt = _c[_b];
                    if (opt.value === optionValue) {
                        optionElement = opt;
                        break;
                    }
                }
            }
            var tag = templates_1.defaultTemplates.tag(optionElement, _this._config);
            // Add event listener to the close button
            var closeButton = tag.querySelector('[data-kt-select-remove-button]');
            if (closeButton) {
                _this._eventManager.addListener(closeButton, 'click', function (event) {
                    event.stopPropagation();
                    _this._removeTag(optionValue);
                });
            }
            // Insert tag before the display element
            wrapper.insertBefore(tag, _this._valueDisplayElement);
        });
    };
    /**
     * Remove a tag and its selection
     */
    KTSelectTags.prototype._removeTag = function (optionValue) {
        // Delegate to the select component to handle state changes
        this._select.toggleSelection(optionValue);
    };
    /**
     * Clean up resources used by this module
     */
    KTSelectTags.prototype.destroy = function () {
        this._eventManager.removeAllListeners(null);
    };
    return KTSelectTags;
}());
exports.KTSelectTags = KTSelectTags;


/***/ }),

/***/ 8834:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


/**
 * KTUI - Free & Open-Source Tailwind UI Components by Keenthemes
 * Copyright 2025 by Keenthemes Inc
 */
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.KTToast = void 0;
var component_1 = __webpack_require__(2658);
var data_1 = __webpack_require__(8716);
var DEFAULT_CONFIG = {
    position: 'top-end',
    duration: 4000,
    className: '',
    maxToasts: 5,
    offset: 15,
    gap: 10,
};
var DEFAULT_TOAST_OPTIONS = {
    appearance: 'solid',
    progress: false,
    size: 'md',
    action: false,
    cancel: false,
    dismiss: true,
};
var KTToast = /** @class */ (function (_super) {
    __extends(KTToast, _super);
    /**
     * Creates a new KTToast instance for a specific element (not commonly used; most use static API).
     * @param element The target HTML element.
     * @param config Optional toast config for this instance.
     */
    function KTToast(element, config) {
        var _this = _super.call(this) || this;
        _this._name = 'toast';
        _this._defaultConfig = DEFAULT_CONFIG;
        _this._config = DEFAULT_CONFIG;
        _this._defaultToastOptions = DEFAULT_TOAST_OPTIONS;
        if (data_1.default.has(element, _this._name))
            return _this;
        _this._init(element);
        _this._buildConfig(config);
        data_1.default.set(element, _this._name, _this);
        return _this;
    }
    /**
     * Generates the HTML content for a toast based on the provided options.
     * @param options Toast options (message, icon, actions, etc).
     * @returns The toast's HTML markup as a string.
     */
    KTToast.getContent = function (options) {
        var classNames = __assign(__assign({}, (this.globalConfig.classNames || {})), ((options === null || options === void 0 ? void 0 : options.classNames) || {}));
        if (options === null || options === void 0 ? void 0 : options.content) {
            if (typeof options.content === 'string') {
                return options.content;
            }
            else if (typeof options.content === 'function') {
                var node = options.content();
                if (node instanceof HTMLElement) {
                    return node.outerHTML;
                }
            }
            else if (options.content instanceof HTMLElement) {
                return options.content.outerHTML;
            }
        }
        var template = '';
        if (options === null || options === void 0 ? void 0 : options.icon) {
            template +=
                '<div class="kt-alert-icon ' +
                    (classNames.icon || '') +
                    '">' +
                    options.icon +
                    '</div>';
        }
        if (options === null || options === void 0 ? void 0 : options.message) {
            template +=
                '<div class="kt-alert-title ' +
                    (classNames.message || '') +
                    '">' +
                    options.message +
                    '</div>';
        }
        if ((options === null || options === void 0 ? void 0 : options.action) !== false ||
            (options === null || options === void 0 ? void 0 : options.dismiss) !== false ||
            (options === null || options === void 0 ? void 0 : options.cancel) !== false) {
            template +=
                '<div class="kt-alert-toolbar ' + (classNames.toolbar || '') + '">';
            template +=
                '<div class="kt-alert-actions ' + (classNames.actions || '') + '">';
            if ((options === null || options === void 0 ? void 0 : options.action) && typeof options.action === 'object') {
                template +=
                    '<button data-kt-toast-action="true" class="' +
                        (options.action.className || '') +
                        '">' +
                        options.action.label +
                        '</button>';
            }
            if ((options === null || options === void 0 ? void 0 : options.cancel) && typeof options.cancel === 'object') {
                template +=
                    '<button data-kt-toast-cancel="true" class="' +
                        (options.cancel.className || '') +
                        '">' +
                        options.cancel.label +
                        '</button>';
            }
            if ((options === null || options === void 0 ? void 0 : options.dismiss) !== false) {
                template +=
                    '<button data-kt-toast-dismiss="true" class="kt-alert-close"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M18 6 6 18"/><path d="m6 6 12 12"/></svg></button>';
            }
            template += '</div>';
            template += '</div>';
        }
        template += '</div>';
        return template;
    };
    /**
     * Update all toasts in the container with smooth animation.
     *
     * @param container The toast container element.
     * @param offset Optional offset from the edge.
     */
    KTToast.update = function (container, offset) {
        var _this = this;
        var _a;
        if (!container)
            return;
        offset =
            typeof offset === 'number' ? offset : ((_a = this.globalConfig.offset) !== null && _a !== void 0 ? _a : 15);
        requestAnimationFrame(function () {
            var _a;
            var gap = (_a = _this.globalConfig.gap) !== null && _a !== void 0 ? _a : 8;
            // Group toasts by alignment (top/bottom)
            var positionGroups = {
                top: [],
                bottom: [],
            };
            var toasts = Array.from(container.children);
            toasts.forEach(function (toast) {
                if (toast.classList.contains('kt-toast-top-end') ||
                    toast.classList.contains('kt-toast-top-center') ||
                    toast.classList.contains('kt-toast-top-start')) {
                    positionGroups.top.push(toast);
                }
                else {
                    positionGroups.bottom.push(toast);
                }
            });
            // Stack top toasts from the top down
            var currentOffset = offset;
            positionGroups.top.forEach(function (toast) {
                toast.style.top = "".concat(currentOffset, "px");
                toast.style.bottom = '';
                toast.style.transition =
                    'top 0.28s cubic-bezier(.4,0,.2,1), opacity 0.28s cubic-bezier(.4,0,.2,1)';
                currentOffset += toast.offsetHeight + gap;
                if (toast.classList.contains('kt-toast-top-start')) {
                    toast.style.insetInlineStart = "".concat(offset, "px");
                }
                if (toast.classList.contains('kt-toast-top-end')) {
                    toast.style.insetInlineEnd = "".concat(offset, "px");
                }
            });
            // Stack bottom toasts from the bottom up
            currentOffset = offset;
            for (var i = positionGroups.bottom.length - 1; i >= 0; i--) {
                var toast = positionGroups.bottom[i];
                toast.style.bottom = "".concat(currentOffset, "px");
                toast.style.top = '';
                toast.style.transition =
                    'bottom 0.28s cubic-bezier(.4,0,.2,1), opacity 0.28s cubic-bezier(.4,0,.2,1)';
                currentOffset += toast.offsetHeight + gap;
                if (toast.classList.contains('kt-toast-bottom-start')) {
                    toast.style.insetInlineStart = "".concat(offset, "px");
                }
                if (toast.classList.contains('kt-toast-bottom-end')) {
                    toast.style.insetInlineEnd = "".concat(offset, "px");
                }
            }
        });
    };
    /**
     * Set global toast configuration options.
     * @param options Partial toast config to merge with global config.
     */
    KTToast.config = function (options) {
        this.globalConfig = __assign(__assign({}, this.globalConfig), options);
    };
    /**
     * Show a toast notification.
     * @param inputOptions Toast options (message, duration, variant, etc).
     * @returns Toast instance with dismiss method, or undefined if invalid input.
     */
    KTToast.show = function (inputOptions) {
        var _a, _b, _c, _d;
        var options = __assign(__assign({}, DEFAULT_TOAST_OPTIONS), inputOptions);
        if (!options || (!options.message && !options.content)) {
            return undefined;
        }
        // Always resolve the id once and use it everywhere
        var id = "kt-toast-".concat(Date.now(), "-").concat(Math.random().toString(36).slice(2, 8));
        var position = options.position || this.globalConfig.position || 'top-end';
        var classNames = __assign(__assign({}, (this.globalConfig.classNames || {})), (options.classNames || {}));
        var container = this.containerMap.get(position);
        if (!container) {
            container = document.createElement('div');
            var classNames_1 = __assign(__assign({}, (this.globalConfig.classNames || {})), (options.classNames || {}));
            // Fallback to default hardcoded classes if not provided in options or globalConfig
            container.className =
                classNames_1.container || "kt-toast-container ".concat(position);
            document.body.appendChild(container);
            this.containerMap.set(position, container);
        }
        // Enforce maxToasts
        if (container.children.length >=
            (this.globalConfig.maxToasts || DEFAULT_CONFIG.maxToasts)) {
            var firstToast_1 = container.firstElementChild;
            if (firstToast_1) {
                firstToast_1.classList.add('kt-toast-closing');
                firstToast_1.addEventListener('animationend', function () {
                    firstToast_1.remove();
                });
            }
        }
        // Create toast element
        var variantMap = {
            info: 'kt-alert-info',
            success: 'kt-alert-success',
            error: 'kt-alert-error',
            warning: 'kt-alert-warning',
            primary: 'kt-alert-primary',
            secondary: 'kt-alert-secondary',
            destructive: 'kt-alert-destructive',
            mono: 'kt-alert-mono',
        };
        var appearanceMap = {
            solid: 'kt-alert-solid',
            outline: 'kt-alert-outline',
            light: 'kt-alert-light',
        };
        var sizeMap = {
            sm: 'kt-alert-sm',
            md: 'kt-alert-md',
            lg: 'kt-alert-lg',
        };
        var toast = document.createElement('div');
        toast.className = "kt-toast kt-alert ".concat(variantMap[options.variant] || '', " ").concat(appearanceMap[options.appearance] || '', " ").concat(sizeMap[options.size] || '', " ").concat(options.className || '', " ").concat(classNames.toast || '');
        // ARIA support
        toast.setAttribute('role', options.role || 'status');
        toast.setAttribute('aria-live', 'polite');
        toast.setAttribute('aria-atomic', 'true');
        toast.setAttribute('tabindex', '0');
        // Always resolve the id once and use it everywhere
        // Always resolve id ONCE at the top, use everywhere
        // (Move this up to replace the previous const id = ... assignment)
        // Populate content via getContent
        var contentHtml = KTToast.getContent(options);
        toast.innerHTML = contentHtml;
        // Assign event handlers to buttons by data attribute
        var actionBtn = toast.querySelector('[data-kt-toast-action]');
        if (actionBtn &&
            options.action &&
            typeof options.action === 'object' &&
            options.action.onClick) {
            actionBtn.addEventListener('click', function (e) {
                e.stopPropagation();
                if (typeof options.action === 'object' && options.action.onClick) {
                    options.action.onClick(id);
                    KTToast.close(id);
                }
            });
        }
        var cancelBtn = toast.querySelector('[data-kt-toast-cancel]');
        if (cancelBtn && options.cancel && typeof options.cancel === 'object') {
            cancelBtn.addEventListener('click', function (e) {
                e.stopPropagation();
                if (typeof options.cancel === 'object' && options.cancel.onClick) {
                    options.cancel.onClick(id);
                    KTToast.close(id);
                }
            });
        }
        // Dismiss button handler
        var dismissBtn = toast.querySelector('[data-kt-toast-dismiss]');
        if (dismissBtn && options.dismiss !== false) {
            dismissBtn.addEventListener('click', function (e) {
                e.stopPropagation();
                KTToast.close(id);
            });
        }
        // If modal-like, set aria-modal
        if (options.important)
            toast.setAttribute('aria-modal', 'true');
        toast.style.pointerEvents = 'auto';
        // Progress line
        var duration = options.important
            ? null
            : ((_b = (_a = options.duration) !== null && _a !== void 0 ? _a : this.globalConfig.duration) !== null && _b !== void 0 ? _b : DEFAULT_CONFIG.duration);
        if (duration && options.progress) {
            var progress = document.createElement('div');
            progress.className = 'kt-toast-progress ' + (classNames.progress || '');
            progress.style.animationDuration = duration + 'ms';
            progress.setAttribute('data-kt-toast-progress', 'true');
            toast.appendChild(progress);
        }
        // Assign direction class to the toast itself, not the container
        var directionClassMap = {
            'top-end': 'kt-toast-top-end',
            'top-center': 'kt-toast-top-center',
            'top-start': 'kt-toast-top-start',
            'bottom-end': 'kt-toast-bottom-end',
            'bottom-center': 'kt-toast-bottom-center',
            'bottom-start': 'kt-toast-bottom-start',
        };
        Object.values(directionClassMap).forEach(function (cls) {
            return toast.classList.remove(cls);
        });
        var dirClass = directionClassMap[position] || 'kt-toast-top-end';
        toast.classList.add(dirClass);
        // Enforce maxToasts: remove oldest if needed
        var maxToasts = (_d = (_c = options.maxToasts) !== null && _c !== void 0 ? _c : this.globalConfig.maxToasts) !== null && _d !== void 0 ? _d : DEFAULT_CONFIG.maxToasts;
        var currentToasts = Array.from(container.children);
        if (currentToasts.length >= maxToasts && currentToasts.length > 0) {
            var oldestToast = currentToasts[currentToasts.length - 1];
            var oldestId = oldestToast.getAttribute('data-kt-toast-id');
            if (oldestId) {
                KTToast.close(oldestId);
            }
            else {
                oldestToast.remove();
            }
        }
        // Insert toast at the top
        container.insertBefore(toast, container.firstChild);
        KTToast.update(container);
        // Play beep if requested
        if (options.beep) {
            try {
                // Use Web Audio API for a short beep
                var ctx_1 = new (window.AudioContext ||
                    window.webkitAudioContext)();
                var o_1 = ctx_1.createOscillator();
                var g = ctx_1.createGain();
                o_1.type = 'sine';
                o_1.frequency.value = 880;
                g.gain.value = 0.09;
                o_1.connect(g);
                g.connect(ctx_1.destination);
                o_1.start();
                setTimeout(function () {
                    o_1.stop();
                    ctx_1.close();
                }, 120);
            }
            catch (e) {
                /* ignore */
            }
        }
        KTToast._fireEventOnElement(toast, 'show', { id: id });
        KTToast._dispatchEventOnElement(toast, 'show', { id: id });
        var instance = { id: id, element: toast, timeoutId: 0 };
        KTToast.toasts.set(id, instance);
        // Auto-dismiss
        var timeoutId = undefined;
        var remaining = duration;
        var startTime;
        var paused = false;
        var progressEl = null;
        if (duration) {
            var startTimer_1 = function (ms) {
                startTime = Date.now();
                timeoutId = window.setTimeout(function () {
                    var _a;
                    (_a = options.onAutoClose) === null || _a === void 0 ? void 0 : _a.call(options, id);
                    KTToast.close(id);
                }, ms);
                instance.timeoutId = timeoutId;
            };
            startTimer_1(duration);
            if (options.pauseOnHover) {
                progressEl = toast.querySelector('[data-kt-toast-progress]');
                var progressPausedAt_1 = 0;
                var pause = function () {
                    if (!paused && timeoutId) {
                        paused = true;
                        window.clearTimeout(timeoutId);
                        if (startTime) {
                            remaining -= Date.now() - startTime;
                        }
                        // Pause progress bar
                        if (progressEl) {
                            var computedStyle = window.getComputedStyle(progressEl);
                            var matrix = computedStyle.transform;
                            var scaleX = 1;
                            if (matrix && matrix !== 'none') {
                                var values = matrix.match(/matrix\(([^)]+)\)/);
                                if (values && values[1]) {
                                    scaleX = parseFloat(values[1].split(',')[0]);
                                }
                            }
                            progressPausedAt_1 = scaleX;
                            progressEl.style.animation = 'none';
                            progressEl.style.transition = 'none';
                            progressEl.style.transform = "scaleX(".concat(scaleX, ")");
                        }
                    }
                };
                var resume = function () {
                    if (paused && remaining > 0) {
                        paused = false;
                        startTimer_1(remaining);
                        // Resume progress bar
                        if (progressEl) {
                            progressEl.style.transition = 'transform 0ms';
                            progressEl.style.transform = "scaleX(".concat(progressPausedAt_1, ")");
                            progressEl.offsetHeight; // force reflow
                            progressEl.style.transition = "transform ".concat(remaining, "ms linear");
                            progressEl.style.transform = 'scaleX(0)';
                        }
                    }
                };
                toast.addEventListener('mouseenter', pause);
                toast.addEventListener('mouseleave', resume);
            }
        }
        KTToast._fireEventOnElement(toast, 'shown', { id: id });
        KTToast._dispatchEventOnElement(toast, 'shown', { id: id });
        return __assign(__assign({}, instance), { dismiss: function () { return KTToast.close(id); } });
    };
    /**
     * Close and remove all active toasts.
     */
    KTToast.clearAll = function (clearContainers) {
        if (clearContainers === void 0) { clearContainers = false; }
        for (var _i = 0, _a = Array.from(this.toasts.keys()); _i < _a.length; _i++) {
            var id = _a[_i];
            console.log('clearAll:', id);
            this.close(id);
        }
        if (clearContainers) {
            // Remove all containers from the DOM.
            this.containerMap.forEach(function (container, position) {
                container.remove();
                console.log('clearAll: removed container for position', position);
            });
            // Clear containerMap to prevent stale references.
            this.containerMap.clear();
        }
    };
    /**
     * Close a toast by ID or instance.
     * @param idOrInstance Toast ID string or KTToastInstance.
     */
    KTToast.close = function (idOrInstance) {
        var inst;
        var id;
        if (!idOrInstance)
            return;
        if (typeof idOrInstance === 'string') {
            id = idOrInstance;
            inst = this.toasts.get(id);
        }
        else if (typeof idOrInstance === 'object' && idOrInstance.id) {
            id = idOrInstance.id;
            inst = idOrInstance;
        }
        if (!inst || !id)
            return;
        if (inst._closing)
            return; // Prevent double-close
        inst._closing = true;
        clearTimeout(inst.timeoutId);
        KTToast._fireEventOnElement(inst.element, 'hide', { id: id });
        KTToast._dispatchEventOnElement(inst.element, 'hide', { id: id });
        // Remove progress bar instantly if present
        var progressEl = inst.element.querySelector('[data-kt-toast-progress]');
        if (progressEl)
            progressEl.remove();
        inst.element.style.animation = 'kt-toast-out 0.25s forwards';
        setTimeout(function () {
            var _a;
            var parent = inst === null || inst === void 0 ? void 0 : inst.element.parentElement;
            inst === null || inst === void 0 ? void 0 : inst.element.remove();
            KTToast.toasts.delete(id);
            // Try to call onDismiss if available in the toast instance (if stored)
            if (typeof ((_a = inst.options) === null || _a === void 0 ? void 0 : _a.onDismiss) === 'function') {
                inst.options.onDismiss(id);
            }
            KTToast._fireEventOnElement(inst.element, 'hidden', { id: id });
            KTToast._dispatchEventOnElement(inst.element, 'hidden', { id: id });
            // update toasts asynchronously after DOM update
            setTimeout(function () {
                KTToast.update(parent);
            }, 0);
        }, 250);
    };
    /**
     * Dispatches a custom 'kt.toast.{eventType}' event on the given element.
     * @param element The toast element.
     * @param eventType The event type (e.g. 'show', 'hide').
     * @param payload Optional event detail payload.
     */
    KTToast._fireEventOnElement = function (element, eventType, payload) {
        var event = new CustomEvent("kt.toast.".concat(eventType), { detail: payload });
        element.dispatchEvent(event);
    };
    /**
     * Dispatches a custom event (not namespaced) on the given element.
     * @param element The toast element.
     * @param eventType The event type.
     * @param payload Optional event detail payload.
     */
    KTToast._dispatchEventOnElement = function (element, eventType, payload) {
        var event = new CustomEvent(eventType, { detail: payload });
        element.dispatchEvent(event);
    };
    /**
     * Initialize toast system (placeholder for future use).
     */
    KTToast.init = function () { };
    KTToast.containerMap = new Map();
    KTToast.toasts = new Map();
    KTToast.globalConfig = __assign({}, DEFAULT_CONFIG);
    return KTToast;
}(component_1.default));
exports.KTToast = KTToast;


/***/ }),

/***/ 9010:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


/**
 * KTUI - Free & Open-Source Tailwind UI Components by Keenthemes
 * Copyright 2025 by Keenthemes Inc
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
/* eslint-disable max-len */
var utils_1 = __webpack_require__(2599);
var KTDom = {
    isRTL: function () {
        var htmlTag = document.documentElement; // Access the <html> tag
        // Check if the "dir" attribute is present and its value is "rtl"
        var dir = htmlTag.getAttribute('dir');
        return dir === 'rtl';
    },
    isElement: function (element) {
        if (element && element instanceof HTMLElement) {
            return true;
        }
        else {
            return false;
        }
    },
    getElement: function (element) {
        if (this.isElement(element)) {
            return element;
        }
        if (element && element.length > 0) {
            return document.querySelector(utils_1.default.parseSelector(element));
        }
        return null;
    },
    remove: function (element) {
        if (this.isElement(element) && element.parentNode) {
            element.parentNode.removeChild(element);
        }
    },
    hasClass: function (element, className) {
        // Split classNames string into an array of individual class names
        var classes = className.split(' ');
        // Loop through each class name
        for (var _i = 0, classes_1 = classes; _i < classes_1.length; _i++) {
            var className_1 = classes_1[_i];
            // Check if the element has the current class name
            if (!element.classList.contains(className_1)) {
                // Return false if any class is missing
                return false;
            }
        }
        // Return true if all classes are present
        return true;
    },
    addClass: function (element, className) {
        var classNames = className.split(' ');
        if (element.classList) {
            for (var i = 0; i < classNames.length; i++) {
                if (classNames[i] && classNames[i].length > 0) {
                    element.classList.add(classNames[i].trim());
                }
            }
        }
        else if (!this.hasClass(element, className)) {
            for (var x = 0; x < classNames.length; x++) {
                element.className += ' ' + classNames[x].trim();
            }
        }
    },
    removeClass: function (element, className) {
        var classNames = className.split(' ');
        if (element.classList) {
            for (var i = 0; i < classNames.length; i++) {
                element.classList.remove(classNames[i].trim());
            }
        }
        else if (this.hasClass(element, className)) {
            for (var x = 0; x < classNames.length; x++) {
                element.className = element.className.replace(new RegExp('\\b' + classNames[x].trim() + '\\b', 'g'), '');
            }
        }
    },
    getCssProp: function (element, prop) {
        return (element ? window.getComputedStyle(element).getPropertyValue(prop) : '').replace(' ', '');
    },
    setCssProp: function (element, prop, value) {
        if (element) {
            window.getComputedStyle(element).setProperty(prop, value);
        }
    },
    offset: function (element) {
        if (!element)
            return { top: 0, left: 0, right: 0, bottom: 0 };
        var rect = element.getBoundingClientRect();
        return {
            top: rect.top,
            left: rect.left,
            right: window.innerWidth - rect.right,
            bottom: window.innerHeight - rect.top,
        };
    },
    getIndex: function (element) {
        var _a;
        var children = Array.from(((_a = element.parentNode) === null || _a === void 0 ? void 0 : _a.children) || []);
        return children.indexOf(element);
    },
    parents: function (element, selector) {
        var parents = [];
        // Push each parent element to the array
        for (element && element !== document.documentElement; (element = element.parentElement);) {
            if (selector) {
                if (element.matches(selector)) {
                    parents.push(element);
                }
                continue;
            }
            parents.push(element);
        }
        // Return our parent array
        return parents;
    },
    siblings: function (element) {
        var parent = element.parentNode;
        if (!parent)
            return [];
        return Array.from(parent.children).filter(function (child) { return child !== element; });
    },
    children: function (element, selector) {
        if (!element || !element.childNodes) {
            return null;
        }
        var result = [];
        var l = element.childNodes.length;
        var i = 0;
        for (i = 0; i < l; i++) {
            if (element.childNodes[i].nodeType == 1 &&
                element.childNodes[i].matches(selector)) {
                result.push(element.childNodes[i]);
            }
        }
        return result;
    },
    child: function (element, selector) {
        var children = KTDom.children(element, selector);
        return children ? children[0] : null;
    },
    isVisible: function (element) {
        if (!this.isElement(element) || element.getClientRects().length === 0) {
            return false;
        }
        // eslint-disable-next-line max-len
        return (getComputedStyle(element).getPropertyValue('visibility') === 'visible');
    },
    isDisabled: function (element) {
        if (!element || element.nodeType !== Node.ELEMENT_NODE) {
            return true;
        }
        if (element.classList.contains('disabled')) {
            return true;
        }
        if (typeof element.disabled !== 'undefined') {
            return element.disabled;
        }
        return (element.hasAttribute('disabled') &&
            element.getAttribute('disabled') !== 'false');
    },
    transitionEnd: function (element, callback) {
        var duration = this.getCSSTransitionDuration(element);
        setTimeout(function () {
            callback();
        }, duration);
    },
    animationEnd: function (element, callback) {
        var duration = this.getCSSAnimationDuration(element);
        setTimeout(function () {
            callback();
        }, duration);
    },
    getCSSTransitionDuration: function (element) {
        return (parseFloat(window.getComputedStyle(element).transitionDuration) * 1000);
    },
    getCSSAnimationDuration: function (element) {
        return (parseFloat(window.getComputedStyle(element).animationDuration) * 1000);
    },
    reflow: function (element) {
        element.offsetHeight;
    },
    insertAfter: function (element, referenceNode) {
        var parentNode = referenceNode.parentNode;
        if (parentNode) {
            parentNode.insertBefore(element, referenceNode.nextSibling);
        }
    },
    getHighestZindex: function (element) {
        var position, value;
        while (element && element !== document.documentElement) {
            // Ignore z-index if position is set to a value where z-index is ignored by the browser
            // This makes behavior of this function consistent across browsers
            // WebKit always returns auto if the element is positioned
            position = element.style.position;
            if (position === 'absolute' ||
                position === 'relative' ||
                position === 'fixed') {
                // IE returns 0 when zIndex is not specified
                // other browsers return a string
                // we ignore the case of nested elements with an explicit value of 0
                // <div style="z-index: -10;"><div style="z-index: 0;"></div></div>
                value = parseInt(element.style.zIndex);
                if (!isNaN(value) && value !== 0) {
                    return value;
                }
            }
            element = element.parentNode;
        }
        return 1;
    },
    isParentOrElementHidden: function (element) {
        if (!element) {
            return false;
        }
        var computedStyle = window.getComputedStyle(element);
        if (computedStyle.display === 'none') {
            return true;
        }
        return this.isParentOrElementHidden(element.parentElement);
    },
    getViewPort: function () {
        return {
            width: window.innerWidth,
            height: window.innerHeight,
        };
    },
    getScrollTop: function () {
        return (document.scrollingElement || document.documentElement).scrollTop;
    },
    isInViewport: function (element) {
        var rect = element.getBoundingClientRect();
        return (rect.top >= 0 &&
            rect.left >= 0 &&
            rect.bottom <=
                (window.innerHeight || document.documentElement.clientHeight) &&
            rect.right <= (window.innerWidth || document.documentElement.clientWidth));
    },
    isPartiallyInViewport: function (element) {
        var x = element.getBoundingClientRect().left;
        var y = element.getBoundingClientRect().top;
        var ww = Math.max(document.documentElement.clientWidth, window.innerWidth || 0);
        var hw = Math.max(document.documentElement.clientHeight, window.innerHeight || 0);
        var w = element.clientWidth;
        var h = element.clientHeight;
        return y < hw && y + h > 0 && x < ww && x + w > 0;
    },
    isVisibleInParent: function (child, parent) {
        var childRect = child.getBoundingClientRect();
        var parentRect = parent.getBoundingClientRect();
        // Check if the child element is visible
        if (child.offsetParent === null ||
            getComputedStyle(child).visibility === 'hidden' ||
            getComputedStyle(child).display === 'none') {
            return false;
        }
        // Check if the child is within the vertical bounds of the parent
        var isVisibleVertically = childRect.top >= parentRect.top && childRect.bottom <= parentRect.bottom;
        // Check if the child is within the horizontal bounds of the parent
        var isVisibleHorizontally = childRect.left >= parentRect.left && childRect.right <= parentRect.right;
        return isVisibleVertically && isVisibleHorizontally;
    },
    getRelativeTopPosition: function (child, parent) {
        var childRect = child.getBoundingClientRect();
        var parentRect = parent.getBoundingClientRect();
        // Calculate the relative top position
        var relativeTop = childRect.top - parentRect.top;
        return relativeTop;
    },
    getDataAttributes: function (element, prefix) {
        if (!element) {
            return {};
        }
        prefix = utils_1.default.camelCase(prefix);
        var attributes = {};
        var keys = Object.keys(element.dataset).filter(function (key) {
            return key.startsWith(prefix);
        });
        for (var _i = 0, keys_1 = keys; _i < keys_1.length; _i++) {
            var key = keys_1[_i];
            var normalizedKey = key.replace(prefix, '');
            normalizedKey = utils_1.default.uncapitalize(normalizedKey);
            attributes[normalizedKey] = utils_1.default.parseDataAttribute(element.dataset[key]);
        }
        return attributes;
    },
    ready: function (callback) {
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', function () {
                callback();
            });
        }
        else {
            callback();
        }
    },
};
exports["default"] = KTDom;


/***/ }),

/***/ 9011:
/***/ (function(__unused_webpack_module, exports) {


/**
 * KTUI - Free & Open-Source Tailwind UI Components by Keenthemes
 * Copyright 2025 by Keenthemes Inc
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TypeToSearchBuffer = exports.EventManager = exports.FocusManager = void 0;
exports.formatCurrency = formatCurrency;
exports.filterOptions = filterOptions;
exports.debounce = debounce;
exports.renderTemplateString = renderTemplateString;
exports.stringToElement = stringToElement;
/**
 * Format a number as a currency string
 */
function formatCurrency(value) {
    return new Intl.NumberFormat('en-US', {
        style: 'currency',
        currency: 'USD',
    }).format(value);
}
/**
 * Filter options based on a search query
 */
function filterOptions(options, query, config, dropdownElement, onVisibleCount) {
    var visibleOptionsCount = 0;
    // For empty query, make all options visible
    // The KTSelectSearch class is now responsible for restoring original content before calling this.
    if (!query || query.trim() === '') {
        for (var _i = 0, options_1 = options; _i < options_1.length; _i++) {
            var option = options_1[_i];
            option.classList.remove('hidden');
            // Remove inline display style if it was used to hide
            if (option.style.display === 'none') {
                option.style.display = '';
            }
            // At this point, option.innerHTML should be its original.
            visibleOptionsCount++;
        }
        if (onVisibleCount) {
            onVisibleCount(visibleOptionsCount);
        }
        return visibleOptionsCount;
    }
    var queryLower = query.toLowerCase();
    for (var _a = 0, options_2 = options; _a < options_2.length; _a++) {
        var option = options_2[_a];
        // Use data-text for matching if available, otherwise fall back to textContent
        var optionText = (option.dataset.text || option.textContent || '').toLowerCase();
        var isMatch = optionText.includes(queryLower);
        if (isMatch) {
            option.classList.remove('hidden');
            if (option.style.display === 'none')
                option.style.display = ''; // Ensure visible
            visibleOptionsCount++;
        }
        else {
            option.classList.add('hidden');
        }
        // Early exit if maxItems limit is reached (optional)
        // if (config.searchMaxItems && visibleOptionsCount >= config.searchMaxItems) {
        // 	break;
        // }
    }
    if (onVisibleCount) {
        onVisibleCount(visibleOptionsCount);
    }
    return visibleOptionsCount;
}
/**
 * Focus manager for keyboard navigation
 * Consolidates redundant focus management logic into shared functions
 */
var FocusManager = /** @class */ (function () {
    function FocusManager(element, optionsSelector, config) {
        if (optionsSelector === void 0) { optionsSelector = '[data-kt-select-option]'; }
        this._focusedOptionIndex = null;
        this._onFocusChange = null;
        this._element = element;
        this._optionsSelector = optionsSelector;
        this._eventManager = new EventManager();
        // Add click handler to update focus state when options are clicked
        this._setupOptionClickHandlers();
        this._focusClass = 'focus'; // or whatever your intended class is
        this._hoverClass = 'hover'; // or your intended class
    }
    /**
     * Set up click handlers for all options to update focus state
     */
    FocusManager.prototype._setupOptionClickHandlers = function () {
        var _this = this;
        // Add click handler to the options container
        this._eventManager.addListener(this._element, 'click', function (e) {
            var target = e.target;
            var optionElement = target.closest(_this._optionsSelector);
            if (optionElement) {
            }
        });
    };
    /**
     * Get all visible options
     */
    FocusManager.prototype.getVisibleOptions = function () {
        return Array.from(this._element.querySelectorAll(this._optionsSelector)).filter(function (option) {
            var element = option;
            // Check only for hidden class
            if (element.classList.contains('hidden')) {
                return false;
            }
            // Also check inline styles for backward compatibility
            if (element.style.display === 'none') {
                return false;
            }
            return true;
        });
    };
    /**
     * Focus the first visible option
     */
    FocusManager.prototype.focusFirst = function () {
        var options = this.getVisibleOptions();
        if (options.length === 0)
            return null;
        for (var i = 0; i < options.length; i++) {
            var option = options[i];
            if (!option.classList.contains('disabled') && option.getAttribute('aria-disabled') !== 'true') {
                this.resetFocus();
                this._focusedOptionIndex = i;
                this.applyFocus(option);
                this.scrollIntoView(option);
                return option;
            }
        }
        return null;
    };
    /**
     * Focus the last visible option
     */
    FocusManager.prototype.focusLast = function () {
        var options = this.getVisibleOptions();
        if (options.length === 0)
            return null;
        for (var i = options.length - 1; i >= 0; i--) {
            var option = options[i];
            if (!option.classList.contains('disabled') && option.getAttribute('aria-disabled') !== 'true') {
                this.resetFocus();
                this._focusedOptionIndex = i;
                this.applyFocus(option);
                this.scrollIntoView(option);
                return option;
            }
        }
        return null;
    };
    /**
     * Focus the next visible option that matches the search string
     */
    FocusManager.prototype.focusByString = function (str) {
        var _a, _b, _c;
        var options = this.getVisibleOptions();
        if (options.length === 0)
            return null;
        var lowerStr = str.toLowerCase();
        var startIdx = ((_a = this._focusedOptionIndex) !== null && _a !== void 0 ? _a : -1) + 1;
        for (var i = 0; i < options.length; i++) {
            var idx = (startIdx + i) % options.length;
            var option = options[idx];
            if (!option.classList.contains('disabled') &&
                option.getAttribute('aria-disabled') !== 'true' &&
                (((_b = option.textContent) === null || _b === void 0 ? void 0 : _b.toLowerCase().startsWith(lowerStr)) || ((_c = option.dataset.value) === null || _c === void 0 ? void 0 : _c.toLowerCase().startsWith(lowerStr)))) {
                this.resetFocus();
                this._focusedOptionIndex = idx;
                this.applyFocus(option);
                this.scrollIntoView(option);
                return option;
            }
        }
        return null;
    };
    /**
     * Focus the next visible option
     */
    FocusManager.prototype.focusNext = function () {
        var options = this.getVisibleOptions();
        if (options.length === 0)
            return null;
        var idx = this._focusedOptionIndex === null ? 0 : (this._focusedOptionIndex + 1) % options.length;
        var startIdx = idx;
        do {
            var option = options[idx];
            if (!option.classList.contains('disabled') && option.getAttribute('aria-disabled') !== 'true') {
                this.resetFocus();
                this._focusedOptionIndex = idx;
                this.applyFocus(option);
                this.scrollIntoView(option);
                return option;
            }
            idx = (idx + 1) % options.length;
        } while (idx !== startIdx);
        return null;
    };
    /**
     * Focus the previous visible option
     */
    FocusManager.prototype.focusPrevious = function () {
        var options = this.getVisibleOptions();
        if (options.length === 0)
            return null;
        var idx = this._focusedOptionIndex === null ? options.length - 1 : (this._focusedOptionIndex - 1 + options.length) % options.length;
        var startIdx = idx;
        do {
            var option = options[idx];
            if (!option.classList.contains('disabled') && option.getAttribute('aria-disabled') !== 'true') {
                this.resetFocus();
                this._focusedOptionIndex = idx;
                this.applyFocus(option);
                this.scrollIntoView(option);
                return option;
            }
            idx = (idx - 1 + options.length) % options.length;
        } while (idx !== startIdx);
        return null;
    };
    /**
     * Apply focus to a specific option
     */
    FocusManager.prototype.applyFocus = function (option) {
        if (!option)
            return;
        // Ensure it's not disabled
        if (option.classList.contains('disabled') || option.getAttribute('aria-disabled') === 'true') {
            return;
        }
        // DO NOT CALL resetFocus() here. Caller's responsibility.
        option.classList.add(this._focusClass);
        option.classList.add(this._hoverClass);
        // _triggerFocusChange needs _focusedOptionIndex to be set by the caller before this.
        this._triggerFocusChange();
    };
    /**
     * Reset focus on all options
     */
    FocusManager.prototype.resetFocus = function () {
        var _this = this;
        var focusedElements = this._element.querySelectorAll(".".concat(this._focusClass, ", .").concat(this._hoverClass));
        // Remove focus and hover classes from all options
        focusedElements.forEach(function (element) {
            element.classList.remove(_this._focusClass, _this._hoverClass);
        });
        this._focusedOptionIndex = null; // Always reset the index
    };
    /**
     * Ensure the focused option is visible in the scrollable container
     */
    FocusManager.prototype.scrollIntoView = function (option) {
        if (!option)
            return;
        var container = this._element.querySelector('[data-kt-select-options]');
        if (!container)
            return;
        var optionRect = option.getBoundingClientRect();
        var containerRect = container.getBoundingClientRect();
        // Check if option is below the visible area
        if (optionRect.bottom > containerRect.bottom) {
            option.scrollIntoView({ block: 'end', behavior: 'smooth' });
        }
        // Check if option is above the visible area
        else if (optionRect.top < containerRect.top) {
            option.scrollIntoView({ block: 'start', behavior: 'smooth' });
        }
    };
    /**
     * Focus a specific option by its value
     */
    FocusManager.prototype.focusOptionByValue = function (value) {
        var options = this.getVisibleOptions();
        var index = options.findIndex(function (option) { return option.dataset.value === value; });
        if (index >= 0) {
            var optionToFocus = options[index];
            if (!optionToFocus.classList.contains('disabled') && optionToFocus.getAttribute('aria-disabled') !== 'true') {
                this.resetFocus();
                this._focusedOptionIndex = index;
                this.applyFocus(optionToFocus);
                this.scrollIntoView(optionToFocus);
                return true;
            }
        }
        return false;
    };
    /**
     * Get the currently focused option
     */
    FocusManager.prototype.getFocusedOption = function () {
        var options = this.getVisibleOptions();
        if (this._focusedOptionIndex !== null &&
            this._focusedOptionIndex < options.length) {
            return options[this._focusedOptionIndex];
        }
        return null;
    };
    /**
     * Get the index of the currently focused option
     */
    FocusManager.prototype.getFocusedIndex = function () {
        return this._focusedOptionIndex;
    };
    /**
     * Set the focused option index directly
     */
    FocusManager.prototype.setFocusedIndex = function (index) {
        this._focusedOptionIndex = index;
    };
    /**
     * Set a callback to be called when focus changes
     */
    FocusManager.prototype.setOnFocusChange = function (cb) {
        this._onFocusChange = cb;
    };
    FocusManager.prototype._triggerFocusChange = function () {
        if (this._onFocusChange) {
            this._onFocusChange(this.getFocusedOption(), this._focusedOptionIndex);
        }
    };
    /**
     * Clean up event listeners
     */
    FocusManager.prototype.dispose = function () {
        if (this._eventManager) {
            this._eventManager.removeAllListeners(this._element);
        }
    };
    return FocusManager;
}());
exports.FocusManager = FocusManager;
/**
 * Centralized event listener management
 */
var EventManager = /** @class */ (function () {
    function EventManager() {
        this._boundHandlers = new Map();
    }
    /**
     * Add an event listener with a bound context
     */
    EventManager.prototype.addListener = function (element, event, handler, context) {
        if (!element)
            return;
        // Create a bound version of the handler if context provided
        var boundHandler = context && typeof handler === 'function'
            ? handler.bind(context)
            : handler;
        // Store the relationship between original and bound handler
        if (!this._boundHandlers.has(event)) {
            this._boundHandlers.set(event, new Map());
        }
        var eventMap = this._boundHandlers.get(event);
        eventMap.set(handler, boundHandler);
        // Add the event listener
        element.addEventListener(event, boundHandler);
    };
    /**
     * Remove an event listener
     */
    EventManager.prototype.removeListener = function (element, event, handler) {
        if (!element)
            return;
        var eventMap = this._boundHandlers.get(event);
        if (!eventMap)
            return;
        // Get the bound version of the handler
        var boundHandler = eventMap.get(handler);
        if (!boundHandler)
            return;
        // Remove the event listener
        element.removeEventListener(event, boundHandler);
        // Clean up the map
        eventMap.delete(handler);
        if (eventMap.size === 0) {
            this._boundHandlers.delete(event);
        }
    };
    /**
     * Remove all event listeners
     */
    EventManager.prototype.removeAllListeners = function (element) {
        if (!element)
            return;
        // Go through each event type
        this._boundHandlers.forEach(function (eventMap, event) {
            // For each event type, go through each handler
            eventMap.forEach(function (boundHandler) {
                element.removeEventListener(event, boundHandler);
            });
        });
        // Clear the maps
        this._boundHandlers.clear();
    };
    return EventManager;
}());
exports.EventManager = EventManager;
/**
 * Debounce function to limit how often a function can be called
 */
function debounce(func, delay) {
    var timeout;
    return function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        clearTimeout(timeout);
        timeout = setTimeout(function () { return func.apply(void 0, args); }, delay);
    };
}
/**
 * Replaces all {{key}} in the template with the corresponding value from the data object.
 * If a key is missing in data, replaces with an empty string.
 */
function renderTemplateString(template, data) {
    return template.replace(/{{(\w+)}}/g, function (_, key) {
        return data[key] !== undefined && data[key] !== null ? String(data[key]) : '';
    });
}
// Type-to-search buffer utility for keyboard navigation
var TypeToSearchBuffer = /** @class */ (function () {
    function TypeToSearchBuffer(timeout) {
        if (timeout === void 0) { timeout = 500; }
        this.buffer = '';
        this.lastTime = 0;
        this.timeout = timeout;
    }
    TypeToSearchBuffer.prototype.push = function (char) {
        var now = Date.now();
        if (now - this.lastTime > this.timeout) {
            this.buffer = '';
        }
        this.buffer += char;
        this.lastTime = now;
    };
    TypeToSearchBuffer.prototype.getBuffer = function () {
        return this.buffer;
    };
    TypeToSearchBuffer.prototype.clear = function () {
        this.buffer = '';
    };
    return TypeToSearchBuffer;
}());
exports.TypeToSearchBuffer = TypeToSearchBuffer;
function stringToElement(html) {
    var template = document.createElement('template');
    template.innerHTML = html.trim();
    return template.content.firstElementChild;
}


/***/ }),

/***/ 9018:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


/**
 * KTUI - Free & Open-Source Tailwind UI Components by Keenthemes
 * Copyright 2025 by Keenthemes Inc
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.KTImageInput = void 0;
var image_input_1 = __webpack_require__(2922);
Object.defineProperty(exports, "KTImageInput", ({ enumerable: true, get: function () { return image_input_1.KTImageInput; } }));


/***/ }),

/***/ 9069:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


/**
 * KTUI - Free & Open-Source Tailwind UI Components by Keenthemes
 * Copyright 2025 by Keenthemes Inc
 */
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.defaultTemplates = exports.coreTemplateStrings = void 0;
exports.setTemplateStrings = setTemplateStrings;
exports.getTemplateStrings = getTemplateStrings;
var utils_1 = __webpack_require__(9011);
/**
 * Default HTML string templates for KTSelect. All UI structure is defined here.
 * Users can override any template by providing a matching key in the config.templates object.
 */
exports.coreTemplateStrings = {
    dropdown: "<div data-kt-select-dropdown class=\"kt-select-dropdown hidden {{class}}\" style=\"z-index: {{zindex}};\"></div>",
    options: "<ul role=\"listbox\" aria-label=\"{{label}}\" class=\"kt-select-options {{class}}\" data-kt-select-options=\"true\"></ul>",
    error: "<li class=\"kt-select-error\" role=\"alert\"></li>",
    wrapper: "<div data-kt-select-wrapper class=\"kt-select-wrapper {{class}}\"></div>",
    combobox: "\n\t\t<div data-kt-select-combobox data-kt-select-display class=\"kt-select-combobox {{class}}\">\n\t\t\t<div data-kt-select-combobox-values=\"true\" class=\"kt-select-combobox-values\"></div>\n\t\t\t<input class=\"kt-input kt-select-combobox-input\" data-kt-select-search=\"true\" type=\"text\" placeholder=\"{{placeholder}}\" role=\"searchbox\" aria-label=\"{{label}}\" {{disabled}} />\n\t\t\t<button type=\"button\" data-kt-select-clear-button=\"true\" class=\"kt-select-combobox-clear-btn\" aria-label=\"Clear selection\">\n\t\t\t\t<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"16\" height=\"16\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\">\n\t\t\t\t\t<line x1=\"18\" y1=\"6\" x2=\"6\" y2=\"18\"></line>\n\t\t\t\t\t<line x1=\"6\" y1=\"6\" x2=\"18\" y2=\"18\"></line>\n\t\t\t\t</svg>\n\t\t\t</button>\n\t\t</div>\n\t",
    placeholder: "<div data-kt-select-placeholder class=\"kt-select-placeholder {{class}}\"></div>",
    display: "\n\t\t<div data-kt-select-display class=\"kt-select-display {{class}}\" tabindex=\"{{tabindex}}\" role=\"button\" data-selected=\"0\" aria-haspopup=\"listbox\" aria-expanded=\"false\" aria-label=\"{{label}}\" {{disabled}}>\n\t\t\t<div class=\"kt-select-option-text\" data-kt-text-container=\"true\">{{text}}</div>\n\t\t</div>\n\t",
    option: "\n\t\t<li data-kt-select-option data-value=\"{{value}}\" data-text=\"{{text}}\" class=\"kt-select-option {{class}}\" role=\"option\" {{selected}} {{disabled}}>\n\t\t\t<div class=\"kt-select-option-text\" data-kt-text-container=\"true\">{{text}}</div><svg viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"size-3.5 ms-auto hidden text-primary kt-select-option-selected:block\"><path d=\"M20 6 9 17l-5-5\"/></svg>\n\t\t</li>\n\t",
    search: "<div data-kt-select-search class=\"kt-select-search {{class}}\"><input type=\"text\" data-kt-select-search=\"true\" placeholder=\"{{searchPlaceholder}}\" class=\"kt-input kt-input-ghost\" role=\"searchbox\" aria-label=\"{{searchPlaceholder}}\"/></div>",
    searchEmpty: "<div data-kt-select-search-empty class=\"kt-select-search-empty {{class}}\"></div>",
    loading: "<li class=\"kt-select-loading {{class}}\" role=\"status\" aria-live=\"polite\"></li>",
    tag: "<div data-kt-select-tag=\"true\" class=\"kt-select-tag {{class}}\"></div>",
    loadMore: "<li class=\"kt-select-load-more {{class}}\" data-kt-select-load-more=\"true\"></li>",
    tagRemoveButton: "<button type=\"button\" data-kt-select-remove-button class=\"kt-select-tag-remove\" aria-label=\"Remove tag\" tabindex=\"0\"><svg width=\"12\" height=\"12\" viewBox=\"0 0 12 12\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\"><line x1=\"3\" y1=\"3\" x2=\"9\" y2=\"9\"/><line x1=\"9\" y1=\"3\" x2=\"3\" y2=\"9\"/></svg></button>",
};
/**
 * Default templates for KTSelect component
 */
function stringToElement(html) {
    var template = document.createElement('template');
    template.innerHTML = html.trim();
    return template.content.firstElementChild;
}
/**
 * User-supplied template overrides. Use setTemplateStrings() to add or update.
 */
var userTemplateStrings = {};
/**
 * Register or update user template overrides.
 * @param templates Partial template object to merge with defaults.
 */
function setTemplateStrings(templates) {
    userTemplateStrings = __assign(__assign({}, userTemplateStrings), templates);
}
/**
 * Get the complete template set, merging defaults, user overrides, and config templates.
 * @param config Optional config object with a "templates" property.
 */
function getTemplateStrings(config) {
    var templates = config && typeof config === 'object' && 'templates' in config
        ? config.templates
        : undefined;
    if (templates) {
        return __assign(__assign(__assign({}, exports.coreTemplateStrings), userTemplateStrings), templates);
    }
    return __assign(__assign({}, exports.coreTemplateStrings), userTemplateStrings);
}
/**
 * Default templates for KTSelect component
 */
exports.defaultTemplates = {
    /**
     * Renders the dropdown content
     */
    dropdown: function (config) {
        var _a;
        var template = getTemplateStrings(config).dropdown;
        // If a custom dropdownTemplate is provided, it's responsible for its own content.
        // Otherwise, the base template is used, and content is appended later.
        if (config.dropdownTemplate) {
            var renderedCustomTemplate = (0, utils_1.renderTemplateString)(config.dropdownTemplate, {
                zindex: config.zindex ? String(config.zindex) : '',
                // content: config.content || '', // No longer pass content to custom template directly here
                class: config.dropdownClass || '',
            });
            // The custom template IS the dropdown element
            var customDropdownEl = stringToElement(renderedCustomTemplate);
            if (config.zindex)
                customDropdownEl.style.zIndex = String(config.zindex);
            if (config.dropdownClass)
                (_a = customDropdownEl.classList).add.apply(_a, config.dropdownClass.split(' '));
            return customDropdownEl;
        }
        var html = template
            .replace('{{zindex}}', config.zindex ? String(config.zindex) : '')
            // .replace('{{content}}', '') // Content is no longer part of the base template string
            .replace('{{class}}', config.dropdownClass || '');
        return stringToElement(html);
    },
    /**
     * Renders the options container for the dropdown
     */
    options: function (config) {
        var template = getTemplateStrings(config).options;
        var html = template
            .replace('{{label}}', config.label || 'Options')
            .replace('{{height}}', config.height ? String(config.height) : '250')
            // .replace('{{options}}', '') // Options are now appended dynamically
            .replace('{{class}}', config.optionsClass || '');
        return stringToElement(html);
    },
    /**
     * Renders the load more button for pagination
     */
    loadMore: function (config) {
        var html = getTemplateStrings(config)
            .loadMore // .replace('{{loadMoreText}}', config.loadMoreText || 'Load more...') // Content is no longer in template string
            .replace('{{class}}', config.loadMoreClass || '');
        var element = stringToElement(html);
        element.textContent = config.loadMoreText || 'Load more...';
        return element;
    },
    /**
     * Renders an error message in the dropdown
     */
    error: function (config) {
        // Changed return type to HTMLElement
        var template = getTemplateStrings(config).error;
        var html = template
            // .replace('{{errorMessage}}', config.errorMessage || 'An error occurred') // Content is no longer in template string
            .replace('{{class}}', config.errorClass || '');
        var element = stringToElement(html);
        element.textContent = config.errorMessage || 'An error occurred';
        return element;
    },
    /**
     * Renders the main container for the select component
     */
    wrapper: function (config) {
        var html = getTemplateStrings(config).wrapper.replace('{{class}}', config.wrapperClass || '');
        var element = stringToElement(html);
        return element;
    },
    /**
     * Renders the display element (trigger) for the select
     */
    display: function (config) {
        var html = getTemplateStrings(config)
            .display.replace('{{tabindex}}', config.disabled ? '-1' : '0')
            .replace('{{label}}', config.label || config.placeholder || 'Select...')
            .replace('{{disabled}}', config.disabled ? 'aria-disabled="true"' : '')
            .replace('{{placeholder}}', config.placeholder || 'Select...')
            .replace('{{class}}', config.displayClass || '');
        var element = stringToElement(html);
        // Add data-multiple attribute if in multiple select mode
        if (config.multiple) {
            element.setAttribute('data-multiple', 'true');
        }
        return element;
    },
    /**
     * Renders a single option
     */
    option: function (option, config) {
        var _a, _b, _c;
        var isHtmlOption = option instanceof HTMLOptionElement;
        var optionData;
        if (isHtmlOption) {
            // If it's a plain HTMLOptionElement, construct data similarly to how KTSelectOption would
            // This branch might be less common if KTSelectOption instances are always used for rendering.
            var el = option;
            var textContent = el.textContent || '';
            optionData = __assign({ value: el.value, text: textContent, selected: el.selected, disabled: el.disabled, content: textContent }, (((_a = config.optionsConfig) === null || _a === void 0 ? void 0 : _a[el.value]) || {}));
        }
        else {
            // If it's a KTSelectOption class instance (from './option')
            // which should have the getOptionDataForTemplate method.
            optionData = option.getOptionDataForTemplate();
        }
        var content = (_b = optionData === null || optionData === void 0 ? void 0 : optionData.text) === null || _b === void 0 ? void 0 : _b.trim(); // Default content to option's text
        if (config.optionTemplate) {
            // Use the user-provided template string, rendering with the full optionData.
            // renderTemplateString will replace {{key}} with values from optionData.
            content = (0, utils_1.renderTemplateString)(config.optionTemplate, optionData);
        }
        else {
            content = optionData.text || optionData.content; // Prefer explicit text, fallback to content
        }
        // Use the core option template string as the base structure.
        var baseTemplate = getTemplateStrings(config).option;
        var optionClasses = [config.optionClass || ''];
        if (optionData.disabled) {
            optionClasses.push('disabled');
        }
        // Populate the base template for the <li> attributes.
        // The actual display content (text or custom HTML) will be set on the inner span later.
        var html = (0, utils_1.renderTemplateString)(baseTemplate, __assign(__assign({}, optionData), { class: optionClasses.join(' ').trim() || '', selected: optionData.selected
                ? 'aria-selected="true"'
                : 'aria-selected="false"', disabled: optionData.disabled ? 'aria-disabled="true"' : '', content: content }));
        var element = stringToElement(html);
        // If a custom option template is provided, replace the element's innerHTML with the content.
        if (config.optionTemplate) {
            element.innerHTML = content;
        }
        // Ensure data-text attribute is set to the original, clean text for searching/filtering
        element.setAttribute('data-text', ((_c = optionData === null || optionData === void 0 ? void 0 : optionData.text) === null || _c === void 0 ? void 0 : _c.trim()) || '');
        return element;
    },
    /**
     * Renders the search input
     */
    search: function (config) {
        var html = getTemplateStrings(config)
            .search.replace('{{searchPlaceholder}}', config.searchPlaceholder || 'Search...')
            .replace('{{class}}', config.searchClass || '');
        return stringToElement(html);
    },
    /**
     * Renders the no results message
     */
    searchEmpty: function (config) {
        var html = getTemplateStrings(config).searchEmpty.replace('{{class}}', config.searchEmptyClass || '');
        var content = config.searchEmpty || 'No results';
        if (config.searchEmptyTemplate) {
            content = (0, utils_1.renderTemplateString)(config.searchEmptyTemplate, {
                class: config.searchEmptyClass || '',
            });
            var element = stringToElement(html);
            element.innerHTML = content; // For templates, content can be HTML
            return element;
        }
        else {
            var element = stringToElement(html);
            element.textContent = content; // For simple text, use textContent
            return element;
        }
    },
    /**
     * Renders the loading state
     */
    loading: function (config, loadingMessage) {
        var html = getTemplateStrings(config).loading.replace('{{class}}', config.loadingClass || '');
        var element = stringToElement(html);
        element.textContent = loadingMessage || 'Loading options...';
        return element;
    },
    /**
     * Renders a tag for multi-select
     */
    tag: function (option, config) {
        var _a;
        var template = getTemplateStrings(config).tag;
        var preparedContent = option.title; // Default content is the option's title
        if (config.tagTemplate) {
            var tagTemplateString_1 = config.tagTemplate;
            var optionValue = option.getAttribute('data-value') || option.value;
            // Replace all {{varname}} in option.innerHTML with values from _config.optionsConfig
            Object.entries(((_a = config.optionsConfig) === null || _a === void 0 ? void 0 : _a[optionValue]) || {}).forEach(function (_a) {
                var key = _a[0], val = _a[1];
                if (typeof val === 'string' ||
                    typeof val === 'number' ||
                    typeof val === 'boolean') {
                    tagTemplateString_1 = tagTemplateString_1.replace(new RegExp("{{".concat(key, "}}"), 'g'), String(val));
                }
            });
            // Render the custom tag template with option data
            preparedContent = (0, utils_1.renderTemplateString)(tagTemplateString_1, {
                title: option.title,
                id: option.id,
                class: config.tagClass || '', // This class is for content, not the main tag div
                // content: option.innerHTML, // Avoid direct innerHTML from option due to potential XSS
                text: option.innerText || option.textContent || '',
                value: optionValue,
            });
        }
        // Append the remove button HTML string to the prepared content
        preparedContent += getTemplateStrings(config).tagRemoveButton;
        var html = template
            // .replace('{{title}}', option.title) // Title is part of preparedContent if using custom template
            // .replace('{{id}}', option.id)       // ID is part of preparedContent if using custom template
            .replace('{{class}}', config.tagClass || ''); // Class for the main tag div
        var element = stringToElement(html);
        element.innerHTML = preparedContent; // Set the fully prepared content (text/HTML + remove button)
        return element;
    },
    /**
     * Renders the placeholder for the select
     */
    placeholder: function (config) {
        var html = getTemplateStrings(config).placeholder.replace('{{class}}', config.placeholderClass || '');
        var content = config.placeholder || 'Select...';
        if (config.placeholderTemplate) {
            content = (0, utils_1.renderTemplateString)(config.placeholderTemplate, {
                placeholder: config.placeholder || 'Select...',
                class: config.placeholderClass || '',
            });
            var element = stringToElement(html);
            element.innerHTML = content; // For templates, content can be HTML
            return element;
        }
        else {
            var element = stringToElement(html);
            element.textContent = content; // For simple text, use textContent
            return element;
        }
    },
};


/***/ }),

/***/ 9250:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


/**
 * KTUI - Free & Open-Source Tailwind UI Components by Keenthemes
 * Copyright 2025 by Keenthemes Inc
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.KTThemeSwitch = void 0;
var theme_switch_1 = __webpack_require__(4592);
Object.defineProperty(exports, "KTThemeSwitch", ({ enumerable: true, get: function () { return theme_switch_1.KTThemeSwitch; } }));


/***/ }),

/***/ 9364:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


/**
 * KTUI - Free & Open-Source Tailwind UI Components by Keenthemes
 * Copyright 2025 by Keenthemes Inc
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.KTDatepickerCalendar = void 0;
var templates_1 = __webpack_require__(9619);
var utils_1 = __webpack_require__(2393);
var dropdown_1 = __webpack_require__(8599);
var events_1 = __webpack_require__(5795);
/**
 * Calendar component for the KTDatepicker
 * Handles rendering and interactions with the calendar
 */
var KTDatepickerCalendar = /** @class */ (function () {
    /**
     * Constructor for the KTDatepickerCalendar class
     *
     * @param element - The datepicker element
     * @param stateManager - State manager for the datepicker
     */
    function KTDatepickerCalendar(element, stateManager) {
        this._calendarContainer = null;
        this._dropdownElement = null;
        this._dropdownManager = null;
        this._isVisible = false;
        this._element = element;
        this._stateManager = stateManager;
        this._eventManager = stateManager.getEventManager();
        // Get current date/time
        var now = new Date();
        this._currentViewMonth = now.getMonth();
        this._currentViewYear = now.getFullYear();
        this._initializeCalendar();
        this._setupEventListeners();
    }
    /**
     * Initialize the calendar
     */
    KTDatepickerCalendar.prototype._initializeCalendar = function () {
        var _this = this;
        var config = this._stateManager.getConfig();
        var locale = (0, utils_1.getLocaleConfig)(config);
        // Create calendar container
        this._dropdownElement = document.createElement('div');
        this._dropdownElement.className = 'kt-datepicker-dropdown';
        this._dropdownElement.setAttribute('role', 'dialog');
        this._dropdownElement.setAttribute('aria-modal', 'true');
        this._dropdownElement.setAttribute('aria-label', 'Calendar');
        // Hidden by default
        this._dropdownElement.classList.add('hidden');
        this._dropdownElement.setAttribute('aria-hidden', 'true');
        // Create header for navigation
        var headerElement = document.createElement('div');
        headerElement.className = 'kt-datepicker-calendar-header';
        // Left navigation button
        var leftNavButton = document.createElement('button');
        leftNavButton.type = 'button';
        leftNavButton.className = 'kt-datepicker-calendar-left-nav-btn';
        leftNavButton.setAttribute('aria-label', 'Previous month');
        leftNavButton.innerHTML =
            '<svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M12.707 5.293a1 1 0 010 1.414L9.414 10l3.293 3.293a1 1 0 01-1.414 1.414l-4-4a1 1 0 010-1.414l4-4a1 1 0 011.414 0z" clip-rule="evenodd" /></svg>';
        leftNavButton.addEventListener('click', function () { return _this._navigateMonth(-1); });
        // Month and Year selector (center)
        var headerCenter = document.createElement('div');
        headerCenter.className = 'kt-datepicker-datepicker-header-middle';
        // Right navigation button
        var rightNavButton = document.createElement('button');
        rightNavButton.type = 'button';
        rightNavButton.className = 'kt-dropdown-calendar-right-nav-btn';
        rightNavButton.setAttribute('aria-label', 'Next month');
        rightNavButton.innerHTML =
            '<svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M7.293 14.707a1 1 0 010-1.414L10.586 10 7.293 6.707a1 1 0 011.414-1.414l4 4a1 1 0 010 1.414l-4 4a1 1 0 01-1.414 0z" clip-rule="evenodd" /></svg>';
        rightNavButton.addEventListener('click', function () { return _this._navigateMonth(1); });
        // Assemble header
        headerElement.appendChild(leftNavButton);
        headerElement.appendChild(headerCenter);
        headerElement.appendChild(rightNavButton);
        this._dropdownElement.appendChild(headerElement);
        // Create calendar content container
        this._calendarContainer = document.createElement('div');
        this._calendarContainer.className = 'kt-datepicker-calendar-container';
        this._dropdownElement.appendChild(this._calendarContainer);
        // Add calendar footer with action buttons
        var footerElement = document.createElement('div');
        footerElement.className = 'kt-datepicker-calendar-footer';
        // Today button
        var todayButton = document.createElement('button');
        todayButton.type = 'button';
        todayButton.className = 'kt-datepicker-calendar-today-btn';
        todayButton.textContent = 'Today';
        todayButton.addEventListener('click', function () { return _this._goToToday(); });
        // Clear button
        var clearButton = document.createElement('button');
        clearButton.type = 'button';
        clearButton.className = 'kt-datepicker-calendar-clear-btn';
        clearButton.textContent = 'Clear';
        clearButton.addEventListener('click', function () { return _this._clearSelection(); });
        // Apply button
        var applyButton = document.createElement('button');
        applyButton.type = 'button';
        applyButton.className = 'kt-datepicker-calendar-clear-btn';
        applyButton.textContent = 'Apply';
        applyButton.addEventListener('click', function () { return _this._applySelection(); });
        // Assemble footer
        footerElement.appendChild(todayButton);
        var rightFooter = document.createElement('div');
        rightFooter.className = 'kt-datepicker-calendar-footer-right';
        rightFooter.appendChild(clearButton);
        rightFooter.appendChild(applyButton);
        footerElement.appendChild(rightFooter);
        this._dropdownElement.appendChild(footerElement);
        // Add to document
        this._element.appendChild(this._dropdownElement);
        // Initialize dropdown manager
        this._initDropdownManager();
        // Initialize calendar view
        this._renderCalendarView();
    };
    /**
     * Initialize the dropdown manager
     */
    KTDatepickerCalendar.prototype._initDropdownManager = function () {
        var _this = this;
        var config = this._stateManager.getConfig();
        // Use the display element rather than the input element
        var displayElement = this._element.querySelector('[data-kt-datepicker-display]');
        var inputElement = this._element.querySelector('[data-kt-datepicker-input]');
        var triggerElement = displayElement || inputElement;
        if (triggerElement && this._dropdownElement) {
            this._dropdownManager = new dropdown_1.KTDatepickerDropdown(this._element, triggerElement, this._dropdownElement, config);
            // Add keyboard event listener to the trigger element
            triggerElement.addEventListener('keydown', function (e) {
                if (e.key === 'Enter' || e.key === ' ' || e.key === 'ArrowDown') {
                    e.preventDefault();
                    if (!_this._isVisible) {
                        // Open the dropdown
                        _this._stateManager.setOpen(true);
                    }
                }
            });
        }
    };
    /**
     * Set up event listeners for calendar interactions
     */
    KTDatepickerCalendar.prototype._setupEventListeners = function () {
        var _this = this;
        if (!this._dropdownElement)
            return;
        // Get elements
        var prevMonthBtn = this._dropdownElement.querySelector('button[aria-label="Previous Month"]');
        var nextMonthBtn = this._dropdownElement.querySelector('button[aria-label="Next Month"]');
        // Find buttons by text content instead of using jQuery-style selectors
        var buttons = this._dropdownElement.querySelectorAll('button');
        var todayBtn = null;
        var clearBtn = null;
        var applyBtn = null;
        buttons.forEach(function (btn) {
            var _a;
            var btnText = (_a = btn.textContent) === null || _a === void 0 ? void 0 : _a.trim();
            if (btnText === 'Today')
                todayBtn = btn;
            else if (btnText === 'Clear')
                clearBtn = btn;
            else if (btnText === 'Apply')
                applyBtn = btn;
        });
        var monthYearText = this._dropdownElement.querySelector('.kt-datepicker-calendar-monthyear-text');
        // Month navigation
        if (prevMonthBtn) {
            prevMonthBtn.addEventListener('click', function () { return _this._navigateMonth(-1); });
        }
        if (nextMonthBtn) {
            nextMonthBtn.addEventListener('click', function () { return _this._navigateMonth(1); });
        }
        // Month/year view toggle
        if (monthYearText) {
            monthYearText.addEventListener('click', function () {
                return _this._toggleMonthYearView();
            });
        }
        // Today, Clear, Apply buttons
        if (todayBtn) {
            todayBtn.addEventListener('click', function () { return _this._goToToday(); });
        }
        if (clearBtn) {
            clearBtn.addEventListener('click', function () { return _this._clearSelection(); });
        }
        if (applyBtn) {
            applyBtn.addEventListener('click', function () { return _this._applySelection(); });
        }
        // Handle day selection through event delegation
        if (this._calendarContainer) {
            this._calendarContainer.addEventListener('click', function (e) {
                var target = e.target;
                var dayButton = target.closest('button[data-date]');
                if (dayButton && !dayButton.hasAttribute('disabled')) {
                    // Get the date ID directly from the clicked button (YYYY-MM-DD format)
                    var dateIdAttr = dayButton.getAttribute('data-date-id');
                    if (dateIdAttr) {
                        // Parse the ISO date string to get exact year, month, day
                        var _a = dateIdAttr
                            .split('-')
                            .map(function (part) { return parseInt(part, 10); }), year = _a[0], month = _a[1], day = _a[2];
                        // Create the date object from the parsed components
                        var clickedDate = new Date(year, month - 1, day); // Month is 0-indexed in JS
                        clickedDate.setHours(0, 0, 0, 0); // Set to midnight
                        // Handle this date directly instead of using day number
                        _this._handleDateSelection(clickedDate, dayButton);
                    }
                    else {
                        // Fallback to old method using day number if date-id is not present
                        var dateAttr = dayButton.getAttribute('data-date');
                        if (dateAttr) {
                            var day = parseInt(dateAttr, 10);
                            _this._handleDaySelection(day);
                        }
                    }
                }
            });
            // Add hover effect for range selection
            this._calendarContainer.addEventListener('mouseover', function (e) {
                var state = _this._stateManager.getState();
                var config = _this._stateManager.getConfig();
                // Only apply hover effect in range mode when start date is selected but end date is not
                if (!config.range ||
                    !state.selectedDateRange ||
                    !state.selectedDateRange.startDate ||
                    state.selectedDateRange.endDate) {
                    return;
                }
                var target = e.target;
                var dayButton = target.closest('button[data-date]');
                if (dayButton && !dayButton.hasAttribute('disabled')) {
                    // Clear any existing hover classes
                    _this._clearRangeHoverClasses();
                    // Get the proper date from the data-date-id attribute
                    var dateIdAttr = dayButton.getAttribute('data-date-id');
                    if (dateIdAttr) {
                        // Parse the ISO date string (YYYY-MM-DD)
                        var _a = dateIdAttr
                            .split('-')
                            .map(function (part) { return parseInt(part, 10); }), year = _a[0], month = _a[1], day = _a[2];
                        var hoverDate = new Date(year, month - 1, day); // Month is 0-indexed in JS Date
                        // Apply hover effect between start date and current hover date
                        _this._applyRangeHoverEffect(state.selectedDateRange.startDate, hoverDate);
                    }
                    else {
                        // Fallback to old method if data-date-id is not present
                        var dateAttr = dayButton.getAttribute('data-date');
                        if (dateAttr) {
                            var day = parseInt(dateAttr, 10);
                            var hoverDate = new Date(state.currentDate);
                            hoverDate.setDate(day);
                            // Apply hover effect between start date and current hover date
                            _this._applyRangeHoverEffect(state.selectedDateRange.startDate, hoverDate);
                        }
                    }
                }
            });
            // Clear hover effect when mouse leaves the calendar
            this._calendarContainer.addEventListener('mouseleave', function () {
                _this._clearRangeHoverClasses();
            });
        }
        // Listen for state changes
        this._eventManager.addEventListener(events_1.KTDatepickerEventName.STATE_CHANGE, function (e) {
            var _a;
            var detail = (_a = e.detail) === null || _a === void 0 ? void 0 : _a.payload;
            var config = _this._stateManager.getConfig();
            // For range selection, check if we need to keep the dropdown open
            if (config.range && detail && detail.selectedDateRange) {
                var _b = detail.selectedDateRange, startDate = _b.startDate, endDate = _b.endDate;
                // If start date is set but no end date, keep dropdown open
                if (startDate && !endDate) {
                    _this._stateManager.getState().isRangeSelectionInProgress = true;
                }
                else if (startDate && endDate) {
                    _this._stateManager.getState().isRangeSelectionInProgress = false;
                }
            }
            // Update calendar view
            _this._updateCalendarView();
        });
        // Listen for other state changes
        this._eventManager.addEventListener(events_1.KTDatepickerEventName.VIEW_CHANGE, function () {
            return _this._updateViewMode();
        });
        this._eventManager.addEventListener(events_1.KTDatepickerEventName.OPEN, function () {
            return _this.show();
        });
        this._eventManager.addEventListener(events_1.KTDatepickerEventName.CLOSE, function () {
            return _this.hide();
        });
        this._eventManager.addEventListener(events_1.KTDatepickerEventName.UPDATE, function () {
            return _this._updateCalendarView();
        });
        // Time inputs
        var timeContainer = this._dropdownElement.querySelector('.kt-datepicker-calendar-time-container');
        if (timeContainer) {
            var hourInput = timeContainer.querySelector('input[aria-label="Hour"]');
            var minuteInput = timeContainer.querySelector('input[aria-label="Minute"]');
            var secondInput = timeContainer.querySelector('input[aria-label="Second"]');
            var amButton = timeContainer.querySelector('button[aria-label="AM"]');
            var pmButton = timeContainer.querySelector('button[aria-label="PM"]');
            // Update AM/PM button texts
            var config = this._stateManager.getConfig();
            if (amButton)
                amButton.textContent = config.am;
            if (pmButton)
                pmButton.textContent = config.pm;
            // Time input listeners
            if (hourInput) {
                hourInput.addEventListener('change', function () { return _this._handleTimeChange(); });
            }
            if (minuteInput) {
                minuteInput.addEventListener('change', function () { return _this._handleTimeChange(); });
            }
            if (secondInput) {
                secondInput.addEventListener('change', function () { return _this._handleTimeChange(); });
            }
            // AM/PM selection
            if (amButton) {
                amButton.addEventListener('click', function () { return _this._setAmPm('AM'); });
            }
            if (pmButton) {
                pmButton.addEventListener('click', function () { return _this._setAmPm('PM'); });
            }
        }
    };
    /**
     * Render the calendar view based on current state
     */
    KTDatepickerCalendar.prototype._renderCalendarView = function () {
        var _this = this;
        if (!this._calendarContainer)
            return;
        var state = this._stateManager.getState();
        var config = this._stateManager.getConfig();
        var locale = (0, utils_1.getLocaleConfig)(config);
        // Clear existing content
        this._calendarContainer.innerHTML = '';
        // Set up proper container classes for multiple months view
        if (config.visibleMonths > 1) {
            // For multiple months, use a flex container with no wrapping
            this._calendarContainer.className = 'kt-datepicker-calendar-container-mt';
        }
        else {
            this._calendarContainer.className = 'kt-datepicker-calendar-container';
        }
        // Render based on view mode
        switch (state.viewMode) {
            case 'days':
                // For each visible month, create a calendar
                for (var i = 0; i < config.visibleMonths; i++) {
                    // Calculate the month to display
                    var tempDate = new Date(state.currentDate);
                    tempDate.setMonth(state.currentDate.getMonth() + i);
                    var month = tempDate.getMonth();
                    var year = tempDate.getFullYear();
                    // Create month container
                    var monthContainer = document.createElement('div');
                    // Set appropriate class based on number of months
                    if (config.visibleMonths > 1) {
                        // For multiple months, use fixed width and properly spaced
                        monthContainer.className = 'kt-datepicker-calendar-month-mt';
                        monthContainer.setAttribute('data-month-id', "".concat(month, "-").concat(year));
                    }
                    else {
                        monthContainer.className = 'kt-datepicker-calendar-month';
                    }
                    // Add month header
                    var monthHeader = document.createElement('div');
                    monthHeader.className = 'kt-datepicker-calendar-month-header';
                    monthHeader.textContent = "".concat(locale.monthNames[month], " ").concat(year);
                    monthContainer.appendChild(monthHeader);
                    // Generate calendar grid
                    monthContainer.innerHTML += (0, templates_1.calendarGridTemplate)(locale, config.weekDays);
                    // Get days for the month
                    var calendarMatrix = (0, utils_1.generateCalendarMonth)(year, month, config);
                    // Render days
                    var daysBody = monthContainer.querySelector('tbody');
                    if (daysBody) {
                        daysBody.innerHTML = this._renderDays(calendarMatrix, month, year);
                    }
                    // Add to container
                    this._calendarContainer.appendChild(monthContainer);
                }
                // Update the month/year display in header
                this._updateMonthYearDisplay();
                break;
            case 'months':
                // Render month selection view with current month
                var currentMonth = state.currentDate.getMonth();
                this._calendarContainer.innerHTML = (0, templates_1.monthSelectionTemplate)(locale, currentMonth);
                // Add click events to month buttons
                var monthButtons = this._calendarContainer.querySelectorAll('button[data-month]');
                monthButtons.forEach(function (btn) {
                    btn.addEventListener('click', function (e) {
                        var target = e.target;
                        var monthIdx = target.getAttribute('data-month');
                        if (monthIdx) {
                            _this._selectMonth(parseInt(monthIdx, 10));
                        }
                    });
                });
                break;
            case 'years':
                // Get current year and calculate year range
                var currentYear = state.currentDate.getFullYear();
                var startYear_1 = currentYear - Math.floor(config.visibleYears / 2);
                var endYear_1 = startYear_1 + config.visibleYears - 1;
                // Render year selection view
                this._calendarContainer.innerHTML = (0, templates_1.yearSelectionTemplate)(startYear_1, endYear_1, currentYear);
                // Add click events to year buttons
                var yearButtons = this._calendarContainer.querySelectorAll('button[data-year]');
                yearButtons.forEach(function (btn) {
                    btn.addEventListener('click', function (e) {
                        var target = e.target;
                        var year = target.getAttribute('data-year');
                        if (year) {
                            _this._selectYear(parseInt(year, 10));
                        }
                    });
                });
                // Add navigation for year ranges
                var prevYearsBtn = this._calendarContainer.querySelector('button[data-year-nav="prev"]');
                if (prevYearsBtn) {
                    prevYearsBtn.addEventListener('click', function () {
                        var newYear = startYear_1 - config.visibleYears;
                        var newDate = new Date(state.currentDate);
                        newDate.setFullYear(newYear);
                        _this._stateManager.setCurrentDate(newDate);
                        _this._renderCalendarView();
                    });
                }
                var nextYearsBtn = this._calendarContainer.querySelector('button[data-year-nav="next"]');
                if (nextYearsBtn) {
                    nextYearsBtn.addEventListener('click', function () {
                        var newYear = endYear_1 + 1;
                        var newDate = new Date(state.currentDate);
                        newDate.setFullYear(newYear);
                        _this._stateManager.setCurrentDate(newDate);
                        _this._renderCalendarView();
                    });
                }
                break;
        }
    };
    /**
     * Render days for a calendar month
     *
     * @param calendarMatrix - Matrix of dates for the month
     * @param currentMonth - Current month
     * @param currentYear - Current year
     * @returns HTML string for the days
     */
    KTDatepickerCalendar.prototype._renderDays = function (calendarMatrix, currentMonth, currentYear) {
        var state = this._stateManager.getState();
        var config = this._stateManager.getConfig();
        var today = new Date();
        today.setHours(0, 0, 0, 0);
        var html = '';
        // Loop through each week
        for (var _i = 0, calendarMatrix_1 = calendarMatrix; _i < calendarMatrix_1.length; _i++) {
            var week = calendarMatrix_1[_i];
            html += '<tr>';
            var _loop_1 = function (date) {
                // Determine cell properties
                var isCurrentMonth = date.getMonth() === currentMonth;
                var isToday = (0, utils_1.isSameDay)(date, today);
                var isSelected = false;
                var isRangeStart = false;
                var isRangeEnd = false;
                var isInRange = false;
                // Check if date is selected
                if (state.selectedDate && (0, utils_1.isSameDay)(date, state.selectedDate)) {
                    isSelected = true;
                }
                // Check if date is in range for range selection
                if (config.range && state.selectedDateRange) {
                    var _b = state.selectedDateRange, startDate = _b.startDate, endDate = _b.endDate;
                    if (startDate && (0, utils_1.isSameDay)(date, startDate)) {
                        isRangeStart = true;
                        isSelected = true;
                    }
                    if (endDate && (0, utils_1.isSameDay)(date, endDate)) {
                        isRangeEnd = true;
                        isSelected = true;
                    }
                    if (startDate && endDate && (0, utils_1.isDateBetween)(date, startDate, endDate)) {
                        isInRange = true;
                    }
                }
                // Check if date is in multi-date selection
                if (config.multiDateSelection && state.selectedDates.length > 0) {
                    isSelected = state.selectedDates.some(function (d) { return (0, utils_1.isSameDay)(date, d); });
                }
                // Check if date is disabled
                var isDisabled = (0, utils_1.isDateDisabled)(date, config);
                // Check if weekend
                var isWeekendDay = (0, utils_1.isWeekend)(date);
                // Get the actual month and year of this date (may differ from currentMonth/currentYear for adjacent months)
                var actualMonth = date.getMonth();
                var actualYear = date.getFullYear();
                // Generate day cell
                html += (0, templates_1.dayTemplate)(date.getDate(), actualMonth, actualYear, isCurrentMonth, isToday, isSelected, isDisabled, isRangeStart, isRangeEnd, isInRange, isWeekendDay);
            };
            // Loop through each day in the week
            for (var _a = 0, week_1 = week; _a < week_1.length; _a++) {
                var date = week_1[_a];
                _loop_1(date);
            }
            html += '</tr>';
        }
        return html;
    };
    /**
     * Update the month and year display in the header
     */
    KTDatepickerCalendar.prototype._updateMonthYearDisplay = function () {
        var _this = this;
        if (!this._dropdownElement)
            return;
        var state = this._stateManager.getState();
        var config = this._stateManager.getConfig();
        var locale = (0, utils_1.getLocaleConfig)(config);
        // Find the calendar header
        var calendarHeader = this._dropdownElement.querySelector('.kt-datepicker-calendar-header');
        if (!calendarHeader)
            return;
        var currentMonth = state.currentDate.getMonth();
        var currentYear = state.currentDate.getFullYear();
        // Update the header with month/year selectors
        calendarHeader.innerHTML = (0, templates_1.monthYearSelectTemplate)(locale, currentMonth, currentYear);
        // Add event listeners to the month and year selectors
        var monthSelector = calendarHeader.querySelector('.kt-datepicker-calendar-month-selector');
        var yearSelector = calendarHeader.querySelector('.kt-datepicker-calendar-year-selector');
        if (monthSelector) {
            monthSelector.addEventListener('click', function () {
                // Switch to months view
                _this._stateManager.setViewMode('months');
                _this._renderCalendarView();
            });
        }
        if (yearSelector) {
            yearSelector.addEventListener('click', function () {
                // Switch to years view
                _this._stateManager.setViewMode('years');
                _this._renderCalendarView();
            });
        }
    };
    /**
     * Navigate to a different month
     *
     * @param offset - Number of months to offset by
     */
    KTDatepickerCalendar.prototype._navigateMonth = function (offset) {
        var state = this._stateManager.getState();
        var newDate = new Date(state.currentDate);
        newDate.setMonth(newDate.getMonth() + offset);
        this._stateManager.setCurrentDate(newDate);
        this._renderCalendarView();
    };
    /**
     * Handle direct date selection (new method that takes the actual date object)
     *
     * @param selectedDate - The exact date that was selected
     * @param clickedButton - The button element that was clicked
     */
    KTDatepickerCalendar.prototype._handleDateSelection = function (selectedDate, clickedButton) {
        var state = this._stateManager.getState();
        var config = this._stateManager.getConfig();
        // Check if the date is disabled (outside min/max range or explicitly disabled)
        if ((0, utils_1.isDateDisabled)(selectedDate, config)) {
            console.log('Date is disabled, ignoring selection:', selectedDate.toISOString());
            return;
        }
        // Create a new date object set to noon of the selected date in local timezone
        // This prevents timezone shifts causing the wrong date to be selected
        var localSelectedDate = new Date(selectedDate);
        localSelectedDate.setHours(12, 0, 0, 0);
        // Set time if enabled
        if (config.enableTime && state.selectedTime) {
            localSelectedDate.setHours(state.selectedTime.hours, state.selectedTime.minutes, state.selectedTime.seconds, 0);
        }
        // Get the current range state before updating
        var currentRange = state.selectedDateRange;
        var isStartingNewRange = !currentRange ||
            !currentRange.startDate ||
            (currentRange.startDate && currentRange.endDate);
        // Determine if we're in a month different from the currently displayed one
        var selectedMonth = localSelectedDate.getMonth();
        var currentViewMonth = state.currentDate.getMonth();
        var isInDifferentMonth = selectedMonth !== currentViewMonth;
        console.log('Selected date:', localSelectedDate.toISOString(), 'Month:', selectedMonth, 'Current view month:', currentViewMonth, 'Day of month:', localSelectedDate.getDate());
        // Call the state manager's setSelectedDate method
        this._stateManager.setSelectedDate(localSelectedDate);
        // After setting the date, get the updated range state
        var updatedRange = state.selectedDateRange;
        // If we're in range mode, handle specific range selection behavior
        if (config.range) {
            if (isStartingNewRange) {
                console.log('Starting new range selection with date:', localSelectedDate.toISOString());
                // If starting a range with a date in a different month, update the view
                if (isInDifferentMonth) {
                    this._stateManager.setCurrentDate(localSelectedDate);
                }
                // Explicitly clear any hover effects when starting a new range
                this._clearRangeHoverClasses();
            }
            else {
                // This is the second click to complete a range
                console.log('Completing range selection with date:', localSelectedDate.toISOString());
                // If the selected range spans different months and we have multiple visible months
                if (updatedRange &&
                    updatedRange.startDate &&
                    updatedRange.endDate &&
                    config.visibleMonths > 1) {
                    // Determine range start and end months
                    var startMonth = updatedRange.startDate.getMonth();
                    var endMonth = updatedRange.endDate.getMonth();
                    // If range spans multiple months, update view to show the earlier month
                    if (startMonth !== endMonth) {
                        // Show the earlier month as the first visible month
                        var earlierDate = updatedRange.startDate < updatedRange.endDate
                            ? updatedRange.startDate
                            : updatedRange.endDate;
                        this._stateManager.setCurrentDate(earlierDate);
                    }
                }
            }
            // Close dropdown only if range selection is complete
            if (updatedRange && updatedRange.startDate && updatedRange.endDate) {
                this._stateManager.setOpen(false);
            }
        }
        else {
            // For single date selection, close the dropdown
            this._stateManager.setOpen(false);
        }
        // Update calendar view to reflect changes
        this._updateCalendarView();
    };
    /**
     * Handle day selection (legacy method, kept for backward compatibility)
     *
     * @param day - Day number
     */
    KTDatepickerCalendar.prototype._handleDaySelection = function (day) {
        var _a;
        var state = this._stateManager.getState();
        var config = this._stateManager.getConfig();
        // Find the clicked button element using data-date attribute
        var dayButtons = (_a = this._calendarContainer) === null || _a === void 0 ? void 0 : _a.querySelectorAll("button[data-date=\"".concat(day, "\"]"));
        if (!dayButtons || dayButtons.length === 0)
            return;
        // First look for the button that matches the clicked target in the current month
        var clickedButton = null;
        // Find the actual button that was likely clicked (prefer current month days)
        for (var i = 0; i < dayButtons.length; i++) {
            var button = dayButtons[i];
            var parentCell = button.closest('td');
            // Check if the day is in the current month (not faded)
            var isCurrentMonth = !button.classList.contains('current') &&
                (!parentCell || !parentCell.classList.contains('current'));
            if (isCurrentMonth) {
                clickedButton = button;
                break;
            }
        }
        // If no current month button found, use the first one
        if (!clickedButton && dayButtons.length > 0) {
            clickedButton = dayButtons[0];
        }
        if (!clickedButton)
            return;
        // Get the proper date from the data-date-id attribute which contains YYYY-MM-DD
        var dateIdAttr = clickedButton.getAttribute('data-date-id');
        if (!dateIdAttr)
            return;
        // Parse the ISO date string
        var _b = dateIdAttr
            .split('-')
            .map(function (part) { return parseInt(part, 10); }), year = _b[0], month = _b[1], dayOfMonth = _b[2];
        // Create the date object with the proper timezone handling
        // We'll set it to noon in local time to avoid timezone issues
        var selectedDate = new Date(year, month - 1, dayOfMonth, 12, 0, 0, 0); // Month is 0-indexed in JS Date, and setting time to noon
        // First check if this date is disabled (outside min/max range)
        if ((0, utils_1.isDateDisabled)(selectedDate, config)) {
            console.log('Date is disabled, ignoring selection:', selectedDate.toISOString());
            return;
        }
        // Use the new direct date selection method
        this._handleDateSelection(selectedDate, clickedButton);
    };
    /**
     * Toggle between days, months, and years view
     */
    KTDatepickerCalendar.prototype._toggleMonthYearView = function () {
        var state = this._stateManager.getState();
        var newMode;
        switch (state.viewMode) {
            case 'days':
                newMode = 'months';
                break;
            case 'months':
                newMode = 'years';
                break;
            case 'years':
                newMode = 'days';
                break;
            default:
                newMode = 'days';
        }
        this._stateManager.setViewMode(newMode);
        this._renderCalendarView();
    };
    /**
     * Update view mode based on state change
     */
    KTDatepickerCalendar.prototype._updateViewMode = function () {
        this._renderCalendarView();
    };
    /**
     * Go to today's date
     */
    KTDatepickerCalendar.prototype._goToToday = function () {
        var today = new Date();
        this._stateManager.setCurrentDate(today);
        this._renderCalendarView();
    };
    /**
     * Clear date selection
     */
    KTDatepickerCalendar.prototype._clearSelection = function () {
        this._stateManager.setSelectedDate(null);
        this._updateCalendarView();
    };
    /**
     * Apply current selection and close dropdown
     */
    KTDatepickerCalendar.prototype._applySelection = function () {
        var state = this._stateManager.getState();
        var config = this._stateManager.getConfig();
        // For range selection, check if range selection is in progress
        if (config.range && state.isRangeSelectionInProgress) {
            console.log('Apply button clicked, but range selection in progress - keeping dropdown open');
            // Don't close when range selection is in progress
            return;
        }
        // Close dropdown for other cases
        this._stateManager.setOpen(false);
    };
    /**
     * Handle time input changes
     */
    KTDatepickerCalendar.prototype._handleTimeChange = function () {
        if (!this._dropdownElement)
            return;
        var timeContainer = this._dropdownElement.querySelector('.kt-datepicker-calendar-time-container');
        if (!timeContainer)
            return;
        var hourInput = timeContainer.querySelector('input[aria-label="Hour"]');
        var minuteInput = timeContainer.querySelector('input[aria-label="Minute"]');
        var secondInput = timeContainer.querySelector('input[aria-label="Second"]');
        var amButton = timeContainer.querySelector('button[aria-label="AM"]');
        var pmButton = timeContainer.querySelector('button[aria-label="PM"]');
        if (!hourInput || !minuteInput || !secondInput)
            return;
        // Get input values
        var hours = parseInt(hourInput.value, 10);
        var minutes = parseInt(minuteInput.value, 10);
        var seconds = parseInt(secondInput.value, 10);
        // Validate values
        var isValidHours = !isNaN(hours) && hours >= 0 && hours <= 23;
        var isValidMinutes = !isNaN(minutes) && minutes >= 0 && minutes <= 59;
        var isValidSeconds = !isNaN(seconds) && seconds >= 0 && seconds <= 59;
        if (!isValidHours || !isValidMinutes || !isValidSeconds)
            return;
        // Check if using 12-hour format and adjust for AM/PM
        var isPM = amButton && amButton.classList.contains('bg-blue-500');
        if (isPM && hours < 12) {
            hours += 12;
        }
        else if (!isPM && hours === 12) {
            hours = 0;
        }
        // Update time in state
        this._stateManager.setSelectedTime({
            hours: hours,
            minutes: minutes,
            seconds: seconds,
            ampm: isPM ? 'PM' : 'AM',
        });
        // Update selected date with new time if a date is selected
        var state = this._stateManager.getState();
        if (state.selectedDate) {
            var updatedDate = new Date(state.selectedDate);
            updatedDate.setHours(hours, minutes, seconds, 0);
            this._stateManager.setSelectedDate(updatedDate);
        }
    };
    /**
     * Set AM/PM selection
     *
     * @param period - 'AM' or 'PM'
     */
    KTDatepickerCalendar.prototype._setAmPm = function (period) {
        if (!this._dropdownElement)
            return;
        var timeContainer = this._dropdownElement.querySelector('.py-3.border-t');
        if (!timeContainer)
            return;
        var amButton = timeContainer.querySelector('button[aria-label="AM"]');
        var pmButton = timeContainer.querySelector('button[aria-label="PM"]');
        if (!amButton || !pmButton)
            return;
        // Update button states
        if (period === 'AM') {
            amButton.classList.add('bg-blue-500', 'text-white', 'border-blue-500');
            amButton.classList.remove('bg-gray-50', 'hover:bg-gray-100');
            pmButton.classList.remove('bg-blue-500', 'text-white', 'border-blue-500');
            pmButton.classList.add('bg-gray-50', 'hover:bg-gray-100');
        }
        else {
            amButton.classList.remove('bg-blue-500', 'text-white', 'border-blue-500');
            amButton.classList.add('bg-gray-50', 'hover:bg-gray-100');
            pmButton.classList.add('bg-blue-500', 'text-white', 'border-blue-500');
            pmButton.classList.remove('bg-gray-50', 'hover:bg-gray-100');
        }
        // Update time
        this._handleTimeChange();
    };
    /**
     * Select a month
     *
     * @param month - Month index (0-11)
     */
    KTDatepickerCalendar.prototype._selectMonth = function (month) {
        var state = this._stateManager.getState();
        var config = this._stateManager.getConfig();
        var newDate = new Date(state.currentDate);
        newDate.setMonth(month);
        this._stateManager.setCurrentDate(newDate);
        // Only change view mode if keepViewModeOnSelection is false
        if (!config.keepViewModeOnSelection) {
            this._stateManager.setViewMode('days');
        }
        this._renderCalendarView();
    };
    /**
     * Select a year
     *
     * @param year - Year value
     */
    KTDatepickerCalendar.prototype._selectYear = function (year) {
        var state = this._stateManager.getState();
        var config = this._stateManager.getConfig();
        var newDate = new Date(state.currentDate);
        newDate.setFullYear(year);
        this._stateManager.setCurrentDate(newDate);
        // Only change view mode if keepViewModeOnSelection is false
        if (!config.keepViewModeOnSelection) {
            this._stateManager.setViewMode('months');
        }
        this._renderCalendarView();
    };
    /**
     * Update calendar view to reflect state changes
     */
    KTDatepickerCalendar.prototype._updateCalendarView = function () {
        this._renderCalendarView();
        this._updateTimeDisplay();
    };
    /**
     * Update time inputs to reflect current time selection
     */
    KTDatepickerCalendar.prototype._updateTimeDisplay = function () {
        if (!this._dropdownElement)
            return;
        var state = this._stateManager.getState();
        var config = this._stateManager.getConfig();
        // Skip if time is not enabled
        if (!config.enableTime)
            return;
        var timeContainer = this._dropdownElement.querySelector('.py-3.border-t');
        if (!timeContainer)
            return;
        var hourInput = timeContainer.querySelector('input[aria-label="Hour"]');
        var minuteInput = timeContainer.querySelector('input[aria-label="Minute"]');
        var secondInput = timeContainer.querySelector('input[aria-label="Second"]');
        var amButton = timeContainer.querySelector('button[aria-label="AM"]');
        var pmButton = timeContainer.querySelector('button[aria-label="PM"]');
        // Get time from selected date or default to current time
        var hours = 0;
        var minutes = 0;
        var seconds = 0;
        var isAM = true;
        if (state.selectedTime) {
            hours = state.selectedTime.hours;
            minutes = state.selectedTime.minutes;
            seconds = state.selectedTime.seconds;
            isAM = state.selectedTime.ampm === 'AM';
        }
        else if (state.selectedDate) {
            hours = state.selectedDate.getHours();
            minutes = state.selectedDate.getMinutes();
            seconds = state.selectedDate.getSeconds();
            isAM = hours < 12;
        }
        else {
            var now = new Date();
            hours = now.getHours();
            minutes = now.getMinutes();
            seconds = now.getSeconds();
            isAM = hours < 12;
        }
        // Adjust for 12-hour display if needed
        var displayHours = hours;
        if (hourInput && config.timeFormat.includes('h')) {
            displayHours = hours % 12;
            if (displayHours === 0)
                displayHours = 12;
        }
        // Update input values
        if (hourInput)
            hourInput.value =
                config.forceLeadingZero && displayHours < 10
                    ? "0".concat(displayHours)
                    : "".concat(displayHours);
        if (minuteInput)
            minuteInput.value =
                config.forceLeadingZero && minutes < 10 ? "0".concat(minutes) : "".concat(minutes);
        if (secondInput)
            secondInput.value =
                config.forceLeadingZero && seconds < 10 ? "0".concat(seconds) : "".concat(seconds);
        // Update AM/PM buttons
        if (amButton && pmButton) {
            if (isAM) {
                amButton.classList.add('bg-blue-500', 'text-white', 'border-blue-500');
                amButton.classList.remove('bg-gray-50', 'hover:bg-gray-100');
                pmButton.classList.remove('bg-blue-500', 'text-white', 'border-blue-500');
                pmButton.classList.add('bg-gray-50', 'hover:bg-gray-100');
            }
            else {
                amButton.classList.remove('bg-blue-500', 'text-white', 'border-blue-500');
                amButton.classList.add('bg-gray-50', 'hover:bg-gray-100');
                pmButton.classList.add('bg-blue-500', 'text-white', 'border-blue-500');
                pmButton.classList.remove('bg-gray-50', 'hover:bg-gray-100');
            }
        }
    };
    /**
     * Show the calendar dropdown
     */
    KTDatepickerCalendar.prototype.show = function () {
        if (!this._dropdownElement || this._isVisible)
            return;
        // Ensure we're in days view
        var state = this._stateManager.getState();
        if (state.viewMode !== 'days') {
            this._stateManager.setViewMode('days');
        }
        // Render calendar before showing
        this._renderCalendarView();
        this._updateTimeDisplay();
        // Show dropdown using dropdown manager
        if (this._dropdownManager) {
            this._dropdownManager.open();
            this._isVisible = true;
        }
    };
    /**
     * Hide the calendar dropdown
     */
    KTDatepickerCalendar.prototype.hide = function () {
        if (!this._dropdownElement || !this._isVisible)
            return;
        // Hide dropdown using dropdown manager
        if (this._dropdownManager) {
            this._dropdownManager.close();
            this._isVisible = false;
        }
    };
    /**
     * Update dropdown position
     */
    KTDatepickerCalendar.prototype.updatePosition = function () {
        if (this._dropdownManager) {
            this._dropdownManager.updatePosition();
        }
    };
    /**
     * Clear range hover classes from all day cells
     */
    KTDatepickerCalendar.prototype._clearRangeHoverClasses = function () {
        if (!this._calendarContainer)
            return;
        // Find all day cells with hover classes across all month containers
        var hoverCells = this._calendarContainer.querySelectorAll('.bg-blue-50, .text-blue-600, button[data-hover-date="true"]');
        hoverCells.forEach(function (cell) {
            cell.classList.remove('bg-blue-50', 'text-blue-600');
        });
    };
    /**
     * Apply hover effect to show potential range selection
     *
     * @param startDate - Start date of the range
     * @param hoverDate - Current date being hovered
     */
    KTDatepickerCalendar.prototype._applyRangeHoverEffect = function (startDate, hoverDate) {
        var _this = this;
        if (!this._calendarContainer)
            return;
        // Clear any existing hover effects first
        this._clearRangeHoverClasses();
        // Normalize dates to midnight for comparison
        var startDateMidnight = new Date(startDate);
        startDateMidnight.setHours(0, 0, 0, 0);
        var hoverDateMidnight = new Date(hoverDate);
        hoverDateMidnight.setHours(0, 0, 0, 0);
        // Ensure proper order for comparison (start date <= end date)
        var rangeStart = startDateMidnight <= hoverDateMidnight
            ? startDateMidnight
            : hoverDateMidnight;
        var rangeEnd = startDateMidnight <= hoverDateMidnight
            ? hoverDateMidnight
            : startDateMidnight;
        // Generate all dates in the range as ISO strings (YYYY-MM-DD)
        var dateRangeISOStrings = [];
        var currentDate = new Date(rangeStart);
        while (currentDate <= rangeEnd) {
            // Format as YYYY-MM-DD
            var year = currentDate.getFullYear();
            var month = String(currentDate.getMonth() + 1).padStart(2, '0');
            var day = String(currentDate.getDate()).padStart(2, '0');
            dateRangeISOStrings.push("".concat(year, "-").concat(month, "-").concat(day));
            // Move to the next day
            currentDate.setDate(currentDate.getDate() + 1);
        }
        // Apply hover effect to all day cells in the range using the date-id attribute
        dateRangeISOStrings.forEach(function (dateStr) {
            // Find the day cell with matching date-id
            var dayCells = _this._calendarContainer.querySelectorAll("button[data-date-id=\"".concat(dateStr, "\"]"));
            dayCells.forEach(function (cell) {
                // Skip if this is already a selected date (has blue background)
                if (cell.classList.contains('bg-blue-600'))
                    return;
                // Apply hover effect
                cell.classList.add('bg-blue-50', 'text-blue-600');
            });
        });
    };
    return KTDatepickerCalendar;
}());
exports.KTDatepickerCalendar = KTDatepickerCalendar;


/***/ }),

/***/ 9386:
/***/ (function(__unused_webpack_module, exports) {


/**
 * KTUI - Free & Open-Source Tailwind UI Components by Keenthemes
 * Copyright 2025 by Keenthemes Inc
 */
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.KTSelectState = exports.DefaultConfig = void 0;
exports.DefaultConfig = {
    // ...other config options
    loadMoreText: 'Load more...',
    // General Display
    debug: false,
    placeholder: 'Select an option', // Default placeholder text when no option is selected
    // Data Handling
    items: [], // Static list of options
    isLoading: false, // Indicates if options are being loaded asynchronously
    onFetch: null, // Callback function to fetch options asynchronously
    // Remote Data Configuration
    remote: false, // Enable/disable remote data fetching
    dataUrl: null, // URL to fetch options from
    apiDataProperty: null, // Property in the response object that contains the options
    remoteErrorMessage: 'Failed to load data', // Error message to display if remote data fetch fails
    // Field Mapping
    dataValueField: null, // Property in the option object that contains the value (default: 'id')
    dataFieldText: null, // Property in the option object that contains the text (default: 'title')
    // Search Configuration
    searchParam: '', // Query parameter for API search requests
    searchDebounce: 300, // Debounce delay for search (in ms)
    // Pagination Configuration
    pagination: false, // Enable/disable pagination for remote data
    paginationLimit: 10, // Items per page
    paginationPageParam: 'page', // Parameter name for page number
    paginationLimitParam: 'limit', // Parameter name for items per page
    paginationTotalParam: 'total', // Parameter name for total items
    // Selection Behavior
    allowClear: false, // Allow clearing the selection (if true, an empty value can be set)
    multiple: false, // Enable/disable multi-select
    maxSelections: null, // Maximum number of selections allowed in multi-select mode (null for unlimited)
    disabled: false, // Disable the select component
    isRequired: false, // Make selection required
    // Search Functionality
    enableSearch: false, // Enable/disable search functionality within the dropdown
    searchPlaceholder: 'Search...', // Placeholder text for the search input
    searchAutofocus: true, // Autofocus on search input when dropdown opens
    searchMinLength: 0, // Minimum characters required to trigger search
    searchMaxItems: 50, // Maximum number of search results to display
    searchEmpty: 'No results', // Text to display when no search results are found
    clearSearchOnClose: true, // Clear search input when dropdown closes
    // Multi-Select Display
    selectAllText: 'Select all', // Text for the "Select All" option (if implemented)
    clearAllText: 'Clear all', // Text for the "Clear All" option (if implemented)
    showSelectedCount: true, // Show the number of selected options in multi-select mode
    renderSelected: null, // Custom function to render the selected value(s) in the display area
    // Accessibility & Usability
    label: 'Select an option', // Label for the select component (for screen readers)
    height: 250, // Maximum height of the dropdown menu in pixels (if exceeded, a scrollbar will appear)
    // Dropdown Configuration
    dropdownZindex: 105, // Initial z-index value for the dropdown
    dropdownContainer: null, // Container element for the dropdown
    dropdownPlacement: null,
    dropdownFlip: false,
    dropdownPreventOverflow: false,
    dropdownStrategy: null,
    dropdownWidth: null, // Custom width for dropdown (e.g., '300px'), null to match toggle element width
    // New Config
    dropdownTemplate: '',
};
var KTSelectState = /** @class */ (function () {
    function KTSelectState(config) {
        this._selectedOptions = [];
        this._config = this._initDefaultConfig(config);
    }
    KTSelectState.prototype._initDefaultConfig = function (config) {
        return __assign(__assign(__assign({}, exports.DefaultConfig), config), config.config);
    };
    KTSelectState.prototype.setItems = function (items, query) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            if (items) {
                _this._config.items = items;
                resolve();
            }
            else if (_this._config.dataUrl) {
                _this._fetchRemoteData(query)
                    .then(resolve) // Resolve after _fetchRemoteData completes
                    .catch(reject);
            }
            else if (_this._config.onFetch) {
                _this._config.isLoading = true;
                _this._config
                    .onFetch(query)
                    .then(function (items) {
                    _this._config.items = items;
                    resolve(); // Resolve after onFetch completes
                })
                    .catch(function (error) {
                    console.error('Error fetching data:', error);
                    reject(error); // Reject on error
                })
                    .finally(function () {
                    _this._config.isLoading = false;
                });
            }
            else {
                resolve();
            }
        });
    };
    KTSelectState.prototype._fetchRemoteData = function (query) {
        var _this = this;
        this._config.isLoading = true; // Show loading indicator
        var url = this._config.dataUrl;
        if (query) {
            url += "?".concat(this._config.searchParam, "=").concat(encodeURIComponent(query));
        }
        return fetch(url)
            .then(function (response) { return response.json(); })
            .then(function (data) {
            if (_this._config.apiDataProperty) {
                // Extract the data property from the response
                if (_this._config.apiDataProperty in data) {
                    data = data[_this._config.apiDataProperty];
                }
                else {
                    console.error('Error fetching data:', "Property '".concat(_this._config.apiDataProperty, "' not found in response"));
                    return;
                }
            }
            _this._config.items = data;
        })
            .catch(function (error) {
            console.error('Error fetching data:', error);
            // Handle error (e.g., display an error message)
        })
            .finally(function () {
            _this._config.isLoading = false; // Hide loading indicator
        });
    };
    KTSelectState.prototype.getItems = function () {
        return this._config.items || [];
    };
    KTSelectState.prototype.setItemsFromOptions = function (options) {
        this._config.items = options.map(function (option) {
            var item = {
                id: option.value,
                title: option.textContent || option.value, // Use value as fallback for title
                // 'selected' property will be definitively set by _preSelectOptions
                disabled: option.disabled,
            };
            return item;
        });
        // The 'selected' status of these items and the overall component selection state
        // are now fully managed by _preSelectOptions in KTSelect during initialization.
    };
    KTSelectState.prototype.getConfig = function () {
        return this._config;
    };
    KTSelectState.prototype.setSelectedOptions = function (value) {
        if (this._config.multiple &&
            typeof value === 'string' &&
            !this._selectedOptions.includes(value)) {
            this._selectedOptions.push(value);
        }
        else if (!this._config.multiple) {
            // For single select, replace the previous selection with the new one
            this._selectedOptions = typeof value === 'string' ? [value] : [value[0]];
        }
        else if (this._config.multiple && Array.isArray(value)) {
            // For multiple select with array input, use the provided array
            this._selectedOptions = __spreadArray([], value, true);
        }
    };
    KTSelectState.prototype.toggleSelectedOptions = function (value) {
        if (!this._config.multiple) {
            // For non-multiple, always set the new value
            this._selectedOptions = [value];
            return;
        }
        // For multiple selection, toggle the value
        var index = this._selectedOptions.indexOf(value);
        if (index > -1) {
            this._selectedOptions.splice(index, 1);
        }
        else {
            this._selectedOptions.push(value);
        }
    };
    KTSelectState.prototype.getSelectedOptions = function () {
        return this._selectedOptions;
    };
    KTSelectState.prototype.isSelected = function (value) {
        return this._selectedOptions.includes(value);
    };
    KTSelectState.prototype.modifyConfig = function (config) {
        this._config = __assign(__assign({}, this._config), config);
    };
    return KTSelectState;
}());
exports.KTSelectState = KTSelectState;


/***/ }),

/***/ 9619:
/***/ (function(__unused_webpack_module, exports) {


/**
 * KTUI - Free & Open-Source Tailwind UI Components by Keenthemes
 * Copyright 2025 by Keenthemes Inc
 */
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.placeholderTemplate = exports.inputWrapperTemplate = exports.datepickerContainerTemplate = void 0;
exports.segmentedDateInputTemplate = segmentedDateInputTemplate;
exports.segmentedDateRangeInputTemplate = segmentedDateRangeInputTemplate;
exports.calendarGridTemplate = calendarGridTemplate;
exports.dayTemplate = dayTemplate;
exports.monthYearSelectTemplate = monthYearSelectTemplate;
exports.monthSelectionTemplate = monthSelectionTemplate;
exports.yearSelectionTemplate = yearSelectionTemplate;
exports.displayWrapperTemplate = displayWrapperTemplate;
exports.displayElementTemplate = displayElementTemplate;
/**
 * Main container template for the datepicker dropdown
 */
exports.datepickerContainerTemplate = "\n  <div class=\"bg-white rounded-lg shadow-lg border border-gray-200 overflow-hidden\">\n    <div class=\"border-b border-gray-200 pb-3 mb-3\">\n      <div class=\"flex items-center justify-between px-3 pt-3\">\n        <button type=\"button\" class=\"p-1 rounded hover:bg-gray-100 text-gray-500 focus:outline-none focus:ring-2 focus:ring-blue-500\" aria-label=\"Previous Month\">\n          <svg xmlns=\"http://www.w3.org/2000/svg\" width=\"16\" height=\"16\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\">\n            <polyline points=\"15 18 9 12 15 6\"></polyline>\n          </svg>\n        </button>\n        <div class=\"flex items-center justify-center\">\n          <select class=\"bg-transparent border border-gray-200 rounded px-2 py-1 mr-1 text-sm focus:outline-none focus:ring-2 focus:ring-blue-500\" aria-label=\"Select Month\"></select>\n          <select class=\"bg-transparent border border-gray-200 rounded px-2 py-1 ml-1 text-sm focus:outline-none focus:ring-2 focus:ring-blue-500\" aria-label=\"Select Year\"></select>\n          <span class=\"font-medium px-2 py-1 rounded hover:bg-gray-100 cursor-pointer\"></span>\n        </div>\n        <button type=\"button\" class=\"p-1 rounded hover:bg-gray-100 text-gray-500 focus:outline-none focus:ring-2 focus:ring-blue-500\" aria-label=\"Next Month\">\n          <svg xmlns=\"http://www.w3.org/2000/svg\" width=\"16\" height=\"16\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\">\n            <polyline points=\"9 18 15 12 9 6\"></polyline>\n          </svg>\n        </button>\n      </div>\n    </div>\n    <div class=\"flex flex-wrap gap-4\"></div>\n    <div class=\"py-3 border-t border-gray-200 mt-3 hidden\">\n      <div class=\"text-sm font-medium text-gray-600 mb-2 text-center\">Time</div>\n      <div class=\"flex items-center justify-center gap-2\">\n        <div class=\"relative w-12\">\n          <input type=\"text\" class=\"w-full py-1.5 px-1.5 text-center border border-gray-300 rounded text-sm focus:outline-none focus:ring-2 focus:ring-blue-500\" min=\"0\" max=\"23\" aria-label=\"Hour\">\n        </div>\n        <span class=\"text-xl font-medium text-gray-500 leading-none\">:</span>\n        <div class=\"relative w-12\">\n          <input type=\"text\" class=\"w-full py-1.5 px-1.5 text-center border border-gray-300 rounded text-sm focus:outline-none focus:ring-2 focus:ring-blue-500\" min=\"0\" max=\"59\" aria-label=\"Minute\">\n        </div>\n        <span class=\"text-xl font-medium text-gray-500 leading-none\">:</span>\n        <div class=\"relative w-12\">\n          <input type=\"text\" class=\"w-full py-1.5 px-1.5 text-center border border-gray-300 rounded text-sm focus:outline-none focus:ring-2 focus:ring-blue-500\" min=\"0\" max=\"59\" aria-label=\"Second\">\n        </div>\n        <div class=\"flex flex-col gap-1\">\n          <button type=\"button\" class=\"px-2 py-1 text-xs border border-gray-300 rounded-t bg-gray-50 hover:bg-gray-100 focus:outline-none focus:ring-2 focus:ring-blue-500 text-center\" aria-label=\"AM\"></button>\n          <button type=\"button\" class=\"px-2 py-1 text-xs border border-gray-300 rounded-b bg-gray-50 hover:bg-gray-100 focus:outline-none focus:ring-2 focus:ring-blue-500 text-center\" aria-label=\"PM\"></button>\n        </div>\n      </div>\n    </div>\n    <div class=\"flex justify-between pt-3 border-t border-gray-200 mt-3 px-3 pb-3\">\n      <button type=\"button\" class=\"px-3 py-1.5 text-sm border border-gray-300 rounded bg-gray-50 hover:bg-gray-100 focus:outline-none focus:ring-2 focus:ring-blue-500\">Today</button>\n      <button type=\"button\" class=\"px-3 py-1.5 text-sm border border-gray-300 rounded bg-gray-50 hover:bg-gray-100 focus:outline-none focus:ring-2 focus:ring-blue-500\">Clear</button>\n      <button type=\"button\" class=\"px-3 py-1.5 text-sm border border-blue-500 rounded bg-blue-500 text-white hover:bg-blue-600 focus:outline-none focus:ring-2 focus:ring-blue-500\">Apply</button>\n    </div>\n  </div>\n";
/**
 * Input wrapper template with calendar icon
 */
exports.inputWrapperTemplate = "\n  <div class=\"relative flex items-center\">\n    <div class=\"flex-grow segmented-input-container\"></div>\n    <button type=\"button\" class=\"absolute right-2 p-1 text-gray-400 hover:text-gray-600 focus:outline-none focus:ring-2 focus:ring-blue-500 calendar-toggle-btn\" aria-label=\"Toggle Calendar\">\n      <svg xmlns=\"http://www.w3.org/2000/svg\" width=\"16\" height=\"16\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\">\n        <rect x=\"3\" y=\"4\" width=\"18\" height=\"18\" rx=\"2\" ry=\"2\"></rect>\n        <line x1=\"16\" y1=\"2\" x2=\"16\" y2=\"6\"></line>\n        <line x1=\"8\" y1=\"2\" x2=\"8\" y2=\"6\"></line>\n        <line x1=\"3\" y1=\"10\" x2=\"21\" y2=\"10\"></line>\n      </svg>\n    </button>\n  </div>\n";
/**
 * Template for segmented date input
 *
 * @param format - Date format string (e.g., 'dd/MM/yyyy')
 * @returns HTML for segmented input
 */
function segmentedDateInputTemplate(format) {
    // Parse the format to determine the order of segments and separators
    var formatSegments = parseFormatString(format);
    var segments = [];
    var separators = [];
    // Extract segments and separators
    for (var i = 0; i < formatSegments.length; i++) {
        var seg = formatSegments[i];
        if (seg.type === 'separator') {
            separators.push(seg.value);
        }
        else {
            segments.push(seg);
        }
    }
    // Ensure we have exactly 3 segments (day, month, year) and 2 separators
    if (segments.length !== 3 || separators.length !== 2) {
        console.warn('Invalid date format for segmented input:', format);
        // Fall back to default MM/dd/yyyy
        return getDefaultSegmentedTemplate();
    }
    // Create the template based on the parsed format
    return "\n    <div class=\"flex items-center bg-transparent text-sm\">\n      <div\n        class=\"".concat(getSegmentWidthClass(segments[0].type), " bg-transparent text-center text-gray-900 cursor-pointer segment-part hover:bg-gray-100 rounded-sm px-1 py-0.5\"\n        data-segment=\"").concat(getSegmentName(segments[0].type), "\"\n        tabindex=\"0\"\n        role=\"button\"\n        aria-label=\"").concat(getSegmentLabel(segments[0].type), "\">").concat(segments[0].placeholder, "</div>\n      <span class=\"text-gray-500 mx-0.5\">").concat(separators[0], "</span>\n      <div\n        class=\"").concat(getSegmentWidthClass(segments[1].type), " bg-transparent text-center text-gray-900 cursor-pointer segment-part hover:bg-gray-100 rounded-sm px-1 py-0.5\"\n        data-segment=\"").concat(getSegmentName(segments[1].type), "\"\n        tabindex=\"0\"\n        role=\"button\"\n        aria-label=\"").concat(getSegmentLabel(segments[1].type), "\">").concat(segments[1].placeholder, "</div>\n      <span class=\"text-gray-500 mx-0.5\">").concat(separators[1], "</span>\n      <div\n        class=\"").concat(getSegmentWidthClass(segments[2].type), " bg-transparent text-center text-gray-900 cursor-pointer segment-part hover:bg-gray-100 rounded-sm px-1 py-0.5\"\n        data-segment=\"").concat(getSegmentName(segments[2].type), "\"\n        tabindex=\"0\"\n        role=\"button\"\n        aria-label=\"").concat(getSegmentLabel(segments[2].type), "\">").concat(segments[2].placeholder, "</div>\n    </div>\n  ");
}
/**
 * Template for segmented date range input
 *
 * @param format - Date format string (e.g., 'dd/MM/yyyy')
 * @param rangeSeparator - Separator between start and end dates
 * @returns HTML for segmented range input
 */
function segmentedDateRangeInputTemplate(format, rangeSeparator) {
    if (rangeSeparator === void 0) { rangeSeparator = ' - '; }
    // Parse the format to determine the order of segments and separators
    var formatSegments = parseFormatString(format);
    var segments = [];
    var separators = [];
    // Extract segments and separators
    for (var i = 0; i < formatSegments.length; i++) {
        var seg = formatSegments[i];
        if (seg.type === 'separator') {
            separators.push(seg.value);
        }
        else {
            segments.push(seg);
        }
    }
    // Ensure we have exactly 3 segments (day, month, year) and 2 separators
    if (segments.length !== 3 || separators.length !== 2) {
        console.warn('Invalid date format for segmented range input:', format);
        // Fall back to default MM/dd/yyyy
        return getDefaultSegmentedRangeTemplate(rangeSeparator);
    }
    // Create the template based on the parsed format
    return "\n    <div class=\"flex items-center w-full\">\n      <div class=\"flex items-center bg-transparent text-sm\">\n        <div\n          class=\"".concat(getSegmentWidthClass(segments[0].type), " bg-transparent text-center text-gray-900 cursor-pointer segment-part hover:bg-gray-100 rounded-sm px-1 py-0.5\"\n          data-segment=\"start-").concat(getSegmentName(segments[0].type), "\"\n          tabindex=\"0\"\n          role=\"button\"\n          aria-label=\"Start ").concat(getSegmentLabel(segments[0].type), "\">").concat(segments[0].placeholder, "</div>\n        <span class=\"text-gray-500 mx-0.5\">").concat(separators[0], "</span>\n        <div\n          class=\"").concat(getSegmentWidthClass(segments[1].type), " bg-transparent text-center text-gray-900 cursor-pointer segment-part hover:bg-gray-100 rounded-sm px-1 py-0.5\"\n          data-segment=\"start-").concat(getSegmentName(segments[1].type), "\"\n          tabindex=\"0\"\n          role=\"button\"\n          aria-label=\"Start ").concat(getSegmentLabel(segments[1].type), "\">").concat(segments[1].placeholder, "</div>\n        <span class=\"text-gray-500 mx-0.5\">").concat(separators[1], "</span>\n        <div\n          class=\"").concat(getSegmentWidthClass(segments[2].type), " bg-transparent text-center text-gray-900 cursor-pointer segment-part hover:bg-gray-100 rounded-sm px-1 py-0.5\"\n          data-segment=\"start-").concat(getSegmentName(segments[2].type), "\"\n          tabindex=\"0\"\n          role=\"button\"\n          aria-label=\"Start ").concat(getSegmentLabel(segments[2].type), "\">").concat(segments[2].placeholder, "</div>\n      </div>\n      <span class=\"mx-1 text-gray-500\">").concat(rangeSeparator, "</span>\n      <div class=\"flex items-center bg-transparent text-sm\">\n        <div\n          class=\"").concat(getSegmentWidthClass(segments[0].type), " bg-transparent text-center text-gray-900 cursor-pointer segment-part hover:bg-gray-100 rounded-sm px-1 py-0.5\"\n          data-segment=\"end-").concat(getSegmentName(segments[0].type), "\"\n          tabindex=\"0\"\n          role=\"button\"\n          aria-label=\"End ").concat(getSegmentLabel(segments[0].type), "\">").concat(segments[0].placeholder, "</div>\n        <span class=\"text-gray-500 mx-0.5\">").concat(separators[0], "</span>\n        <div\n          class=\"").concat(getSegmentWidthClass(segments[1].type), " bg-transparent text-center text-gray-900 cursor-pointer segment-part hover:bg-gray-100 rounded-sm px-1 py-0.5\"\n          data-segment=\"end-").concat(getSegmentName(segments[1].type), "\"\n          tabindex=\"0\"\n          role=\"button\"\n          aria-label=\"End ").concat(getSegmentLabel(segments[1].type), "\">").concat(segments[1].placeholder, "</div>\n        <span class=\"text-gray-500 mx-0.5\">").concat(separators[1], "</span>\n        <div\n          class=\"").concat(getSegmentWidthClass(segments[2].type), " bg-transparent text-center text-gray-900 cursor-pointer segment-part hover:bg-gray-100 rounded-sm px-1 py-0.5\"\n          data-segment=\"end-").concat(getSegmentName(segments[2].type), "\"\n          tabindex=\"0\"\n          role=\"button\"\n          aria-label=\"End ").concat(getSegmentLabel(segments[2].type), "\">").concat(segments[2].placeholder, "</div>\n      </div>\n    </div>\n  ");
}
/**
 * Parse a date format string into segments and separators
 *
 * @param format - Date format string (e.g., 'dd/MM/yyyy')
 * @returns Array of parsed segments with type, placeholder and value
 */
function parseFormatString(format) {
    var result = [];
    var currentType = '';
    var currentValue = '';
    // Helper to add a segment to the result
    var addSegment = function () {
        if (!currentValue)
            return;
        if (/^d+$/.test(currentValue)) {
            result.push({
                type: 'day',
                value: currentValue,
                placeholder: currentValue.length === 1 ? 'd' : 'dd',
            });
        }
        else if (/^M+$/.test(currentValue)) {
            result.push({
                type: 'month',
                value: currentValue,
                placeholder: currentValue.length === 1 ? 'M' : 'MM',
            });
        }
        else if (/^y+$/.test(currentValue)) {
            result.push({
                type: 'year',
                value: currentValue,
                placeholder: currentValue.length <= 2 ? 'yy' : 'yyyy',
            });
        }
        else {
            // This is a separator
            result.push({
                type: 'separator',
                value: currentValue,
            });
        }
        currentValue = '';
    };
    // Process each character in the format string
    for (var i = 0; i < format.length; i++) {
        var char = format[i];
        if (/[dMy]/.test(char)) {
            // Date part characters
            if (currentType === char) {
                // Continue the current segment
                currentValue += char;
            }
            else {
                // Start a new segment
                addSegment();
                currentType = char;
                currentValue = char;
            }
        }
        else {
            // Separator character
            if (currentValue) {
                addSegment();
            }
            currentType = '';
            currentValue = char;
            addSegment();
        }
    }
    // Add the last segment
    addSegment();
    return result;
}
/**
 * Get a suitable CSS width class based on segment type
 *
 * @param type - Segment type (day, month, year)
 * @returns CSS class for width
 */
function getSegmentWidthClass(type) {
    switch (type) {
        case 'day':
            return 'w-7';
        case 'month':
            return 'w-7';
        case 'year':
            return 'w-12';
        default:
            return 'w-7';
    }
}
/**
 * Get the segment name to be used in data-segment attribute
 *
 * @param type - Segment type (day, month, year)
 * @returns Segment name
 */
function getSegmentName(type) {
    return type;
}
/**
 * Get a human-readable label for the segment
 *
 * @param type - Segment type (day, month, year)
 * @returns Human-readable label
 */
function getSegmentLabel(type) {
    return type.charAt(0).toUpperCase() + type.slice(1);
}
/**
 * Get the default segmented date input template (MM/dd/yyyy)
 *
 * @returns Default template HTML
 */
function getDefaultSegmentedTemplate() {
    return "\n    <div class=\"flex items-center bg-transparent text-sm\">\n      <div\n        class=\"w-7 bg-transparent text-center text-gray-900 cursor-pointer segment-part hover:bg-gray-100 rounded-sm px-1 py-0.5\"\n        data-segment=\"month\"\n        tabindex=\"0\"\n        role=\"button\"\n        aria-label=\"Month\">MM</div>\n      <span class=\"text-gray-500 mx-0.5\">/</span>\n      <div\n        class=\"w-7 bg-transparent text-center text-gray-900 cursor-pointer segment-part hover:bg-gray-100 rounded-sm px-1 py-0.5\"\n        data-segment=\"day\"\n        tabindex=\"0\"\n        role=\"button\"\n        aria-label=\"Day\">dd</div>\n      <span class=\"text-gray-500 mx-0.5\">/</span>\n      <div\n        class=\"w-12 bg-transparent text-center text-gray-900 cursor-pointer segment-part hover:bg-gray-100 rounded-sm px-1 py-0.5\"\n        data-segment=\"year\"\n        tabindex=\"0\"\n        role=\"button\"\n        aria-label=\"Year\">yyyy</div>\n    </div>\n  ";
}
/**
 * Get the default segmented date range input template (MM/dd/yyyy)
 *
 * @param rangeSeparator - Separator between start and end dates
 * @returns Default range template HTML
 */
function getDefaultSegmentedRangeTemplate(rangeSeparator) {
    if (rangeSeparator === void 0) { rangeSeparator = ' - '; }
    return "\n    <div class=\"flex items-center w-full\">\n      <div class=\"flex items-center bg-transparent text-sm\">\n        <div\n          class=\"w-7 bg-transparent text-center text-gray-900 cursor-pointer segment-part hover:bg-gray-100 rounded-sm px-1 py-0.5\"\n          data-segment=\"start-month\"\n          tabindex=\"0\"\n          role=\"button\"\n          aria-label=\"Start Month\">MM</div>\n        <span class=\"text-gray-500 mx-0.5\">/</span>\n        <div\n          class=\"w-7 bg-transparent text-center text-gray-900 cursor-pointer segment-part hover:bg-gray-100 rounded-sm px-1 py-0.5\"\n          data-segment=\"start-day\"\n          tabindex=\"0\"\n          role=\"button\"\n          aria-label=\"Start Day\">dd</div>\n        <span class=\"text-gray-500 mx-0.5\">/</span>\n        <div\n          class=\"w-12 bg-transparent text-center text-gray-900 cursor-pointer segment-part hover:bg-gray-100 rounded-sm px-1 py-0.5\"\n          data-segment=\"start-year\"\n          tabindex=\"0\"\n          role=\"button\"\n          aria-label=\"Start Year\">yyyy</div>\n      </div>\n      <span class=\"mx-1 text-gray-500\">".concat(rangeSeparator, "</span>\n      <div class=\"flex items-center bg-transparent text-sm\">\n        <div\n          class=\"w-7 bg-transparent text-center text-gray-900 cursor-pointer segment-part hover:bg-gray-100 rounded-sm px-1 py-0.5\"\n          data-segment=\"end-month\"\n          tabindex=\"0\"\n          role=\"button\"\n          aria-label=\"End Month\">MM</div>\n        <span class=\"text-gray-500 mx-0.5\">/</span>\n        <div\n          class=\"w-7 bg-transparent text-center text-gray-900 cursor-pointer segment-part hover:bg-gray-100 rounded-sm px-1 py-0.5\"\n          data-segment=\"end-day\"\n          tabindex=\"0\"\n          role=\"button\"\n          aria-label=\"End Day\">dd</div>\n        <span class=\"text-gray-500 mx-0.5\">/</span>\n        <div\n          class=\"w-12 bg-transparent text-center text-gray-900 cursor-pointer segment-part hover:bg-gray-100 rounded-sm px-1 py-0.5\"\n          data-segment=\"end-year\"\n          tabindex=\"0\"\n          role=\"button\"\n          aria-label=\"End Year\">yyyy</div>\n      </div>\n    </div>\n  ");
}
/**
 * Get an array of day names based on locale and format
 *
 * @param locale - Locale configuration
 * @param format - Format for day names ('long', 'short', or 'min')
 * @returns Array of day names
 */
function getDayNames(locale, format) {
    if (format === 'long') {
        return locale.dayNames;
    }
    else if (format === 'short') {
        return locale.dayNamesShort;
    }
    else {
        return locale.dayNamesMin;
    }
}
/**
 * Calendar grid template
 *
 * @param locale - Locale configuration for the datepicker
 * @param weekDayFormat - Format for the week day names ('long', 'short', or 'min')
 * @returns Calendar grid template HTML
 */
function calendarGridTemplate(locale, weekDayFormat) {
    // Get the day names based on the locale and format
    var dayNames = getDayNames(locale, weekDayFormat);
    // Start from the first day of the week based on locale
    var firstDay = locale.firstDayOfWeek;
    var orderedDayNames = __spreadArray(__spreadArray([], dayNames.slice(firstDay), true), dayNames.slice(0, firstDay), true);
    // Create the header with day names
    var headerCells = orderedDayNames
        .map(function (day) {
        return "<th class=\"py-2 text-center text-xs font-medium text-gray-500 uppercase w-10\">".concat(day, "</th>");
    })
        .join('');
    return "\n    <div class=\"calendar-month-container\">\n      <table class=\"w-full border-collapse calendar-grid\" role=\"grid\" aria-labelledby=\"datepicker-month\">\n        <thead>\n          <tr class=\"border-b border-gray-200\">\n            ".concat(headerCells, "\n          </tr>\n        </thead>\n        <tbody class=\"border-none\"></tbody>\n      </table>\n    </div>\n  ");
}
/**
 * Calendar day cell template
 *
 * @param day - Day number
 * @param month - Month number (0-11)
 * @param year - Year (4 digits)
 * @param isCurrentMonth - Whether the day is in the current month
 * @param isToday - Whether the day is today
 * @param isSelected - Whether the day is selected
 * @param isDisabled - Whether the day is disabled
 * @param isRangeStart - Whether the day is the start of a range
 * @param isRangeEnd - Whether the day is the end of a range
 * @param isInRange - Whether the day is within a selected range
 * @param isWeekend - Whether the day is a weekend
 * @returns Day cell HTML
 */
function dayTemplate(day, month, year, isCurrentMonth, isToday, isSelected, isDisabled, isRangeStart, isRangeEnd, isInRange, isWeekend) {
    if (month === void 0) { month = 0; }
    if (year === void 0) { year = 0; }
    if (isCurrentMonth === void 0) { isCurrentMonth = true; }
    if (isToday === void 0) { isToday = false; }
    if (isSelected === void 0) { isSelected = false; }
    if (isDisabled === void 0) { isDisabled = false; }
    if (isRangeStart === void 0) { isRangeStart = false; }
    if (isRangeEnd === void 0) { isRangeEnd = false; }
    if (isInRange === void 0) { isInRange = false; }
    if (isWeekend === void 0) { isWeekend = false; }
    // Base classes for day button
    var classes = 'w-full h-8 rounded-full flex items-center justify-center text-sm focus:outline-none focus:ring-2 focus:ring-blue-500 ';
    // Apply conditional classes
    if (!isCurrentMonth) {
        classes += 'current';
    }
    else if (isDisabled) {
        classes += 'text-gray-300 cursor-not-allowed ';
    }
    else if (isSelected || isRangeStart || isRangeEnd) {
        classes += 'bg-blue-600 text-white hover:bg-blue-700 ';
    }
    else if (isInRange) {
        classes += 'bg-blue-100 text-blue-800 hover:bg-blue-200 ';
    }
    else if (isToday) {
        classes += 'border border-blue-500 text-blue-600 hover:bg-blue-50 ';
    }
    else {
        classes +=
            'text-gray-700 hover:bg-gray-100 hover:bg-blue-50 hover:text-blue-600 ';
    }
    // Add weekend-specific styling
    if (isWeekend && !isSelected && !isRangeStart && !isRangeEnd && !isInRange) {
        classes += 'text-gray-500 ';
    }
    // Add attributes for hover states in range selection
    var hoverAttributes = isCurrentMonth && !isDisabled ? 'data-hover-date="true"' : '';
    // Create a date ID if month and year are provided
    var dateIdAttr = '';
    if (year > 0) {
        // Format: YYYY-MM-DD (ensures leading zeros for month and day)
        var monthStr = String(month + 1).padStart(2, '0'); // Add 1 since month is 0-indexed
        var dayStr = String(day).padStart(2, '0');
        var dateId = "".concat(year, "-").concat(monthStr, "-").concat(dayStr);
        dateIdAttr = "data-date-id=\"".concat(dateId, "\"");
    }
    return "\n    <td class=\"p-0.5\">\n      <button\n        type=\"button\"\n        class=\"".concat(classes.trim(), "\"\n        data-date=\"").concat(day, "\"\n        ").concat(dateIdAttr, "\n        ").concat(isDisabled ? 'disabled' : '', "\n        ").concat(!isCurrentMonth ? 'tabindex="-1"' : '', "\n        ").concat(hoverAttributes, "\n        aria-selected=\"").concat(isSelected, "\"\n        aria-current=\"").concat(isToday ? 'date' : 'false', "\"\n      >\n        ").concat(day, "\n      </button>\n    </td>\n  ");
}
/**
 * Month and year header template with buttons for toggling month/year view
 *
 * @param locale - Locale configuration
 * @param currentMonth - Current month (0-11)
 * @param currentYear - Current year
 * @returns Month and year header HTML
 */
function monthYearSelectTemplate(locale, currentMonth, currentYear) {
    return "\n    <div class=\"flex items-center justify-center space-x-2\">\n      <button type=\"button\"\n        class=\"month-selector px-2 py-1 rounded hover:bg-gray-100 focus:outline-none focus:ring-2 focus:ring-blue-500 text-gray-800 font-medium\"\n        aria-label=\"Select Month\">\n        ".concat(locale.monthNames[currentMonth], "\n      </button>\n      <button type=\"button\"\n        class=\"year-selector px-2 py-1 rounded hover:bg-gray-100 focus:outline-none focus:ring-2 focus:ring-blue-500 text-gray-800 font-medium\"\n        aria-label=\"Select Year\">\n        ").concat(currentYear, "\n      </button>\n    </div>\n  ");
}
/**
 * Template for month selection view
 *
 * @param locale - Locale configuration
 * @param currentMonth - Current selected month (0-11)
 * @returns Month selection HTML
 */
function monthSelectionTemplate(locale, currentMonth) {
    var months = locale.monthNamesShort.map(function (month, idx) {
        var isCurrentMonth = idx === currentMonth;
        var buttonClass = isCurrentMonth
            ? 'py-3 px-2 text-sm rounded-md bg-blue-500 text-white font-medium hover:bg-blue-600 focus:outline-none focus:ring-2 focus:ring-blue-500'
            : 'py-3 px-2 text-sm rounded-md bg-transparent hover:bg-gray-100 focus:outline-none focus:ring-2 focus:ring-blue-500 text-gray-800';
        return "\n      <button\n        type=\"button\"\n        class=\"".concat(buttonClass, "\"\n        data-month=\"").concat(idx, "\"\n        aria-selected=\"").concat(isCurrentMonth, "\"\n        aria-label=\"").concat(locale.monthNames[idx], "\"\n      >\n        ").concat(month, "\n      </button>\n    ");
    });
    return "\n    <div class=\"month-grid grid grid-cols-3 gap-2 p-2\">\n      ".concat(months.join(''), "\n    </div>\n  ");
}
/**
 * Template for year selection view
 *
 * @param startYear - Start year
 * @param endYear - End year
 * @param currentYear - Current selected year
 * @returns Year selection HTML
 */
function yearSelectionTemplate(startYear, endYear, currentYear) {
    var years = [];
    for (var year = startYear; year <= endYear; year++) {
        var isCurrentYear = year === currentYear;
        var yearClass = isCurrentYear
            ? 'py-3 px-2 text-center text-sm rounded-md bg-blue-500 text-white font-medium hover:bg-blue-600 focus:outline-none focus:ring-2 focus:ring-blue-500'
            : 'py-3 px-2 text-center text-sm rounded-md bg-transparent hover:bg-gray-100 focus:outline-none focus:ring-2 focus:ring-blue-500 text-gray-800';
        years.push("\n      <button\n        type=\"button\"\n        class=\"".concat(yearClass, "\"\n        data-year=\"").concat(year, "\"\n        aria-selected=\"").concat(isCurrentYear, "\"\n      >\n        ").concat(year, "\n      </button>\n    "));
    }
    // Navigation to previous/next year ranges
    var prevYearsBtn = "\n    <button\n      type=\"button\"\n      class=\"py-2 px-2 text-center text-sm rounded-md bg-gray-100 text-gray-600 hover:bg-gray-200 focus:outline-none focus:ring-2 focus:ring-blue-500\"\n      data-year-nav=\"prev\"\n      aria-label=\"Previous years\"\n    >\n      ".concat(startYear - 1, "...\n    </button>\n  ");
    var nextYearsBtn = "\n    <button\n      type=\"button\"\n      class=\"py-2 px-2 text-center text-sm rounded-md bg-gray-100 text-gray-600 hover:bg-gray-200 focus:outline-none focus:ring-2 focus:ring-blue-500\"\n      data-year-nav=\"next\"\n      aria-label=\"Next years\"\n    >\n      ...".concat(endYear + 1, "\n    </button>\n  ");
    return "\n    <div class=\"year-selection\">\n      <div class=\"year-navigation flex justify-between mb-2 px-2\">\n        ".concat(prevYearsBtn, "\n        <span class=\"text-gray-700 font-medium\">").concat(startYear, "-").concat(endYear, "</span>\n        ").concat(nextYearsBtn, "\n      </div>\n      <div class=\"year-grid grid grid-cols-4 gap-2 p-2\">\n        ").concat(years.join(''), "\n      </div>\n    </div>\n  ");
}
/**
 * Create placeholder template with placeholder text
 *
 * @param placeholder - Placeholder text to display
 * @returns HTML string for the placeholder
 */
var placeholderTemplate = function (placeholder) {
    return "<span class=\"text-gray-500\">".concat(placeholder, "</span>");
};
exports.placeholderTemplate = placeholderTemplate;
/**
 * Create a template for the display wrapper
 */
function displayWrapperTemplate(classes) {
    if (classes === void 0) { classes = ''; }
    return "\n    <div class=\"kt-datepicker-display-wrapper relative w-full ".concat(classes, "\"\n      role=\"combobox\"\n      aria-haspopup=\"dialog\"\n      aria-expanded=\"false\"\n    >\n    </div>\n  ");
}
/**
 * Create a template for the display element
 */
function displayElementTemplate(placeholder, classes) {
    if (classes === void 0) { classes = ''; }
    return "\n    <div class=\"kt-datepicker-display-element py-2 px-3 border rounded cursor-pointer ".concat(classes, "\"\n      tabindex=\"0\"\n      role=\"textbox\"\n      aria-label=\"").concat(placeholder, "\"\n      data-placeholder=\"").concat(placeholder, "\"\n    >\n      <span class=\"kt-datepicker-display-text\"></span>\n    </div>\n  ");
}


/***/ }),

/***/ 9742:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


/**
 * KTUI - Free & Open-Source Tailwind UI Components by Keenthemes
 * Copyright 2025 by Keenthemes Inc
 */
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.KTScrollspy = void 0;
var data_1 = __webpack_require__(8716);
var dom_1 = __webpack_require__(9010);
var event_handler_1 = __webpack_require__(5183);
var component_1 = __webpack_require__(2658);
var KTScrollspy = /** @class */ (function (_super) {
    __extends(KTScrollspy, _super);
    function KTScrollspy(element, config) {
        var _this = _super.call(this) || this;
        _this._name = 'scrollspy';
        _this._defaultConfig = {
            target: 'body',
            offset: 0,
            smooth: true,
        };
        _this._config = _this._defaultConfig;
        _this._targetElement = null;
        _this._anchorElements = null;
        if (data_1.default.has(element, _this._name))
            return _this;
        _this._init(element);
        _this._buildConfig(config);
        if (!_this._element)
            return _this;
        var targetElement = _this._getTarget() === 'body'
            ? document
            : dom_1.default.getElement(_this._getTarget());
        if (!targetElement)
            return _this;
        _this._targetElement = targetElement;
        _this._anchorElements = _this._element.querySelectorAll('[data-kt-scrollspy-anchor]');
        if (!_this._anchorElements)
            return _this;
        _this._handlers();
        _this._update();
        return _this;
    }
    KTScrollspy.prototype._getTarget = function () {
        return (this._element.getAttribute('data-kt-scrollspy-target') ||
            this._getOption('target'));
    };
    KTScrollspy.prototype._handlers = function () {
        var _this = this;
        if (!this._anchorElements)
            return;
        this._targetElement.addEventListener('scroll', function () {
            _this._anchorElements.forEach(function (anchorElement) {
                _this._updateAnchor(anchorElement);
            });
        });
        event_handler_1.default.on(this._element, '[data-kt-scrollspy-anchor]', 'click', function (event, target) {
            event.preventDefault();
            _this._scrollTo(target);
        });
    };
    KTScrollspy.prototype._scrollTo = function (anchorElement) {
        if (!anchorElement)
            return;
        var sectionElement = dom_1.default.getElement(anchorElement.getAttribute('href'));
        if (!sectionElement)
            return;
        var targetElement = this._targetElement === document ? window : this._targetElement;
        if (!targetElement)
            return;
        var offset = parseInt(this._getOption('offset'));
        if (anchorElement.getAttribute('data-kt-scrollspy-anchor-offset')) {
            offset = parseInt(anchorElement.getAttribute('data-kt-scrollspy-anchor-offset'));
        }
        var scrollTop = sectionElement.offsetTop - offset;
        if ('scrollTo' in targetElement) {
            targetElement.scrollTo({
                top: scrollTop,
                left: 0,
                behavior: this._getOption('smooth') ? 'smooth' : 'instant',
            });
        }
    };
    KTScrollspy.prototype._updateAnchor = function (anchorElement) {
        var sectionElement = dom_1.default.getElement(anchorElement.getAttribute('href'));
        if (!sectionElement)
            return;
        if (!dom_1.default.isVisible(anchorElement))
            return;
        if (!this._anchorElements)
            return;
        var scrollPosition = this._targetElement === document
            ? document.documentElement.scrollTop || document.body.scrollTop
            : this._targetElement.scrollTop;
        var offset = parseInt(this._getOption('offset'));
        if (anchorElement.getAttribute('data-kt-scrollspy-anchor-offset')) {
            offset = parseInt(anchorElement.getAttribute('data-kt-scrollspy-anchor-offset'));
        }
        var offsetTop = sectionElement.offsetTop;
        if (scrollPosition + offset >= offsetTop) {
            this._anchorElements.forEach(function (anchorElement) {
                anchorElement.classList.remove('active');
            });
            var payload = { element: anchorElement };
            this._fireEvent('activate', payload);
            this._dispatchEvent('activate', payload);
            anchorElement.classList.add('active');
            var parentAnchorElements = dom_1.default.parents(anchorElement, '[data-kt-scrollspy-group]');
            if (parentAnchorElements) {
                parentAnchorElements.forEach(function (parentAnchorElement) {
                    var _a;
                    (_a = parentAnchorElement
                        .querySelector('[data-kt-scrollspy-anchor]')) === null || _a === void 0 ? void 0 : _a.classList.add('active');
                });
            }
        }
    };
    KTScrollspy.prototype._update = function () {
        var _this = this;
        if (!this._anchorElements)
            return;
        this._anchorElements.forEach(function (anchorElement) {
            _this._updateAnchor(anchorElement);
        });
    };
    KTScrollspy.prototype._isActive = function (anchorElement) {
        return anchorElement.classList.contains('active');
    };
    KTScrollspy.prototype.updateAnchor = function (anchorElement) {
        this._updateAnchor(anchorElement);
    };
    KTScrollspy.prototype.isActive = function (anchorElement) {
        return this._isActive(anchorElement);
    };
    KTScrollspy.prototype.update = function () {
        this.update();
    };
    KTScrollspy.prototype.scrollTo = function (anchorElement) {
        this._scrollTo(anchorElement);
    };
    KTScrollspy.getInstance = function (element) {
        if (!element)
            return null;
        if (data_1.default.has(element, 'scrollspy')) {
            return data_1.default.get(element, 'scrollspy');
        }
        if (element.getAttribute('data-kt-scrollspy')) {
            return new KTScrollspy(element);
        }
        return null;
    };
    KTScrollspy.getOrCreateInstance = function (element, config) {
        return this.getInstance(element) || new KTScrollspy(element, config);
    };
    KTScrollspy.createInstances = function () {
        var elements = document.querySelectorAll('[data-kt-scrollspy]');
        elements.forEach(function (element) {
            new KTScrollspy(element);
        });
    };
    KTScrollspy.init = function () {
        KTScrollspy.createInstances();
    };
    return KTScrollspy;
}(component_1.default));
exports.KTScrollspy = KTScrollspy;
if (typeof window !== 'undefined') {
    window.KTScrollspy = KTScrollspy;
}


/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	!function() {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = function(exports, definition) {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	!function() {
/******/ 		__webpack_require__.o = function(obj, prop) { return Object.prototype.hasOwnProperty.call(obj, prop); }
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	!function() {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = function(exports) {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	}();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __webpack_exports__ = __webpack_require__(8156);
/******/ 	
/******/ 	return __webpack_exports__;
/******/ })()
;
});